DetectionId,ingestionTime,MITREMatrix,Tactic,TechniqueId,TechniqueName,Platform,DetectionType,DetectionService,DetectionName,DetectionDescription,ConnectorId,DataTypes,Query,QueryFrequency,QueryPeriod,TriggerOperator,TriggerThreshold,DetectionSeverity,DetectionUrl,IngestedDate,fileName
44a555d8-ecee-4a25-95ce-055879b4b14b,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Detection,Azure Sentinel Community Github,High count of connections by client IP on many ports,"'Identifies when 30 or more ports are used for a given client IP in 10 minutes occurring on the IIS server.
This could be indicative of attempted port scanning or exploit attempt at internet facing web applications.  
This could also simply indicate a misconfigured service or device.
References:
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = 1d;
let timeBin = 10m;
let portThreshold = 30;
W3CIISLog
| where TimeGenerated >= ago(timeFrame)
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""775"", ""The referenced account is currently locked out and cannot be logged on to."",
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."",
scWin32Status_Hex =~ ""532"", ""Logon failure: The specified account password has expired."",
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
// Count of attempts by client IP on many ports
| summarize makeset(sPort), makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), ConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP
| extend portCount = arraylength(set_sPort)
| where portCount >= portThreshold
| project TimeGenerated, cIP, set_sPort, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, ConnectionsCount, portCount
| order by portCount
| extend timestamp = TimeGenerated, IPCustomEntity = cIP
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HighPortCountByClientIP.yaml,2020-10-04,HighPortCountByClientIP.yaml
f845881e-2500-44dc-8ed7-b372af3e1e25,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Detection,Azure Sentinel Community Github,Anomalous User Agent connection attempt,"'Identifies connection attempts (success or fail) from clients with very short or very long User Agent strings and with less than 100 connection attempts.'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = 1d;
let short_uaLength = 5;
let long_uaLength = 1000;
let c_threshold = 100;
W3CIISLog 
| where TimeGenerated >= ago(timeFrame)
// Exclude local IPs as these create noise
| where cIP !startswith ""192.168."" and cIP != ""::1""
| where isnotempty(csUserAgent) and csUserAgent !in~ (""-"", ""MSRPC"") and (string_size(csUserAgent) <= short_uaLength or string_size(csUserAgent) >= long_uaLength)
| extend csUserAgent_size = string_size(csUserAgent)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ConnectionCount = count() by Computer, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, scSubStatus, scWin32Status
| where ConnectionCount < c_threshold
| extend timestamp = StartTimeUtc, AccountCustomEntity = csUserName, HostCustomEntity = Computer, IPCustomEntity = cIP
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/AnomomlousUserAgentConnection.yaml,2020-10-04,AnomomlousUserAgentConnection.yaml
be52662c-3b23-435a-a6fa-f39bdfc849e6,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Detection,Azure Sentinel Community Github,High Number of Urgent Vulnerabilities Detected,"'This Creates an incident when a host has a high number of Urgent, severity 5, vulnerabilities detected.'
",QualysVulnerabilityManagement,QualysHostDetection_CL,"
let timeframe = ago(1h);
let threshold = 10;
QualysHostDetection_CL
| where TimeGenerated >= timeframe
| mv-expand todynamic(Detections_s)
| where Detections_s.Severity == ""5""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by NetBios_s, IPAddress
| where count_ >= threshold
| extend timestamp = StartTime, HostCustomEntity = NetBios_s, IPCustomEntity = IPAddress
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/QualysVM/HighNumberofVulnDetected.yaml,2020-10-04,HighNumberofVulnDetected.yaml
84cf1d59-f620-4fee-b569-68daf7008b7b,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Detection,Azure Sentinel Community Github,New High Severity Vulnerability Detected Across Multiple Hosts,"'This creates an incident when a new high severity vulnerability is detected across multilple hosts'
",QualysVulnerabilityManagement,QualysHostDetection_CL,"
let timeframe = ago(1h);
let threshold = 10;
QualysHostDetection_CL
| where TimeGenerated >= timeframe
| mv-expand todynamic(Detections_s)
| extend Status = tostring(Detections_s.Status), Vulnerability = tostring(Detections_s.Results), Severity = tostring(Detections_s.Severity)
| where Status =~ ""New"" and Severity == ""5""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), dcount(NetBios_s) by tostring(Detections_s.QID)
| where dcount_NetBios_s >= threshold
| extend timestamp = StartTime
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/QualysVM/NewHighSeverityVulnDetectedAcrossMulitpleHosts.yaml,2020-10-04,NewHighSeverityVulnDetectedAcrossMulitpleHosts.yaml
3de523b5-9608-43d5-801e-732c741dd82e,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Hunting Query,Azure Sentinel Community Github,Rare User Agent strings,"'This will check for Rare User Agent strings over the last 3 days.  This can indicate potential probing of your IIS servers.'
",AzureMonitor(IIS),W3CIISLog,"
let timeframe = 3d;
W3CIISLog | where TimeGenerated >= ago(timeframe)
// The below line can be used to exclude local IPs if these create noise
//| where cIP !startswith ""192.168."" and cIP != ""::1""
| where isnotempty(csUserAgent) and csUserAgent !in~ (""-"", ""MSRPC"")
| extend csUserAgent_size = string_size(csUserAgent)
| project TimeGenerated, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, 
scSubStatus, scWin32Status, csHost 
| join (
    W3CIISLog | where TimeGenerated >= ago(timeframe) 
	  // The below line can be used to exclude local IPs if these create noise
    //| where cIP !startswith ""192.168."" and cIP != ""::1""
    | where isnotempty(csUserAgent) and csUserAgent !in~ (""-"", ""MSRPC"") 
    | extend csUserAgent_size = string_size(csUserAgent)
    | summarize csUserAgent_count = count() by bin(csUserAgent_size, 1)
    | top 20 by csUserAgent_count asc nulls last 
) on csUserAgent_size
| project TimeGenerated, sSiteName, sPort, sIP, cIP, csUserAgent, csUserAgent_size, csUserAgent_count, csUserName , csMethod, csUriStem, 
scStatus, scSubStatus, scWin32Status, csHost
| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName 
",,,,,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/RareUserAgentStrings.yaml,2020-10-04,RareUserAgentStrings.yaml
4edbb420-2df7-4089-9906-c335f065803e,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Hunting Query,Azure Sentinel Community Github,Same IP address with multiple csUserAgent,"'This alerts when the same client IP (cIP) is connecting with more than 1 but less than 15 different useragent string (csUserAgent) in less than 1 hour.
We limit to 50 or less connections to avoid high traffic sites. This may indicate malicious activity as this is a method of probing an environment
References: Status code mappings for your convenience
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = ago(1h);
W3CIISLog
| where TimeGenerated >= timeFrame
| where scStatus !startswith ""20"" and scStatus !startswith ""30"" and cIP !startswith ""192.168."" and cIP != sIP and cIP != ""::1""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(csUserAgent), ConnectionCount = count() 
by Computer, sSiteName, sIP, sPort, cIP, csMethod
| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)
| where  csUserAgentPerIPCount between ( 2 .. 15 ) and ConnectionCount <=50
| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/ClientIPwithManyUserAgents.yaml,2020-10-04,ClientIPwithManyUserAgents.yaml
a787a819-40df-4c9f-a5ae-850d5a2a0cf6,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1190,Exploit Public-Facing Application,SaaS,Hunting Query,Azure Sentinel Community Github,URI requests from single client,"'This will look for connections to files on the server that are requested by only a single client. This analytic will be effective where an actor is utilising relatively static operational IP addresses. The threshold can be modified. The larger the execution window for this query the more reliable the results returned.'
",AzureMonitor(IIS),W3CIISLog,"
let timeRange = 7d;
let clientThreshold = 1;
let data = W3CIISLog
//Get script files asmx, aspx
| where csUriStem contains "".as""
//Exclude local addresses, needs editing to matc your network configuration
| where cIP !startswith ""10."" and cIP !startswith ""fe80"" and cIP !startswith ""::"" and cIP !startswith ""127.""
| summarize makelist(cIP), count(TimeGenerated) by csUriStem, sSiteName, csUserAgent;
data
| mvexpand list_cIP
| distinct tostring(list_cIP), csUriStem, sSiteName, csUserAgent
| summarize dcount(list_cIP), makelist(list_cIP), makelist(sSiteName) by csUriStem, csUserAgent
| where dcount_list_cIP == clientThreshold 
//Uncomment to check to see if useragent is likely a browser
| where csUserAgent startswith ""Mozilla""
",,,,,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/RareClientFileAccess.yaml,2020-10-04,RareClientFileAccess.yaml
19e01883-15d8-4eb6-a7a5-3276cd668388,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,SaaS,Detection,Azure Sentinel Community Github,High count of failed attempts from same client IP,"'Identifies when 20 or more failed attempts from a given client IP in 1 minute occur on the IIS server.
This could be indicative of an attempted brute force. This could also simply indicate a misconfigured service or device.
Recommendations: Validate that these are expected connections from the given Client IP.  If the client IP is not recognized, 
potentially block these connections at the edge device.
If these are expected connections, verify the credentials are properly configured on the system, service, application or device 
that is associated with the client IP.
References:
IIS status code mapping: https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping: https://msdn.microsoft.com/library/cc231199.aspx'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = 1d;
let timeBin = 1m;
let failedThreshold = 20;
W3CIISLog
| where TimeGenerated >= ago(timeFrame)
| where scStatus in (""401"",""403"")
| where csUserName != ""-""
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""775"", ""The referenced account is currently locked out and cannot be logged on to."",
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."",
scWin32Status_Hex =~ ""532"", ""Logon failure: The specified account password has expired."",
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
// Count of failed attempts from same client IP
| summarize makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP
| where FailedConnectionsCount >= failedThreshold
| project TimeGenerated, cIP, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount
| order by FailedConnectionsCount
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = cIP
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HighFailedLogonCountByClientIP.yaml,2020-10-04,HighFailedLogonCountByClientIP.yaml
884c4957-70ea-4f57-80b9-1bca3890315b,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,SaaS,Detection,Azure Sentinel Community Github,High count of failed logons by a user,"'Identifies when 100 or more failed attempts by a given user in 10 minutes occur on the IIS Server.
This could be indicative of attempted brute force based on known account information.
This could also simply indicate a misconfigured service or device. 
References:
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = 1d;
let timeBin = 10m;
let failedThreshold = 100;
W3CIISLog
| where TimeGenerated >= ago(timeFrame)
| where scStatus in (""401"",""403"")
| where csUserName != ""-""
// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI
| extend csUriQuery = iff(csUriQuery startswith ""MailboxId="", tostring(split(csUriQuery, ""&"")[0]) , csUriQuery )
| extend csUriQuery = iff(csUriQuery startswith ""X-ARR-CACHE-HIT="", strcat(tostring(split(csUriQuery, ""&"")[0]),tostring(split(csUriQuery, ""&"")[1])) , csUriQuery )
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""775"", ""The referenced account is currently locked out and cannot be logged on to."",
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."",
scWin32Status_Hex =~ ""532"", ""Logon failure: The specified account password has expired."",
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
// Count of failed logons by a user
| summarize makeset(decodedUriQuery), makeset(cIP), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), csUserName, Computer, sIP
| where FailedConnectionsCount >= failedThreshold
| project TimeGenerated, csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_cIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount
| order by FailedConnectionsCount
| extend timestamp = TimeGenerated, AccountCustomEntity = csUserName, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HighFailedLogonCountByUser.yaml,2020-10-04,HighFailedLogonCountByUser.yaml
1fa1528e-f746-4794-8a41-14827f4cb798,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Detection,Azure Sentinel Community Github,PulseConnectSecure - Large Number of Distinct Failed User Logins,"'This query identifies evidence of failed login attempts from a large number of distinct users on a Pulse Connect Secure VPN server'
",PulseConnectSecure,Syslog,"
let timeframe = ago(1h);
let threshold = 100;
PulseConnectSecure
| where TimeGenerated >= timeframe
| where Messages startswith ""Login failed""
| summarize dcount(User) by Computer, bin(TimeGenerated, 15m)
| where dcount_User > threshold
| extend timestamp = TimeGenerated, HostCustomEntity = Computer
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/PulseConnectSecure/PulseConnectSecureVPN-DistinctFailedUserLogin.yaml,2020-10-04,PulseConnectSecureVPN-DistinctFailedUserLogin.yaml
34663177-8abf-4db1-b0a4-5683ab273f44,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Detection,Azure Sentinel Community Github,PulseConnectSecure - Potential Brute Force Attempts,"'This query identifies evidence of potential brute force attack by looking at multiple failed attempts to log into the VPN server'
",PulseConnectSecure,Syslog,"
let timeframe = ago(1h);
let threshold = 20;
PulseConnectSecure
| where TimeGenerated >= timeframe
| where Messages contains ""Login failed""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by User, Source_IP
| where count_ > threshold
| extend timestamp = StartTime, AccountCustomEntity = User, IPCustomEntity = Source_IP
",1h,1h,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/PulseConnectSecure/PulseConnectSecureVPN-BruteForce.yaml,2020-10-04,PulseConnectSecureVPN-BruteForce.yaml
e7ec9fa6-e7f7-41ed-a34b-b956837a3ee6,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Detection,Azure Sentinel Community Github,Failed logon attempts in authpriv,"'Identifies failed logon attempts from unknown users in Syslog authpriv logs. The unknown user means the account that tried to log in 
isn't provisioned on the machine. A few hits could indicate someone attempting to access a machine they aren't authorized to access. 
If there are many of hits, especially from outside your network, it could indicate a brute force attack. 
Default threshold for logon attempts is 15.'
",Syslog,Syslog,"
let startdate = 1d;
let threshold = 15;
// Below pulls messages from syslog-authpriv logs where there was an authentication failure with an unknown user.
// IP address of system attempting logon is also extracted from the SyslogMessage field. Some of these messages
// are aggregated.
let authfail = Syslog
| where TimeGenerated >= ago(startdate)     
| where Facility =~ ""authpriv""   // looks at authpriv messages
| where SyslogMessage contains ""authentication failure"" and SyslogMessage contains "" uid=0""
| parse SyslogMessage with * ""rhost="" ExternalIP
| project TimeGenerated, Computer, ProcessName, HostIP, ExternalIP, ProcessID;  
// Below pulls messages from syslog-authpriv logs that show each instance an unknown user tried to logon. 
let userfail = Syslog 
| where TimeGenerated >= ago(startdate)
| where Facility =~ ""authpriv"" 
| where SyslogMessage contains ""user unknown""
| project TimeGenerated, Computer, HostIP, ProcessID;
// Join the two log messages above
let userauthfail = authfail | join (userfail) on Computer, HostIP, ProcessID
| project TimeGenerated, Computer, HostIP, ExternalIP, ProcessID ;
// Extract the EventTime of the first logon attempt
let firstfail = userauthfail
| summarize arg_min(TimeGenerated, *) by Computer, ExternalIP
| project Computer, ExternalIP, FirstLogonAttempt = TimeGenerated;
// Extract the EventTime of the last logon attempt
let lastfail = userauthfail
| summarize arg_max(TimeGenerated, *) by Computer, ExternalIP
| project Computer, ExternalIP, LatestLogonAttempt = TimeGenerated;
// Join first and last logon attempt data and calculate the time between them (AttemptPeriodLength).
let faildates = firstfail | join (lastfail) on Computer, ExternalIP
| project ExternalIP, Computer, FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts = LatestLogonAttempt - FirstLogonAttempt;
// Count the number of failed logon attempts by External IP and internal machine
let totalfails = userauthfail
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TotalLogonAttempts = count() by ExternalIP, Computer, HostIP
| project StartTimeUtc, EndTimeUtc, ExternalIP, Computer, HostIP, TotalLogonAttempts;
// Combine total attempts with timing data from above
let finalfails = totalfails | join (faildates) on Computer, ExternalIP
| project StartTimeUtc, EndTimeUtc, SourceAddress = ExternalIP, DestinationHost = Computer, DestinationIP = HostIP, TotalLogonAttempts, FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts
| order by DestinationHost asc nulls last;
finalfails 
| where TotalLogonAttempts >= threshold
| extend timestamp = StartTimeUtc, HostCustomEntity = DestinationHost, IPCustomEntity = DestinationIP
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/FailedLogonAttempts_UnknownUser.yaml,2020-10-04,FailedLogonAttempts_UnknownUser.yaml
e1ce0eab-10d1-4aae-863f-9a383345ba88,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Detection,Azure Sentinel Community Github,SSH - Potential Brute Force,"'Identifies an IP address that had 15 failed attempts to sign in via SSH in a 4 hour block during a 24 hour time period.'
",Syslog,Syslog,"
let timeframe = 1d;
let threshold = 15;
Syslog
| where TimeGenerated >= ago(timeframe)
| where SyslogMessage contains ""Failed password for invalid user""
| where ProcessName =~ ""sshd"" 
| parse kind=relaxed SyslogMessage with * ""invalid user"" user "" from "" ip "" port"" port "" ssh2""
| project user, ip, port, SyslogMessage, EventTime
| summarize EventTimes = make_list(EventTime), PerHourCount = count() by ip, bin(EventTime, 4h), user
| where PerHourCount > threshold
| mvexpand EventTimes
| extend EventTimes = tostring(EventTimes) 
| summarize StartTimeUtc = min(EventTimes), EndTimeUtc = max(EventTimes), UserList = makeset(user), sum(PerHourCount) by IPAddress = ip
| extend UserList = tostring(UserList) 
| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress, AccountCustomEntity = UserList
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/ssh_potentialBruteForce.yaml,2020-10-04,ssh_potentialBruteForce.yaml
2391ce61-8c8d-41ac-9723-d945b2e90720,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Windows,Detection,Azure Sentinel Community Github,Excessive Windows logon failures,"'User has over 50 Windows logon failures today and at least 33% of the count of logon failures over the previous 7 days.'
",SecurityEvents,SecurityEvent,"
let starttime = 8d;
let endtime = 1d;
let threshold = 0.333;
let countlimit = 50;
SecurityEvent
| where TimeGenerated >= ago(endtime)
| where EventID == 4625 and AccountType =~ ""User""
| where IpAddress !in (""127.0.0.1"", ""::1"")
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), CountToday = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress
| join kind=leftouter (
    SecurityEvent 
    | where TimeGenerated between (ago(starttime) .. ago(endtime))
    | where EventID == 4625 and AccountType =~ ""User""
    | where IpAddress !in (""127.0.0.1"", ""::1"")
    | summarize CountPrev7day = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress
) on EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress
| where CountToday >= coalesce(CountPrev7day,0)*threshold and CountToday >= countlimit
//SubStatus Codes are detailed here - https://docs.microsoft.com/windows/security/threat-protection/auditing/event-4625
| extend Reason = case(
SubStatus =~ '0xC000005E', 'There are currently no logon servers available to service the logon request.',
SubStatus =~ '0xC0000064', 'User logon with misspelled or bad user account',
SubStatus =~ '0xC000006A', 'User logon with misspelled or bad password',    
SubStatus =~ '0xC000006D', 'Bad user name or password',
SubStatus =~ '0xC000006E', 'Unknown user name or bad password',
SubStatus =~ '0xC000006F', 'User logon outside authorized hours',
SubStatus =~ '0xC0000070', 'User logon from unauthorized workstation',
SubStatus =~ '0xC0000071', 'User logon with expired password',
SubStatus =~ '0xC0000072', 'User logon to account disabled by administrator',
SubStatus =~ '0xC00000DC', 'Indicates the Sam Server was in the wrong state to perform the desired operation',  
SubStatus =~ '0xC0000133', 'Clocks between DC and other computer too far out of sync',
SubStatus =~ '0xC000015B', 'The user has not been granted the requested logon type (aka logon right) at this machine',
SubStatus =~ '0xC000018C', 'The logon request failed because the trust relationship between the primary domain and the trusted domain failed',
SubStatus =~ '0xC0000192', 'An attempt was made to logon, but the Netlogon service was not started',
SubStatus =~ '0xC0000193', 'User logon with expired account',
SubStatus =~ '0xC0000224', 'User is required to change password at next logon',
SubStatus =~ '0xC0000225', 'Evidently a bug in Windows and not a risk',
SubStatus =~ '0xC0000234', 'User logon with account locked',
SubStatus =~ '0xC00002EE', 'Failure Reason: An Error occurred during Logon',
SubStatus =~ '0xC0000413', 'Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine',
strcat('Unknown reason substatus: ', SubStatus))
| extend WorkstationName = iff(WorkstationName == ""-"" or isempty(WorkstationName), Computer , WorkstationName) 
| project StartTime, EndTime, EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, Computer, WorkstationName, IpAddress, CountToday, CountPrev7day, Avg7Day = round(CountPrev7day*1.00/7,2)
| summarize StartTime = min(StartTime), EndTime = max(EndTime), Computer = make_set(Computer,128), IpAddressList = make_set(IpAddress,128), sum(CountToday), sum(CountPrev7day), avg(Avg7Day) 
by EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, WorkstationName
| order by sum_CountToday desc nulls last 
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = WorkstationName
",1d,8d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ExcessiveLogonFailures.yaml,2020-10-04,ExcessiveLogonFailures.yaml
0777f138-e5d8-4eab-bec1-e11ddfbc2be2,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Windows,Detection,Azure Sentinel Community Github,Failed logon attempts by valid accounts within 10 mins,"'Identifies when failed logon attempts are 20 or higher during a 10 minute period (2 failed logons per minute minimum) from valid account.'
",SecurityEvents,SecurityEvent,"
let timeframe = 10m;
let threshold = 20;
SecurityEvent 
| where TimeGenerated >= ago(timeframe)
| where EventID == 4625
| where AccountType =~ ""User""
| where SubStatus !='0xc0000064' and Account !in ('\\', '-\\-')
// SubStatus '0xc0000064' signifies 'Account name does not exist'
| extend ResourceId = column_ifexists(""_ResourceId"", _ResourceId), SourceComputerId = column_ifexists(""SourceComputerId"", SourceComputerId)
| extend Reason = case(
SubStatus =~ '0xC000005E', 'There are currently no logon servers available to service the logon request.',
SubStatus =~ '0xC0000064', 'User logon with misspelled or bad user account',
SubStatus =~ '0xC000006A', 'User logon with misspelled or bad password', 
SubStatus =~ '0xC000006D', 'Bad user name or password',
SubStatus =~ '0xC000006E', 'Unknown user name or bad password',
SubStatus =~ '0xC000006F', 'User logon outside authorized hours',
SubStatus =~ '0xC0000070', 'User logon from unauthorized workstation',
SubStatus =~ '0xC0000071', 'User logon with expired password',
SubStatus =~ '0xC0000072', 'User logon to account disabled by administrator',
SubStatus =~ '0xC00000DC', 'Indicates the Sam Server was in the wrong state to perform the desired operation', 
SubStatus =~ '0xC0000133', 'Clocks between DC and other computer too far out of sync',
SubStatus =~ '0xC000015B', 'The user has not been granted the requested logon type (aka logon right) at this machine',
SubStatus =~ '0xC000018C', 'The logon request failed because the trust relationship between the primary domain and the trusted domain failed',
SubStatus =~ '0xC0000192', 'An attempt was made to logon, but the Netlogon service was not started',
SubStatus =~ '0xC0000193', 'User logon with expired account',
SubStatus =~ '0xC0000224', 'User is required to change password at next logon',
SubStatus =~ '0xC0000225', 'Evidently a bug in Windows and not a risk',
SubStatus =~ '0xC0000234', 'User logon with account locked',
SubStatus =~ '0xC00002EE', 'Failure Reason: An Error occurred during Logon',
SubStatus =~ '0xC0000413', 'Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine',
strcat('Unknown reason substatus: ', SubStatus))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), FailedLogonCount = count() by EventID, 
Activity, Computer, Account, TargetAccount, TargetUserName, TargetDomainName, 
LogonType, LogonTypeName, LogonProcessName, Status, SubStatus, Reason, ResourceId, SourceComputerId, WorkstationName, IpAddress
| where FailedLogonCount >= threshold
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress",10m,10m,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/gte_6_FailedLogons_10m.yaml,2020-10-04,gte_6_FailedLogons_10m.yaml
cf3ede88-a429-493b-9108-3e46d3c741f7,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Windows,Detection,Azure Sentinel Community Github,SecurityEvent - Multiple authentication failures followed by a success,"'Identifies accounts who have failed to logon to the domain multiple times in a row, followed by a successful authentication
within a short time frame. Multiple failed attempts followed by a success can be an indication of a brute force attempt or
possible mis-configuration of a service account within an environment.
The lookback is set to 6h and the authentication window and threshold are set to 1h and 5, meaning we need to see a minimum
of 5 failures followed by a success for an account within 1 hour to surface an alert.'
",SecurityEvents,SecurityEvent,"
let timeRange = 6h;
let authenticationWindow = 1h;
let authenticationThreshold = 5;
SecurityEvent
| where TimeGenerated > ago(timeRange)
| where EventID == 4624 or EventID == 4625
| where IpAddress != ""-"" and isnotempty(Account)
| extend Outcome = iff(EventID == 4624, ""Success"", ""Failure"")
// bin outcomes into 5 minute windows to reduce the volume of data
| summarize OutcomeCount=count() by Account, IpAddress, Computer, Outcome, bin(TimeGenerated, 5m)
| project TimeGenerated, Account, IpAddress, Computer, Outcome, OutcomeCount
// sort ready for sessionizing - by account and time of the authentication outcome
| sort by Account asc, TimeGenerated asc
| serialize 
// sessionize into failure groupings until either the account changes or there is a success
| extend SessionStartedUtc = row_window_session(TimeGenerated, timeRange, authenticationWindow, Account != prev(Account) or prev(Outcome) == ""Success"")
// count the failures in each session
| summarize FailureCountBeforeSuccess=sumif(OutcomeCount, Outcome == ""Failure""), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), makelist(Outcome), makeset(Computer), makeset(IpAddress) by SessionStartedUtc, Account
// the session must not start with a success, and must end with one
| where array_index_of(list_Outcome, ""Success"") != 0
| where array_index_of(list_Outcome, ""Success"") == array_length(list_Outcome) - 1
| project-away SessionStartedUtc, list_Outcome 
// where the number of failures before the success is above the threshold 
| where FailureCountBeforeSuccess >= authenticationThreshold
// expand out ip and computer for customer entity assignment
| mvexpand set_IpAddress, set_Computer
| extend IpAddress = tostring(set_IpAddress), Computer = tostring(set_Computer)
| extend timestamp=StartTime, AccountCustomEntity=Account, HostCustomEntity=Computer, IPCustomEntity=IpAddress
",6h,6h,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/MultipleFailedFollowedBySuccess.yaml,2020-10-04,MultipleFailedFollowedBySuccess.yaml
223db5c1-1bf8-47d8-8806-bed401b356a4,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Detection,Azure Sentinel Community Github,Failed login attempts to Azure Portal,"'Identifies failed login attempts in the Azure Active Directory SigninLogs to the Azure Portal.  Many failed logon 
attempts or some failed logon attempts from multiple IPs could indicate a potential brute force attack.  
The following are excluded due to success and non-failure results:
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
0 - successful logon
50125 - Sign-in was interrupted due to a password reset or password registration entry.
50140 - This error occurred due to 'Keep me signed in' interrupt when the user was signing-in.'
",AzureActiveDirectory,SigninLogs,"
let timeRange = 1d;
let lookBack = 7d;
let threshold_Failed = 5;
let threshold_FailedwithSingleIP = 20;
let threshold_IPAddressCount = 2;
let isGUID = ""[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}"";
let azPortalSignins = materialize(SigninLogs
| where TimeGenerated >= ago(lookBack)
// Azure Portal only
| where AppDisplayName =~ ""Azure Portal"")
;
let successPortalSignins = azPortalSignins
| where TimeGenerated >= ago(timeRange)
// Azure Portal only and exclude non-failure Result Types
| where ResultType in (""0"", ""50125"", ""50140"")
// Tagging identities not resolved to friendly names
//| extend Unresolved = iff(Identity matches regex isGUID, true, false)
| distinct TimeGenerated, UserPrincipalName, Id, ResultType
;
let failPortalSignins = azPortalSignins
| where TimeGenerated >= ago(timeRange)
// Azure Portal only and exclude non-failure Result Types
| where ResultType !in (""0"", ""50125"", ""50140"")
// Tagging identities not resolved to friendly names
| extend Unresolved = iff(Identity matches regex isGUID, true, false)
;
// Verify there is no success for the same connection attempt after the fail
let failnoSuccess = failPortalSignins | join kind= leftouter (
   successPortalSignins 
) on UserPrincipalName, Id
| where TimeGenerated > TimeGenerated1
| project-away TimeGenerated1, UserPrincipalName1, Id1, ResultType1
;
// Lookup up resolved identities from last 7 days
let identityLookup = azPortalSignins
| where TimeGenerated >= ago(lookBack)
| where not(Identity matches regex isGUID)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// Join resolved names to unresolved list from portal signins
let unresolvedNames = failnoSuccess | where Unresolved == true | join kind= inner (
   identityLookup 
) on UserId
| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName
| project-away lu_UserDisplayName, lu_UserPrincipalName;
// Join Signins that had resolved names with list of unresolved that now have a resolved name
let u_azPortalSignins = failnoSuccess | where Unresolved == false | union unresolvedNames;
u_azPortalSignins
| extend Status = strcat(ResultType, "": "", ResultDescription), OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), FailedLogonCount = count()
by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation
| mvexpand TimeGenerated, IPAddresses, Status
| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)
| project-away IPAddresses
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status, FailedLogonCount, IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation
| where (IPAddressCount >= threshold_IPAddressCount and FailedLogonCount >= threshold_Failed) or FailedLogonCount >= threshold_FailedwithSingleIP
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
",1d,7d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/FailedLogonToAzurePortal.yaml,2020-10-04,FailedLogonToAzurePortal.yaml
28b42356-45af-40a6-a0b4-a554cdfd5d8a,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Detection,Azure Sentinel Community Github,Brute force attack against Azure Portal,"'Identifies evidence of brute force activity against Azure Portal by highlighting multiple authentication failures 
and by a successful authentication within a given time window. 
(The query does not enforce any sequence - eg requiring the successful authentication to occur last.)
Default Failure count is 5, Default Success count is 1 and default Time Window is 20 minutes.
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.'
",AzureActiveDirectory,SigninLogs,"
let failureCountThreshold = 5;
let successCountThreshold = 1;
let timeRange = 1d;
let authenticationWindow = 20m;
SigninLogs
| where TimeGenerated >= ago(timeRange)
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| where AppDisplayName contains ""Azure Portal""
// Split out failure versus non-failure types
| extend FailureOrSuccess = iff(ResultType in (""0"", ""50125"", ""50140"", ""70043"", ""70044""), ""Success"", ""Failure"")
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), IPAddress = makeset(IPAddress), makeset(OS), makeset(Browser), makeset(City), 
makeset(ResultType), FailureCount = countif(FailureOrSuccess==""Failure""), SuccessCount = countif(FailureOrSuccess==""Success"") 
by bin(TimeGenerated, authenticationWindow), UserDisplayName, UserPrincipalName, AppDisplayName
| where FailureCount >= failureCountThreshold and SuccessCount >= successCountThreshold
| mvexpand IPAddress
| extend IPAddress = tostring(IPAddress)
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress 
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/SigninBruteForce-AzurePortal.yaml,2020-10-04,SigninBruteForce-AzurePortal.yaml
97ad74c4-fdd9-4a3f-b6bf-5e28f4f71e06,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Detection,Azure Sentinel Community Github,Brute Force Attack against GitHub Account,"'Attackers who are trying to guess your users' passwords or use brute-force methods to get in. If your organization is using SSO with Azure Active Directory, authentication logs to GitHub.com will be generated. Using the following query can help you identify a sudden increase in failed logon attempt of users.'
",AzureActiveDirectory,SigninLogs,"let LearningPeriod = 7d; 
let BinTime = 1h; 
let RunTime = 1h; 
let StartTime = 1h; 
let NumberOfStds = 3; 
let MinThreshold = 10.0; 
let EndRunTime = StartTime - RunTime; 
let EndLearningTime = StartTime + LearningPeriod; 
let GitHubFailedSSOLogins = (SigninLogs 
| where AppDisplayName == ""GitHub.com"" 
| where ResultType == 50056); 
GitHubFailedSSOLogins 
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime)) 
| summarize FailedLoginsCountInBinTime = count() by  UserPrincipalName, bin(TimeGenerated, BinTime) 
| summarize AvgOfFailedLoginsInLearning = avg(FailedLoginsCountInBinTime), StdOfFailedLoginsInLearning = stdev(FailedLoginsCountInBinTime) by UserPrincipalName, tostring(set_IPAddress)
| extend LearningThreshold = max_of(AvgOfFailedLoginsInLearning + StdOfFailedLoginsInLearning * NumberOfStds, MinThreshold)  
| join kind=innerunique ( 
  GitHubFailedSSOLogins 
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime)) 
  | summarize FailedLoginsCountInRunTime = count() by User = Identity 
) on UserPrincipalName 
| where FailedLoginsCountInRunTime > LearningThreshold
| extend AccountCustomEntity = UserPrincipalName , timestamp = TimeGenerated",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/Brute%20Force%20Attack%20against%20GitHub%20Account.yaml,2020-10-04,Brute%20Force%20Attack%20against%20GitHub%20Account.yaml
d3980830-dd9d-40a5-911f-76b44dfdce16,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Detection,Azure Sentinel Community Github,GitHub Signin Burst from Multiple Locations,"'This alerts when there Signin burst from multiple locations in GitHub (AAD SSO).'
",AzureActiveDirectory,SigninLogs,"let RunTime = 1h;
SigninLogs
| where TimeGenerated > ago(RunTime)
| where AppDisplayName == ""GitHub.com""
| where ResultType == 0
| summarize CountOfLocations = dcount(Location), Locations = make_set(Location) by UserPrincipalName
| where CountOfLocations > 1
| extend AccountCustomEntity = UserPrincipalName , timestamp = TimeGenerated
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/Sign-in%20Burst%20from%20Multiple%20Locations.yaml,2020-10-04,Sign-in%20Burst%20from%20Multiple%20Locations.yaml
48607a29-a26a-4abf-8078-a06dbdd174a4,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Detection,Azure Sentinel Community Github,Password spray attack against Azure AD application,"'Identifies evidence of password spray activity against Azure AD applications by looking for failures from multiple accounts from the same
IP address within a time window. If the number of accounts breaches the threshold just once, all failures from the IP address within the time range
are bought into the result. Details on whether there were successful authentications by the IP address within the time window are also included.
This can be an indicator that an attack was successful.
The default failure acccount threshold is 5, Default time window for failures is 20m and default look back window is 3 days
Note: Due to the number of possible accounts involved in a password spray it is not possible to map identities to a custom entity.
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.'
",AzureActiveDirectory,SigninLogs,"
let timeRange = 3d;
let lookBack = 7d;
let authenticationWindow = 20m;
let authenticationThreshold = 5;
let isGUID = ""[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}"";
let failureCodes = dynamic([50053, 50126, 50055]); // invalid password, account is locked - too many sign ins, expired password
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
// Lookup up resolved identities from last 7 days
let identityLookup = SigninLogs
| where TimeGenerated >= ago(lookBack)
| where not(Identity matches regex isGUID)
| where isnotempty(UserId)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// collect window threshold breaches
SigninLogs
| where TimeGenerated > ago(timeRange)
| where ResultType in(failureCodes)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), count() by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName, UserPrincipalName
| summarize FailedPrincipalCount = dcount(UserPrincipalName) by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName
| where FailedPrincipalCount >= authenticationThreshold
| summarize WindowThresholdBreaches = count() by IPAddress
| join kind= inner (
// where we breached a threshold, join the details back on all failure data
 SigninLogs
| where TimeGenerated > ago(timeRange)
| where ResultType in(failureCodes)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), make_set(FullLocation), FailureCount = count() by IPAddress, AppDisplayName, UserPrincipalName, UserDisplayName, Identity, UserId
// lookup any unresolved identities
| extend UnresolvedUserId = iff(Identity matches regex isGUID, UserId, """")
| join kind= leftouter (
 identityLookup 
) on $left.UnresolvedUserId==$right.UserId
| extend UserDisplayName=iff(isempty(lu_UserDisplayName), UserDisplayName, lu_UserDisplayName)
| extend UserPrincipalName=iff(isempty(lu_UserPrincipalName), UserPrincipalName, lu_UserPrincipalName)
| summarize StartTime = min(StartTime), EndTime = max(EndTime), make_set(UserPrincipalName), make_set(UserDisplayName), make_set(set_ClientAppUsed), make_set(set_FullLocation), make_list(FailureCount) by IPAddress, AppDisplayName
| extend FailedPrincipalCount = arraylength(set_UserPrincipalName)
) on IPAddress
| project IPAddress, StartTime, EndTime, TargetedApplication=AppDisplayName, FailedPrincipalCount, UserPrincipalNames=set_UserPrincipalName, UserDisplayNames=set_UserDisplayName, ClientAppsUsed=set_set_ClientAppUsed, Locations=set_set_FullLocation, FailureCountByPrincipal=list_FailureCount, WindowThresholdBreaches
| join kind= inner (
SigninLogs // get data on success vs. failure history for each IP
| where TimeGenerated > ago(timeRange)
| where ResultType in(successCodes) or ResultType in(failureCodes) // success or failure types
| summarize GlobalSuccessPrincipalCount = dcountif(UserPrincipalName, (ResultType in(successCodes))), ResultTypeSuccesses = make_set_if(ResultType, (ResultType in(successCodes))), GlobalFailPrincipalCount = dcountif(UserPrincipalName, (ResultType in(failureCodes))), ResultTypeFailures = make_set_if(ResultType, (ResultType in(failureCodes))) by IPAddress
| where GlobalFailPrincipalCount > GlobalSuccessPrincipalCount // where the number of failed principals is greater than success - eliminates FPs from IPs who authenticate successfully alot and as a side effect have alot of failures
) on IPAddress
| project-away IPAddress1
| extend timestamp=StartTime, IPCustomEntity = IPAddress",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/SigninPasswordSpray.yaml,2020-10-04,SigninPasswordSpray.yaml
bfb1c90f-8006-4325-98be-c7fffbc254d6,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Detection,Azure Sentinel Community Github,Distributed Password cracking attempts in AzureAD,"'Identifies distributed password cracking attempts from the Azure Active Directory SigninLogs.
The query looks for unusually high number of failed password attempts coming from multiple locations for a user account.
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
50053   Account is locked because the user tried to sign in too many times with an incorrect user ID or password.
50055   Invalid password, entered expired password.
50056   Invalid or null password - Password does not exist in store for this user.
50126   Invalid username or password, or invalid on-premises username or password.'
",AzureActiveDirectory,SigninLogs,"
let timeRange = 1d;
let s_threshold = 30;
let l_threshold = 3;
SigninLogs
| where TimeGenerated >= ago(timeRange)
| where OperationName =~ ""Sign-in activity""
// Error codes that we want to look at as they are related to the use of incorrect password.
| where ResultType in (""50126"", ""50053"" , ""50055"", ""50056"")
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser 
| extend LocationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated),LocationCount=dcount(LocationString), Location = make_set(LocationString), 
IPAddress = make_set(IPAddress), IPAddressCount = dcount(IPAddress), AppDisplayName = make_set(AppDisplayName), ResultDescription = make_set(ResultDescription), 
Browser = make_set(Browser), OS = make_set(OS), SigninCount = count() by UserPrincipalName                               
// Setting a generic threshold - Can be different for different environment
| where SigninCount > s_threshold and LocationCount >= l_threshold
| extend tostring(Location), tostring(IPAddress), tostring(AppDisplayName), tostring(ResultDescription), tostring(Browser), tostring(OS)
| distinct *
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/DistribPassCrackAttempt.yaml,2020-10-04,DistribPassCrackAttempt.yaml
a9956d3a-07a9-44a6-a279-081a85020cae,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Detection,Azure Sentinel Community Github,ClientDeniedAccess,"'Creates an incident in the event a Client has an excessive amounts of denied access requests.'
",SymantecVIP,Syslog,"
let timeframe = ago(1h);
let threshold = 15;
let rejectedAccess = SymantecVIP
| where TimeGenerated > timeframe
| where isnotempty(RADIUSAuth)
| where RADIUSAuth =~ ""Reject""
| summarize Total = count() by ClientIP, bin(TimeGenerated, 15m)
| where Total > threshold
| project ClientIP;
SymantecVIP
| where TimeGenerated > timeframe
| where isnotempty(RADIUSAuth)
| where RADIUSAuth =~ ""Reject""
| join kind=inner rejectedAccess() on ClientIP
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by ClientIP, User
| extend timestamp = StartTime, IPCustomEntity = ClientIP, AccountCustomEntity = User
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SymantecVIP/ClientDeniedAccess.yaml,2020-10-04,ClientDeniedAccess.yaml
c775a46b-21b1-46d7-afa6-37e3e577a27b,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Detection,Azure Sentinel Community Github,Excessive Failed Authentication from Invalid Inputs,"'Creates an incident in the event that a user generates an excessive amount of failed authentications due to invalid inputs, indications of a potential brute force.'
",SymantecVIP,Syslog,"
let timeframe = ago(1h);
let threshold = 15;
SymantecVIP
| where TimeGenerated > timeframe
| where isnotempty(RADIUSAuth)
| where RADIUSAuth =~ ""Reject""
| summarize Total = count() by bin(TimeGenerated, 15m), User, ClientIP
| where Total > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = User
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SymantecVIP/ExcessiveFailedAuthenticationsfromInvalidInputs.yaml,2020-10-04,ExcessiveFailedAuthenticationsfromInvalidInputs.yaml
04384937-e927-4595-8f3c-89ff58ed231f,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Office 365,Detection,Azure Sentinel Community Github,Possible STRONTIUM attempted credential harvesting,"'Surfaces potential STRONTIUM group Office365 credential harvesting attempts within OfficeActivity Logon events.
References: https://www.microsoft.com/security/blog/2020/09/10/strontium-detecting-new-patters-credential-harvesting/.'
",Office365,OfficeActivity,"let detectionTime = 30d;
let IPs = dynamic ([""199.249.230."",""185.220.101."",""23.129.64."",""109.70.100."",""185.220.102.""]);
OfficeActivity
| where TimeGenerated > ago(detectionTime)
| where RecordType in (""AzureActiveDirectoryAccountLogon"", ""AzureActiveDirectoryStsLogon"") 
| where Operation != 'UserLoggedIn'
| extend UserAgent = iff(parse_json(ExtendedProperties)[0].Name =~ ""UserAgent"", extractjson(""$[0].Value"", ExtendedProperties, typeof(string)),"""")
| mv-expand parse_json(ExtendedProperties)
| where ExtendedProperties.Name =~ ""RequestType""
| extend RequestType = ExtendedProperties.Value
| where ClientIP has_any (IPs)
| summarize authAttempts=dcount(TimeGenerated), firstAttempt=min(TimeGenerated), lastAttempt=max(TimeGenerated), uniqueIPs=dcount(ClientIP), uniqueAccounts=dcount(UserId), attemptedAccounts=make_set(UserId) by UserAgent
| where authAttempts > 2500
| extend timestamp = firstAttempt
| sort by uniqueAccounts
",7d,30d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/StrontiumCredHarvesting.yaml,2020-10-04,StrontiumCredHarvesting.yaml
e27dd7e5-4367-4c40-a2b7-fcd7e7a8a508,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,SaaS,Detection,Azure Sentinel Community Github,Potential Password Spray Attack,"'This query searches for failed attempts to log into the Okta console from more than 15 various users within a 5 minute timeframe from the same source. This is a potential indication of a password spray attack'
",OktaSSO,Okta_CL,"
let timeframe = ago(1h);
let FailureThreshold = 15;
let FailedEvents = Okta_CL
| where TimeGenerated > timeframe
| where eventType_s =~ ""user.session.start""and outcome_reason_s in (""VERIFICATION_ERROR"",""INVALID_CREDENTIALS"")
| summarizedcount(actor_alternateId_s) by client_ipAddress_s, bin(TimeGenerated, 5m)
| where dcount_actor_alternateId_s > FailureThreshold
| project client_ipAddress_s, TimeGenerated;
Okta_CL
| where TimeGenerated > timeframe
| where eventType_s =~ ""user.session.start""and outcome_reason_s in (""VERIFICATION_ERROR"",""INVALID_CREDENTIALS"")
| summarize Users = make_set(actor_alternateId_s) by client_ipAddress_s, City = client_geographicalContext_city_s, Country = client_geographicalContext_country_s, bin(TimeGenerated, 5m)
| join kind=inner (FailedEvents) on client_ipAddress_s, TimeGenerated
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, IPCustomEntity = client_ipAddress_s
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OktaSSO/PasswordSpray.yaml,2020-10-04,PasswordSpray.yaml
884be6e7-e568-418e-9c12-89229865ffde,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,SaaS,Detection,Azure Sentinel Community Github,Failed Logins from Unknown or Invalid User,"'This query searches for numerous login attempts to the management console with an unknown or invalid user name'
",OktaSSO,Okta_CL,"
let timeframe = ago(1h);
let FailureThreshold = 15;
let FailedLogins = Okta_CL
| where TimeGenerated > timeframe
| where eventType_s =~ ""user.session.start"" and outcome_reason_s =~ ""VERIFICATION_ERROR""
| summarize count() by actor_alternateId_s, client_ipAddress_s, bin(TimeGenerated, 5m)
| where count_ > FailureThreshold
| project client_ipAddress_s, actor_alternateId_s;
Okta_CL
| where TimeGenerated > timeframe
| join kind=inner (FailedLogins) on client_ipAddress_s, actor_alternateId_s
| where eventType_s =~ ""user.session.start"" and outcome_reason_s =~ ""VERIFICATION_ERROR""
| summarize count() by actor_alternateId_s, ClientIP = client_ipAddress_s, City = client_geographicalContext_city_s, Country = client_geographicalContext_country_s, published_t
| sort by published_t desc
| extend timestamp = published_t, IPCustomEntity = ClientIP, AccountCustomEntity = actor_alternateId_s
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OktaSSO/FailedLoginsFromUnknownOrInvalidUser.yaml,2020-10-04,FailedLoginsFromUnknownOrInvalidUser.yaml
934011da-1fe6-4507-aadb-d3914c877bcd,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,SaaS,Hunting Query,Azure Sentinel Community Github,Potential IIS brute force,"'This query shows when 1200 (20 per minute) or more failed attempts by cIP per hour occur on a given server and then a successful logon by cIP. 
This only includes when more than 1 user agent strings is used or more than 1 port is used.
This could be indicative of successful probing and password brute force success on your IIS servers. 
Feel free to adjust the threshold as needed - ConnectionCount >= 1200 
References: Status code mappings for your convenience, also inline if the mapping is not available
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = ago(1h);
W3CIISLog
| where TimeGenerated >= timeFrame
| where scStatus in (""401"",""403"")
| where cIP !startswith ""192.168."" and cIP != sIP and cIP != ""::1"" //and csUserName != ""-"" 
// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI
| extend csUriQuery = iff(csUriQuery startswith ""MailboxId="", tostring(split(csUriQuery, ""&"")[0]) , csUriQuery )
| extend csUriQuery = iff(csUriQuery startswith ""X-ARR-CACHE-HIT="", strcat(tostring(split(csUriQuery, ""&"")[0]),tostring(split(csUriQuery, ""&"")[1])) , csUriQuery )
| summarize FailStartTimeUtc = min(TimeGenerated), FailEndTimeUtc = max(TimeGenerated), makeset(sPort), makeset(csUserAgent), makeset(csUserName), csUserNameCount = dcount(csUserName), ConnectionCount = count() by Computer, sSiteName, sIP, cIP, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)
| extend sPortCount = arraylength(set_sPort)
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."", 
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
| where (ConnectionCount >= 1200 and csUserAgentPerIPCount > 1) or (ConnectionCount >= 1200 and sPortCount > 1)
// now join back to see if there is a successful logon after so many failures
| join (
W3CIISLog
| where TimeGenerated >= timeFrame
| where scStatus startswith ""20""
| where cIP !startswith ""192.168."" and cIP != sIP and cIP != ""::1""
| extend LogonSuccessTimeUtc = TimeGenerated, Success_scStatus = scStatus
| distinct LogonSuccessTimeUtc, Computer, sSiteName, sIP, cIP, Success_scStatus
) on Computer, sSiteName, sIP, cIP
| where FailEndTimeUtc < LogonSuccessTimeUtc and not(LogonSuccessTimeUtc between (FailStartTimeUtc .. FailEndTimeUtc))
| summarize makeset(LogonSuccessTimeUtc) by FailStartTimeUtc, FailEndTimeUtc, Computer, sSiteName, sIP, cIP, tostring(set_csUserName), csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, tostring(set_sPort), tostring(set_csUserAgent), ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly
| project FailStartTimeUtc, FailEndTimeUtc, set_LogonSuccessTimeUtc, Computer, sSiteName, sIP, cIP, set_csUserName, csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, set_sPort, set_csUserAgent, ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly
| extend timestamp = FailStartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/Potential_IIS_BF.yaml,2020-10-04,Potential_IIS_BF.yaml
472e83d6-ccec-47b8-b1cd-75500f936981,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Office 365,Hunting Query,Azure Sentinel Community Github,Permutations on logon attempts by UserPrincipalNames indicating potential brute force,"'Attackers sometimes try variations on account logon names, this will identify failed attempts on logging in using permutations 
based on known first and last name within 10m time windows, for UserPrincipalNames that separated by hyphen(-), underscore(_) and dot(.).
If there is iteration through these separators or order changes in the logon name it may indicate potential Brute Force logon attempts.
For example, attempts with first.last@example.com, last.first@example.com, first_last@example.com and so on.'
",Office365,OfficeActivity,"
let lookback = 1d;
let fl_Min = 3;
let un_MatchMin = 2;
let upnFunc = (startTimeSpan:timespan, tableName:string){
table(tableName) | where TimeGenerated >= ago(lookback)
| extend Operation = columnifexists(""Operation"", ""Sign-in activity"")
| where Operation == ""UserLoginFailed"" or Operation == ""Sign-in activity""
| extend Result = columnifexists(""ResultType"", ""tempValue"")
| extend Result = iff(Result == ""tempValue"", columnifexists(""ResultStatus"", Result), Result)
| extend ResultValue = case(Result == ""0"", ""Success"", Result == ""Success"" or Result == ""Succeeded"", ""Success"", Result)
| where ResultValue != ""Success""
| extend UserPrincipalName = columnifexists(""UserPrincipalName"", ""tempValue"") 
| extend UserPrincipalName = iff(tableName == ""OfficeActivity"", tolower(UserId), tolower(UserPrincipalName))
| extend UPN = split(UserPrincipalName, ""@"")
| extend UserNameOnly = tostring(UPN[0]), DomainOnly = tostring(UPN[1])
| where UserNameOnly contains ""."" or UserPrincipalName contains ""-"" or UserPrincipalName contains ""_""
// Verify we only get accounts without other separators, it would be difficult to identify multi-level separators
// Count of any that are not alphanumeric
| extend charcount = countof(UserNameOnly, '[^0-9A-Za-z]', ""regex"")
// Drop any that have non-alphanumeric characters still included
| where charcount < 2
// Creating array of name pairs that include the separators we are interested in, this can be added to if needed.
| extend unoArray = case(
UserNameOnly contains ""."", split(UserNameOnly, "".""),
UserNameOnly contains ""-"", split(UserNameOnly, ""-""),
UserNameOnly contains ""_"", split(UserNameOnly, ""_""),
UserNameOnly)
| extend First = iff(isnotempty(tostring(parsejson(unoArray)[0])), tostring(parsejson(unoArray)[0]),tostring(unoArray))
| extend Last = tostring(parsejson(unoArray)[1])
| extend First4char = iff(countof(substring(First, 0,4), '[0-9A-Za-z]', ""regex"") >= 4, substring(First, 0,4), ""LessThan4""),
First6char = iff(countof(substring(First, 0,6), '[0-9A-Za-z]', ""regex"") >= 6, substring(First, 0,6), ""LessThan6""),
First8char = iff(countof(substring(First, 0,8), '[0-9A-Za-z]', ""regex"") >= 8, substring(First, 0,8), ""LessThan8""),
Last4char = iff(countof(substring(Last, 0,4), '[0-9A-Za-z]', ""regex"") >= 4, substring(Last, 0,4), ""LessThan4""),
Last6char = iff(countof(substring(Last, 0,6), '[0-9A-Za-z]', ""regex"") >= 6, substring(Last, 0,6), ""LessThan6""),
Last8char = iff(countof(substring(Last, 0,8), '[0-9A-Za-z]', ""regex"") >= 8, substring(Last, 0,8), ""LessThan8"")
| where First != Last
| summarize UserNames = makeset(UserNameOnly),
fl_Count = count() by bin(TimeGenerated, 10m), First4char, First6char, First8char, Last4char, Last6char, Last8char, Type
};
let SigninList = upnFunc(lookback,""SigninLogs"");
let OffActList = upnFunc(lookback,""OfficeActivity"");
let UserNameList = (union isfuzzy=true SigninList, OffActList);
let Char4List = UserNameList
| project TimeGenerated, First4char, Last4char, UserNames, fl_Count, Type
| where First4char != ""LessThan4"" and Last4char != ""LessThan4"";
// Break out first and last so we can then join and see where a first and last match.
let First4charList = Char4List | where isnotempty(First4char)
| summarize un_MatchOnFirst = makeset(UserNames),
fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First4char, Type
| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;
let Last4charList = Char4List | where isnotempty(Last4char) 
| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last4char, Type
| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;
let char4 = First4charList | join Last4charList on CharSet and TimeGenerated
| project-away TimeGenerated1, CharSet1
// Make sure that we get more than a single match for First or Last
| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin
| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;
let Char6List = UserNameList
| project TimeGenerated, First6char, Last6char, UserNames, fl_Count, Type
| where First6char != ""LessThan6"" and Last6char != ""LessThan6"";
// Break out first and last so we can then join and see where a first and last match.
let First6charList = Char6List | where isnotempty(First6char)
| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First6char, Type
| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;
let Last6charList = Char6List | where isnotempty(Last6char)
| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last6char, Type
| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;
let char6 = First6charList | join Last6charList on CharSet and TimeGenerated
| project-away TimeGenerated1, CharSet1
// Make sure that we get more than a single match for First or Last
| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin
| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;
let Char8List = UserNameList
| project TimeGenerated, First8char, Last8char, UserNames, fl_Count, Type
| where First8char != ""LessThan8"" and Last8char != ""LessThan8"";
// Break out first and last so we can then join and see where a first and last match.
let First8charList = Char8List | where isnotempty(First8char)
| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First8char, Type
| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type; 
let Last8charList = Char8List | where isnotempty(Last8char)
| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last8char, Type
| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;
let char8 = First8charList | join Last8charList on CharSet and TimeGenerated
| project-away TimeGenerated1, CharSet1
// Make sure that we get more than a single match for First or Last
| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin
| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;
(union isfuzzy=true char4, char6, char8)
| project Type, TimeGenerated, CharSet, UserNameMatchOnFirst = un_MatchOnFirst, UserNameMatchOnFirstCount = un_MatchOnFirstCount,
FailedLogonCountForFirst = fl_CountForFirst, UserNameMatchOnLast = un_MatchOnLast, UserNameMatchOnLastCount = un_MatchOnLastCount,
FailedLogonCountForLast = fl_CountForLast
| sort by UserNameMatchOnFirstCount desc, UserNameMatchOnLastCount desc
| extend timestamp = TimeGenerated
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PermutationsOnLogonNames.yaml,2020-10-04,PermutationsOnLogonNames.yaml
22f33a4c-e60f-4817-bbfe-9e2ed33cb596,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,SaaS,Hunting Query,Azure Sentinel Community Github,Failed service logon attempt by user account with available AuditData,"'User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.
Additionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.
This can help to understand any events for this same user related to User or Group Management.
Results may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.
The associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.
Receiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.'
",AzureActiveDirectory,AuditLogs,"
let current = 1d;
let failLimit = 10;
let ipLimit = 3;
let auditLookback = 7d;
let FailedSignins = SigninLogs 
| where TimeGenerated >= ago(current)
| where ResultType != ""0"" and AppDisplayName != ""Windows Sign In""
| extend UserPrincipalName = tolower(UserPrincipalName)
| extend CityState = strcat(tostring(LocationDetails.city),""|"", tostring(LocationDetails.state))
| extend Result = strcat(ResultType,""-"",ResultDescription) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress), 
CityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName), 
FailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount, 
Results, FailedLogonCount, Location, CityStates 
| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit
| extend Activity = pack(""IPAddresses"", IPAddresses, ""AppDisplayNames"", AppDisplayNames, ""Results"", Results, ""Location"", Location, ""CityStates"", CityStates)
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity
| extend AccountCustomEntity = UserPrincipalName;
let AccountMods = AuditLogs | where TimeGenerated >= ago(current+auditLookback)
| where Category == ""UserManagement"" or Category == ""GroupManagement""
| extend ModProps = TargetResources.[0].modifiedProperties
| extend InitiatedBy = case(
isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),
isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),
"""")
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)
| extend ModifiedProps = pack(""PropertyName"",PropertyName,""oldValue"",oldValue,""newValue"",newValue) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id
| extend AccountCustomEntity = UserPrincipalName;
// Gather only Audit data for UserPrincipalNames that we have Audit data for
let AccountNameOnly = FailedSignins | project UserPrincipalName;
let AuditMods = AccountNameOnly
| join kind= innerunique (
AccountMods
) on UserPrincipalName;
let AvailableAudits = AuditMods | project UserPrincipalName;
let SigninsWithAudit = AvailableAudits
| join kind= innerunique (
FailedSignins
) on UserPrincipalName;
// Union the Current Signin failures so we do not lose them with the Auditing data we do have
let Activity = (union isfuzzy=true
SigninsWithAudit, AuditMods)
| order by StartTimeUtc, UserPrincipalName;
Activity
| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id
| order by UserPrincipalName, StartTimeUtc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FailedSigninsWithAuditDetails.yaml,2020-10-04,FailedSigninsWithAuditDetails.yaml
959fe0f0-7ac0-467c-944f-5b8c6fdc9e72,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Linux,Hunting Query,Azure Sentinel Community Github,Disabled accounts using Squid proxy,"'Look for accounts that have a been recorded as disabled by AD in the previous week but are still using the proxy during 
the current week. This query presumes the default squid log format is being used. http://www.squid-cache.org/Doc/config/access_log/'
",Syslog,Syslog,"
let starttime = 14d;
let endtime = 7d;
let disabledAccounts = (){
SigninLogs 
| where TimeGenerated between(ago(starttime) .. ago(endtime))
| where ResultType == 50057
| where ResultDescription =~ ""User account is disabled. The account has been disabled by an administrator."" 
};
let proxyEvents = (){
Syslog
| where TimeGenerated > ago(endtime)
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
         Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
         contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
};
proxyEvents 
| where Status !contains 'DENIED'
| join kind=inner disabledAccounts on $left.User == $right.UserPrincipalName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, URLCustomEntity = URL
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/disabled_account_squid_usage.yaml,2020-10-04,disabled_account_squid_usage.yaml
d0f13bb9-e713-4f89-b610-1806326a1dea,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1110,Brute Force,Windows,Hunting Query,Azure Sentinel Community Github,Summary of user logons by logon type,"'Comparing succesful and nonsuccessful logon attempts can be used to identify attempts to move laterally within the 
environment with the intention of discovering credentials and sensitive data.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID in (4624, 4625)
| where AccountType == 'User' 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Amount = count() by LogonTypeName
| extend timestamp = StartTimeUtc",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/User%20Logons%20By%20Logon%20Type.yaml,2020-10-04,User%20Logons%20By%20Logon%20Type.yaml
e8d36582-c403-4466-bd44-ebede5b6fa6e,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Windows,Hunting Query,Azure Sentinel Community Github,VIP account more than 6 failed logons in 10,"'VIP Account with more than 6 failed logon attempts in 10 minutes, include your own VIP list in the table below'
",SecurityEvents,SecurityEvent,"
// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain
let List = datatable(VIPUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN""];
let timeframe = 10m;
List | extend Account = strcat(Domain,""\\"",VIPUser) | join kind= inner (
SecurityEvent 
| where TimeGenerated > ago(timeframe) 
| where EventID == ""4625""
| where AccountType == ""User""
| where LogonType == ""2"" or LogonType == ""3""
) on Account 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by LogonType, Account
| where FailedVIPLogons >= 6
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/VIPAccountFailedLogons.yaml,2020-10-04,VIPAccountFailedLogons.yaml
62e2df59-1535-4c8e-ac6c-c91faeed0179,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1110,Brute Force,Windows,Hunting Query,Azure Sentinel Community Github,Hosts with new logons,"'Shows new accounts that have logged onto a host for the first time - this may clearly be benign activity but an account 
logging onto multiple hosts for the first time can also be used to look for evidence of that account being used to move 
laterally across a network.'
",SecurityEvents,SecurityEvent,"
let starttime = 7d;
let endtime = 1d;
let LogonEvents=() { 
let logonSuccess=SecurityEvent 
| where EventID==4624 
| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='Logon';
let logonFail=SecurityEvent 
| where EventID==4625 
| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='LogonFailure';
logonFail 
| union logonSuccess
};
LogonEvents 
| where TimeGenerated > ago(endtime) 
| where ActionType == 'Logon' 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ComputerName, AccountName 
| join kind=leftanti ( 
LogonEvents 
| where TimeGenerated between(ago(starttime)..ago(endtime)) 
| where ActionType == 'Logon' 
| summarize count() by ComputerName, AccountName 
) on ComputerName, AccountName 
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), HostCount=dcount(ComputerName), HostSet=makeset(ComputerName, 10)  by AccountName, ComputerName
| extend timestamp = StartTimeUtc, AccountCustomEntity = AccountName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/HostsWithNewLogons.yaml,2020-10-04,HostsWithNewLogons.yaml
5e76eaf9-79a7-448c-bace-28e5b53b8396,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1110,Brute Force,Windows,Hunting Query,Azure Sentinel Community Github,Summary of users created using uncommon/undocumented commandline switches,"'Summarizes uses of uncommon & undocumented commandline switches to create persistence
User accounts may be created to achieve persistence on a machine.
Read more here: https://attack.mitre.org/wiki/Technique/T1136
Query for users being created using ""net user"" command
""net user"" commands are noisy, so needs to be joined with another signal -
e.g. in this example we look for some undocumented variations (e.g. /ad instead of /add)'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID==4688
| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, 
    AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, '\\')[-1]), 
    ProcessCommandLine = CommandLine, 
    FolderPath = """", InitiatingProcessFileName=ParentProcessName,
    InitiatingProcessCommandLine="""",InitiatingProcessParentFileName=""""
| where FileName in~ (""net.exe"", ""net1.exe"")
| parse kind=regex flags=iU ProcessCommandLine with * ""user "" CreatedUser "" "" * ""/ad""
| where not(FileName =~ ""net1.exe"" and InitiatingProcessFileName =~ ""net.exe"" and replace(""net"", ""net1"", InitiatingProcessCommandLine) =~ ProcessCommandLine)
| extend CreatedOnLocalMachine=(ProcessCommandLine !contains ""/do"")
| where ProcessCommandLine contains ""/add"" or (CreatedOnLocalMachine == 0 and ProcessCommandLine !contains ""/domain"")
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), MachineCount=dcount(ComputerName) by CreatedUser, CreatedOnLocalMachine, InitiatingProcessFileName, FileName, ProcessCommandLine, InitiatingProcessCommandLine
| extend timestamp = StartTimeUtc, AccountCustomEntity = CreatedUser
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/persistence_create_account.yaml,2020-10-04,persistence_create_account.yaml
745a22ec-fed8-49b9-9f62-4570b7709da4,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,Azure AD,Hunting Query,Azure Sentinel Community Github,Azure Active Directory sign-in burst from multiple locations,"'This query over Azure Active Directory sign-in activity highlights accounts associated
with multiple authentications from different geographical locations in a short space of time.'
",AzureActiveDirectory,SigninLogs,"
let timeRange = ago(10d);
let signIns = SigninLogs
| where TimeGenerated >= timeRange
| extend locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"",
 tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
| where locationString != ""//"" 
// filter out signins associated with top 100 signin locations 
| join kind=anti (
SigninLogs
  | extend locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
  tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
  | where locationString != ""//""
  | summarize count() by locationString
  | order by count_ desc
  | take 100) on locationString ; // TODO - make this threshold percentage-based
// We will perform a time window join to identify signins from multiple locations within a 10-minute period
let lookupWindow = 10m;
let lookupBin = lookupWindow / 2.0; // lookup bin = equal to 1/2 of the lookup window
signIns 
| project-rename Start=TimeGenerated 
| extend TimeKey = bin(Start, lookupBin)
| join kind = inner (
signIns 
| project-rename End=TimeGenerated, EndLocationString=locationString 
  // TimeKey on the right side of the join - emulates this authentication appearing several times
  | extend TimeKey = range(bin(End - lookupWindow, lookupBin),
  bin(End, lookupBin), lookupBin)
  | mvexpand TimeKey to typeof(datetime) // translate TimeKey arrange range to a column
) on Identity, TimeKey
| where End > Start
| project timeSpan = End - Start, Identity, locationString, EndLocationString,tostring(Start), tostring(End), UserPrincipalName
| where locationString != EndLocationString
| summarize by timeSpan, Identity, locationString, EndLocationString, Start, End, UserPrincipalName
| extend timestamp = Start, AccountCustomEntity = UserPrincipalName 
| order by Identity
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/signinBurstFromMultipleLocations.yaml,2020-10-04,signinBurstFromMultipleLocations.yaml
aef212b5-c770-42e1-9abf-bc513e4e749c,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,,Hunting Query,Azure Sentinel Community Github,Multiple Failed Logon on SQL Server in Short time Span,"This hunting queries looks for multiple failed logon attempts in short span of time.
This query is based on the SQLEvent KQL Parser function (link below)
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// the timeframe and threshold can be changed below as per requirement
//
let TimeFrame = 1d;
let failedThreshold = 3;
SQLEvent
| where TimeGenerated >= ago(TimeFrame) 
| where LogonResult has ""failed""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TotalFailedLogons = count() by CurrentUser, ClientIP
| where TotalFailedLogons >= failedThreshold
| project StartTime, CurrentUser, TotalFailedLogons, ClientIP
| extend timestamp = StartTime, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-MultipleFailedLogon_InShortSpan.yaml,2020-10-04,SQL-MultipleFailedLogon_InShortSpan.yaml
d98256d5-0c9a-4ffc-8618-66a3404412f8,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,,Hunting Query,Azure Sentinel Community Github,Failed Logon Attempts on SQL Server,"This query is based on the SQLEvent KQL Parser function (link below) and detects failed logons on SQL Server 
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
SQLEvent
| where TimeGenerated >= ago(1d)
| where LogonResult has ""failed""
| summarize count() by TimeGenerated, CurrentUser, Reason, ClientIP
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-Failed%20SQL%20Logons.yaml,2020-10-04,SQL-Failed%20SQL%20Logons.yaml
72727649-6445-46a3-b249-997a009fad89,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1110,Brute Force,,Hunting Query,Azure Sentinel Community Github,Failed Logon on SQL Server from Same IPAddress in Short time Span,"This hunitng query identifies multiple failed logon attempts from same IP within short span of time.
This query is based on the SQLEvent KQL Parser function (link below)
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// the timeframe and threshold can be changed below as per requirement.
//
let TimeFrame = 1d;
let failedThreshold = 3;
SQLEvent
| where TimeGenerated >= ago(TimeFrame) 
| where LogonResult has ""failed""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TotalFailedLogons = count() by ClientIP, CurrentUser, Computer
| where TotalFailedLogons >= failedThreshold
| project StartTime, ClientIP, TotalFailedLogons, CurrentUser, Computer
| extend timestamp = StartTime, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-MultipleFailedLogon_FromSameIP.yaml,2020-10-04,SQL-MultipleFailedLogon_FromSameIP.yaml
2790795b-7dba-483e-853f-44aa0bc9c985,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1110,Brute Force,,Detection,Azure Sentinel Community Github,Wazuh - Large Number of Web errors from an IP,"'Identifies instances where Wazuh logged over 400 '403' Web Errors from one IP Address. To onboard Wazuh data into Sentinel please view: https://github.com/wazuh/wazuh-documentation/blob/master/source/azure/monitoring%20activity.rst'
",CustomConnector,CustomLogs_CL,"
let incidentTime = ago(1d);
CommonSecurityLog
| where TimeGenerated > incidentTime
| where DeviceProduct =~ ""Wazuh""
| where Activity has ""Web server 400 error code.""
| where Message has ""403""
| extend HostName=substring(split(DeviceCustomString1,"")"")[0],1)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumberOfErrors = count(SourceIP) by HostName, SourceIP
| where NumberOfErrors > 400
| sort by NumberOfErrors desc
| extend timestamp = StartTime, HostCustomEntity = HostName, IPCustomEntity = SourceIP
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/Wazuh-Large%20Number%20of%20Web%20errors%20from%20an%20IP.yaml,2020-10-04,Wazuh-Large%20Number%20of%20Web%20errors%20from%20an%20IP.yaml
fbfbf530-506b-49a4-81ad-4030885a195c,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1100,Web Shell,SaaS,Detection,Azure Sentinel Community Github,Malicious web application requests linked with MDATP alerts,"'Takes MDATP alerts where web scripts are present in the evidence and correlates with requests made to those scripts
in the WCSIISLog to surface new alerts for potentially malicious web request activity.
The lookback for alerts is set to 1h and the lookback for W3CIISLogs is set to 7d. A sample set of popular web script extensions
has been provided in scriptExtensions that should be tailored to your environment.'
",AzureMonitor(IIS),W3CIISLog,"
let alertTimeWindow = 1h;
let logTimeWindow = 7d;
// Define script extensions that suit your web application environment - a sample are provided below
let scriptExtensions = dynamic(["".php"", "".jsp"", "".js"", "".aspx"", "".asmx"", "".asax"", "".cfm"", "".shtml""]); 
let alertData = materialize(SecurityAlert 
| where TimeGenerated > ago(alertTimeWindow) 
| where ProviderName == ""MDATP"" 
// Parse and expand the alert JSON 
| extend alertData = parse_json(Entities) 
| mvexpand alertData);
let fileData = alertData
// Extract web script files from MDATP alerts - our malicious web scripts - candidate webshells
| where alertData.Type =~ ""file"" 
| where alertData.Name has_any(scriptExtensions) 
| extend FileName = tostring(alertData.Name), Directory = tostring(alertData.Directory);
let hostData = alertData
// Extract server details from alerts and map to alert id
| where alertData.Type =~ ""host""
| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId
| distinct HostName, DnsDomain, SystemAlertId;
// Join the files on their impacted servers
let webshellData = fileData
| join kind=inner (hostData) on SystemAlertId 
| project TimeGenerated, FileName, Directory, HostName, DnsDomain;
webshellData
| join (  
// Find requests that were made to this file on the impacted server in the W3CIISLog table 
W3CIISLog  
| where TimeGenerated > ago(logTimeWindow) 
// Restrict to accesses to script extensions 
| where csUriStem has_any(scriptExtensions)
| extend splitUriStem = split(csUriStem, ""/"")  
| extend FileName = splitUriStem[-1], HostName = sComputerName
// Summarize potential attacker activity
| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), RequestUserAgents=make_set(csUserAgent), ReqestMethods=make_set(csMethod), RequestStatusCodes=make_set(scStatus), RequestCookies=make_set(csCookie), RequestReferers=make_set(csReferer), RequestQueryStrings=make_set(csUriQuery) by AttackerIP=cIP, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName), HostName  
) on FileName, HostName
| project StartTime, EndTime, AttackerIP, RequestUserAgents, HostName, SiteName, ShellLocation, ReqestMethods, RequestStatusCodes, RequestCookies, RequestReferers, RequestQueryStrings, RequestCount = count_
// Expose the attacker ip address as a custom entity
| extend timestamp=StartTime, IPCustomEntity = AttackerIP, HostCustomEntity = HostName",1h,7d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/MaliciousAlertLinkedWebRequests.yaml,2020-10-04,MaliciousAlertLinkedWebRequests.yaml
cc087e7c-4db0-4bf9-9e48-287a9c9c3fbc,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1100,Web Shell,SaaS,Hunting Query,Azure Sentinel Community Github,Web shell Detection,"'Web shells are script that when uploaded to a web server can be used for remote administration. 
Attackers often use web shells to obtain unauthorized access, escalate //privilege as well as further compromise the environment. 
The query detects web shells that use GET requests by keyword searches in URL strings. 
This is based out of sigma rules described //here (https://github.com/Neo23x0/sigma/blob/master/rules/web/web_webshell_keyword.yml). 
There could be some web sites like wikis with articles on os commands and pages that include the os //commands in the URLs that might cause FP.'
",AzureMonitor(IIS),W3CIISLog,"
let timeFrame = ago(1d);
let command = ""(?i)net(1)?(.exe)?(%20){1,}user|cmd(.exe)?(%20){1,}/c(%20){1,}"";
W3CIISLog
| where TimeGenerated >= timeFrame
| where csMethod == ""GET"" 
| where ( csUriQuery has ""whoami"" or csUriQuery matches regex command ) or 
        ( csUriStem has ""whoami"" or csUriStem matches regex command ) or
        ( csReferer has ""whoami"" or csReferer matches regex command )
| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), ConnectionCount = count() 
by Computer, sSiteName, sIP, cIP, csUserName, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/PotentialWebshell.yaml,2020-10-04,PotentialWebshell.yaml
84ad2f8a-b64c-49bc-b669-bdb4fd3071e9,2020-10-04 07:11:15.6720053,,InitialAccess,,,Windows,Detection,Azure Sentinel Community Github,Web sites blocked by Eset,"'Create alert on web sites blocked by Eset.'
",EsetSMC,eset_CL,"eset_CL
| where event_type_s == 'FilteredWebsites_Event'
| extend AccountCustomEntity = username_s, URLCustomEntity = object_uri_s, HostCustomEntity = hostname_s, IPCustomEntity = ipv4_s",5m,5m,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/EsetSMC/eset-sites-blocked.yaml,2020-10-04,eset-sites-blocked.yaml
2d8a60aa-c15e-442e-9ce3-ee924889d2a6,2020-10-04 07:11:15.6720053,,PrivilegeEscalation,,,Windows,Detection,Azure Sentinel Community Github,Threats detected by Eset,"'Escalates threats detected by Eset.'
",EsetSMC,eset_CL,"eset_CL
| where event_type_s == ""Threat_Event""
| extend HostCustomEntity = hostname_s, AccountCustomEntity = username_s, IPCustomEntity = ipv4_s",5m,5m,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/EsetSMC/eset-threats.yaml,2020-10-04,eset-threats.yaml
26a3b261-b997-4374-94ea-6c37f67f4f39,2020-10-04 07:11:15.6720053,,CredentialAccess,,,Windows,Detection,Azure Sentinel Community Github,Known GALLIUM domains and hashes,"'GALLIUM command and control domains and hash values for tools and malware used by GALLIUM. 
 Matches domain name IOCs related to the GALLIUM activity group with CommonSecurityLog, DnsEvents, VMConnection and SecurityEvents dataTypes.
 References: https://www.microsoft.com/security/blog/2019/12/12/gallium-targeting-global-telecom/ '
",SecurityEvents,SecurityEvent,"let timeframe = 1d;
let DomainNames = dynamic([""asyspy256.ddns.net"",""hotkillmail9sddcc.ddns.net"",""rosaf112.ddns.net"",""cvdfhjh1231.myftp.biz"",""sz2016rose.ddns.net"",""dffwescwer4325.myftp.biz"",""cvdfhjh1231.ddns.net""]);
let SHA1Hash = dynamic ([""53a44c2396d15c3a03723fa5e5db54cafd527635"", ""9c5e496921e3bc882dc40694f1dcc3746a75db19"", ""aeb573accfd95758550cf30bf04f389a92922844"", ""79ef78a797403a4ed1a616c68e07fff868a8650a"", ""4f6f38b4cec35e895d91c052b1f5a83d665c2196"", ""1e8c2cac2e4ce7cbd33c3858eb2e24531cb8a84d"", ""e841a63e47361a572db9a7334af459ddca11347a"", ""c28f606df28a9bc8df75a4d5e5837fc5522dd34d"", ""2e94b305d6812a9f96e6781c888e48c7fb157b6b"", ""dd44133716b8a241957b912fa6a02efde3ce3025"", ""8793bf166cb89eb55f0593404e4e933ab605e803"", ""a39b57032dbb2335499a51e13470a7cd5d86b138"", ""41cc2b15c662bc001c0eb92f6cc222934f0beeea"", ""d209430d6af54792371174e70e27dd11d3def7a7"", ""1c6452026c56efd2c94cea7e0f671eb55515edb0"", ""c6b41d3afdcdcaf9f442bbe772f5da871801fd5a"", ""4923d460e22fbbf165bbbaba168e5a46b8157d9f"", ""f201504bd96e81d0d350c3a8332593ee1c9e09de"", ""ddd2db1127632a2a52943a2fe516a2e7d05d70d2""]);
let SHA256Hash = dynamic ([""9ae7c4a4e1cfe9b505c3a47e66551eb1357affee65bfefb0109d02f4e97c06dd"", ""7772d624e1aed327abcd24ce2068063da0e31bb1d5d3bf2841fc977e198c6c5b"", ""657fc7e6447e0065d488a7db2caab13071e44741875044f9024ca843fe4e86b5"", ""2ef157a97e28574356e1d871abf75deca7d7a1ea662f38b577a06dd039dbae29"", ""52fd7b90d7144ac448af4008be639d4d45c252e51823f4311011af3207a5fc77"", ""a370e47cb97b35f1ae6590d14ada7561d22b4a73be0cb6df7e851d85054b1ac3"", ""5bf80b871278a29f356bd42af1e35428aead20cd90b0c7642247afcaaa95b022"", ""6f690ccfd54c2b02f0c3cb89c938162c10cbeee693286e809579c540b07ed883"", ""3c884f776fbd16597c072afd81029e8764dd57ee79d798829ca111f5e170bd8e"", ""1922a419f57afb351b58330ed456143cc8de8b3ebcbd236d26a219b03b3464d7"", ""fe0e4ef832b62d49b43433e10c47dc51072959af93963c790892efc20ec422f1"", ""7ce9e1c5562c8a5c93878629a47fe6071a35d604ed57a8f918f3eadf82c11a9c"", ""178d5ee8c04401d332af331087a80fb4e5e2937edfba7266f9be34a5029b6945"", ""51f70956fa8c487784fd21ab795f6ba2199b5c2d346acdeef1de0318a4c729d9"", ""889bca95f1a69e94aaade1e959ed0d3620531dc0fc563be9a8decf41899b4d79"", ""332ddaa00e2eb862742cb8d7e24ce52a5d38ffb22f6c8bd51162bd35e84d7ddf"", ""44bcf82fa536318622798504e8369e9dcdb32686b95fcb44579f0b4efa79df08"", ""63552772fdd8c947712a2cff00dfe25c7a34133716784b6d486227384f8cf3ef"", ""056744a3c371b5938d63c396fe094afce8fb153796a65afa5103e1bffd7ca070""]);
let SigNames = dynamic([""TrojanDropper:Win32/BlackMould.A!dha"", ""Trojan:Win32/BlackMould.B!dha"", ""Trojan:Win32/QuarkBandit.A!dha"", ""Trojan:Win32/Sidelod.A!dha""]);
(union isfuzzy=true
(CommonSecurityLog 
| where TimeGenerated >= ago(timeframe) 
| parse Message with * '(' DNSName ')' * 
| where isnotempty(FileHash)
| where FileHash in (SHA256Hash) or DNSName in~ (DomainNames)
| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP
),
(DnsEvents 
| where TimeGenerated >= ago(timeframe) 
| extend DNSName = Name
| where isnotempty(DNSName)
| where DNSName  in~ (DomainNames)
| extend IPAddress = ClientIP
),
(VMConnection 
| where TimeGenerated >= ago(timeframe) 
| parse RemoteDnsCanonicalNames with * '[""' DNSName '""]' *
| where isnotempty(DNSName)
| where DNSName  in~ (DomainNames)
| extend IPAddress = RemoteIp
),
(Event
//This query uses sysmon data depending on table name used this may need updataing
| where TimeGenerated >= ago(3d)
| where Source == ""Microsoft-Windows-Sysmon""
| extend EvData = parse_xml(EventData)
| extend EventDetail = EvData.DataItem.EventData.Data
| extend Hashes = EventDetail.[16].[""#text""]
| parse Hashes with * 'SHA1=' SHA1 ',' * 
| where isnotempty(Hashes)
| where Hashes in (SHA1Hash) 
| extend Account = UserName
),
(SecurityAlert
| where TimeGenerated >= ago(timeframe)
| where Entities has_any (SigNames)
| extend Computer = tostring(parse_json(Entities)[0].HostName) 
)
)
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress",1d,1d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/GalliumIOCs.yaml,2020-10-04,GalliumIOCs.yaml
7ee72a9e-2e54-459c-bc8a-8c08a6532a63,2020-10-04 07:11:15.6720053,,CommandAndControl,,,AWS,Detection,Azure Sentinel Community Github,Known IRIDIUM IP,"'IRIDIUM command and control IP. Identifies a match across various data feeds for IP IOCs related to the IRIDIUM activity group.'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
let IPList = dynamic([""154.223.45.38"",""185.141.207.140"",""185.234.73.19"",""216.245.210.106"",""51.91.48.210"",""46.255.230.229""]);
(union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated >= ago(timeframe) 
| where isnotempty(SourceIP) or isnotempty(DestinationIP)
| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList)
| extend IPMatch = case(SourceIP in (IPList), ""SourceIP"", DestinationIP in (IPList), ""DestinationIP"", ""Message"") 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch
| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == ""SourceIP"", SourceIP, IPMatch == ""DestinationIP"", DestinationIP, ""IP in Message Field"") 
),
(OfficeActivity
| where TimeGenerated >= ago(timeframe) 
|extend SourceIPAddress = ClientIP, Account = UserId
| where  SourceIPAddress in (IPList)
| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account
),
(DnsEvents 
| where TimeGenerated >= ago(timeframe) 
| extend DestinationIPAddress = IPAddresses,  Host = Computer
| where  DestinationIPAddress has_any (IPList) 
| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host
),
(VMConnection 
| where TimeGenerated >= ago(timeframe) 
| where isnotempty(SourceIp) or isnotempty(DestinationIp) 
| where SourceIp in (IPList) or DestinationIp in (IPList) 
| extend IPMatch = case( SourceIp in (IPList), ""SourceIP"", DestinationIp in (IPList), ""DestinationIP"", ""None"") 
| extend timestamp = TimeGenerated , IPCustomEntity = case(IPMatch == ""SourceIP"", SourceIp, IPMatch == ""DestinationIP"", DestinationIp, ""None""), Host = Computer
),
(Event
| where TimeGenerated >= ago(timeframe)
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 3
| extend EvData = parse_xml(EventData)
| extend EventDetail = EvData.DataItem.EventData.Data
| extend SourceIP = EventDetail.[9].[""#text""], DestinationIP = EventDetail.[14].[""#text""]
| where SourceIP in (IPList) or DestinationIP in (IPList) 
| extend IPMatch = case( SourceIP in (IPList), ""SourceIP"", DestinationIP in (IPList), ""DestinationIP"", ""None"") 
| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == ""SourceIP"", SourceIP, IPMatch == ""DestinationIP"", DestinationIP, ""None"")
), 
(WireData 
| where TimeGenerated >= ago(timeframe)
| where isnotempty(RemoteIP)
| where RemoteIP in (IPList)
| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = Computer
),
(SigninLogs
| where TimeGenerated >= ago(timeframe)
| where isnotempty(IPAddress)
| where IPAddress in (IPList)
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
),
(W3CIISLog 
| where TimeGenerated >= ago(timeframe)
| where isnotempty(cIP)
| where cIP in (IPList)
| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName
),
(AzureActivity 
| where TimeGenerated >= ago(timeframe)
| where isnotempty(CallerIpAddress)
| where CallerIpAddress in (IPList)
| extend timestamp = TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller
),
(
AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where isnotempty(SourceIpAddress)
| where SourceIpAddress in (IPList)
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName
)
)
",1d,1d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/IridiumIOCs.yaml,2020-10-04,IridiumIOCs.yaml
70b12a3b-4896-42cb-910c-5ffaf8d7987d,2020-10-04 07:11:15.6720053,,CredentialAccess,,,GCP,Detection,Azure Sentinel Community Github,THALLIUM domains included in DCU takedown,"'THALLIUM spearphishing and command and control domains included in December 2019 DCU/MSTIC takedown. 
 Matches domain name IOCs related to the THALLIUM activity group with CommonSecurityLog, DnsEvents, VMConnection and SecurityEvents dataTypes.
 References: https://blogs.microsoft.com/on-the-issues/2019/12/30/microsoft-court-action-against-nation-state-cybercrime/ '
",PaloAltoNetworks,CommonSecurityLog,"let timeframe = 1d;
let DomainNames = dynamic([""seoulhobi.biz"", ""reader.cash"", ""pieceview.club"", ""app-wallet.com"", ""bigwnet.com"", ""bitwoll.com"", ""cexrout.com"", ""change-pw.com"", ""checkprofie.com"", ""cloudwebappservice.com"", ""ctquast.com"", ""dataviewering.com"", ""day-post.com"", ""dialy-post.com"", ""documentviewingcom.com"", ""dovvn-mail.com"", ""down-error.com"", ""drivecheckingcom.com"", ""drog-service.com"", ""encodingmail.com"", ""filinvestment.com"", ""foldershareing.com"", ""golangapis.com"", ""hotrnall.com"", ""lh-logins.com"", ""login-use.com"", ""mail-down.com"", ""matmiho.com"", ""mihomat.com"", ""natwpersonal-online.com"", ""nidlogin.com"", ""nid-login.com"", ""nidlogon.com"", ""pw-change.com"", ""rnaii.com"", ""rnailm.com"", ""sec-live.com"", ""secrityprocessing.com"", ""securitedmode.com"", ""securytingmail.com"", ""set-login.com"", ""usrchecking.com"", ""com-serviceround.info"", ""mai1.info"", ""reviewer.mobi"", ""files-download.net"", ""fixcool.net"", ""hanrnaii.net"", ""office356-us.org"", ""smtper.org""]);
(union isfuzzy=true
(CommonSecurityLog 
| where TimeGenerated >= ago(timeframe) 
| parse Message with * '(' DNSName ')' * 
| where isnotempty(FileHash)
| where DNSName in~ (DomainNames)
| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP
),
(DnsEvents 
| where TimeGenerated >= ago(timeframe) 
| extend DNSName = Name
| where isnotempty(DNSName)
| where DNSName  in~ (DomainNames)
| extend IPAddress = ClientIP
),
(VMConnection 
| where TimeGenerated >= ago(timeframe) 
| parse RemoteDnsCanonicalNames with * '[""' DNSName '""]' *
| where isnotempty(DNSName)
| where DNSName  in~ (DomainNames)
| extend IPAddress = RemoteIp
)
)
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress",1d,1d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ThalliumIOCs.yaml,2020-10-04,ThalliumIOCs.yaml
a2e36ce0-da4d-4b6e-88c6-4e40161c5bfc,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Email entity to SecurityAlert,"'Identifies a match in SecurityAlert table from any Email IOC from TI which will extend coverage to datatypes such as MCAS, StorageThreatProtection and many others'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$';
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
//Filtering the table for Email related IOCs
| where isnotempty(EmailRecipient)
| join (
    SecurityAlert | where TimeGenerated >= ago(dt_lookBack)
    // Converting Entities into dynamic data type and use mv-expand to unpack the array
    | extend EntitiesDynamicArray = parse_json(Entities) | mv-expand EntitiesDynamicArray
    // Parsing relevant entity column to filter type account and creating new column by combining account and UPNSuffix
    | extend Entitytype = tostring(parse_json(EntitiesDynamicArray).Type), EntityName = tostring(parse_json(EntitiesDynamicArray).Name),
    EntityUPNSuffix = tostring(parse_json(EntitiesDynamicArray).UPNSuffix)
    | where Entitytype =~ ""account""
    | extend EntityEmail = tolower(strcat(EntityName, ""@"", EntityUPNSuffix))
    | where EntityEmail matches regex emailregex
    | extend SecurityAlert_TimeGenerated = TimeGenerated
)
on $left.EmailRecipient == $right.EntityEmail
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, SecurityAlert_TimeGenerated,
EmailSenderName, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, EntityEmail, AlertName, AlertType,
AlertSeverity, Entities, ProviderName, VendorName
| extend timestamp = SecurityAlert_TimeGenerated, AccountCustomEntity = EntityEmail, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_SecurityAlert.yaml,2020-10-04,EmailEntity_SecurityAlert.yaml
4a3f5ed7-8da5-4ce2-af6f-c9ada45060f2,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Email entity to OfficeActivity,"'Identifies a match in OfficeActivity table from any Email IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$';
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
//Filtering the table for Email related IOCs
| where isnotempty(EmailRecipient)
| join (
    OfficeActivity | where TimeGenerated >= ago(dt_lookBack) and isnotempty(UserId)
    | where UserId matches regex emailregex
    | extend OfficeActivity_TimeGenerated = TimeGenerated
)
on $left.EmailRecipient == $right.UserId
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, OfficeActivity_TimeGenerated,
EmailSenderName, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, UserId, ClientIP, Operation, UserType, RecordType, OfficeWorkload, Parameters
| extend timestamp = OfficeActivity_TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_OfficeActivity.yaml,2020-10-04,EmailEntity_OfficeActivity.yaml
9713e3c0-1410-468d-b79e-383448434b2d,2020-10-04 07:11:15.6720053,,Impact,,,Azure,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to VMConnection,"'Identifies a match in VMConnection from any IP IOC from TI'
",AzureMonitor(VMInsights),VMConnection,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    VMConnection
    | where TimeGenerated >= ago(dt_lookBack)
    // renaming time column so it is clear the log this came from
    | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.RemoteIp
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, VMConnection_TimeGenerated,
TI_ipEntity, Computer, Direction, ProcessName, SourceIp, DestinationIp, RemoteIp, Protocol, DestinationPort, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_VMConnection.yaml,2020-10-04,IPEntity_VMConnection.yaml
f30a47c1-65fb-42b1-a7f4-00941c12550b,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map URL entity to SecurityAlert data,"'Identifies a match in SecurityAlert data from any URL IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(Url)
| join (
  SecurityAlert
  | where TimeGenerated >= ago(dt_lookBack)
  // Extract URL from JSON data
  | extend Url = extract(""(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)"", 1,Entities)
  // We only want alerts that actually contain URL data
  | where isnotempty(Url)
  // Extract hostname from JSON data for entity mapping
  | extend Compromised_Host = tostring(parse_json(ExtendedProperties).[""Compromised Host""])
  | extend Alert_TimeGenerated = TimeGenerated
) on Url
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Alert_TimeGenerated,
AlertName, AlertSeverity, Description, Url, Compromised_Host
| extend timestamp = Alert_TimeGenerated, HostCustomEntity = Compromised_Host, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_SecurityAlerts.yaml,2020-10-04,URLEntity_SecurityAlerts.yaml
ffcd575b-3d54-482a-a6d8-d0de13b6ac63,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Email entity to CommonSecurityLog,"'Identifies a match in CommonSecurityLog table from any Email IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$';
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
//Filtering the table for Email related IOCs
| where isnotempty(EmailRecipient)
| join (
    CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack) and isnotempty(DestinationUserID)
    // Filtering PAN Logs for specific event type to match relevant email entities
    | where DeviceVendor == ""Palo Alto Networks"" and  DeviceEventClassID == ""wildfire"" and ApplicationProtocol in (""smtp"",""pop3"")
    | extend DestinationUserID = tolower(DestinationUserID)
    | where DestinationUserID matches regex emailregex
    | extend CommonSecurityLog_TimeGenerated = TimeGenerated
)
on $left.EmailRecipient == $right.DestinationUserID
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, CommonSecurityLog_TimeGenerated,
EmailSenderName, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, DestinationUserID, DeviceEventClassID, LogSeverity, DeviceAction,
SourceIP, SourcePort, DestinationIP, DestinationPort, Protocol, ApplicationProtocol
| extend timestamp = CommonSecurityLog_TimeGenerated, AccountCustomEntity = DestinationUserID, IPCustomEntity = SourceIP, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_PaloAlto.yaml,2020-10-04,EmailEntity_PaloAlto.yaml
f15370f4-c6fa-42c5-9be4-1d308f40284e,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to OfficeActivity,"'Identifies a match in OfficeActivity from any IP IOC from TI'
",Office365,OfficeActivity,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    OfficeActivity | where TimeGenerated >= ago(dt_lookBack)
    // renaming time column so it is clear the log this came from
    | extend OfficeActivity_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.ClientIP
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, OfficeActivity_TimeGenerated,
TI_ipEntity, ClientIP, UserId, Operation, ResultStatus, RecordType, OfficeObjectId, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = OfficeActivity_TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = UserId, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_OfficeActivity.yaml,2020-10-04,IPEntity_OfficeActivity.yaml
106813db-679e-4382-a51b-1bfc463befc3,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map URL entity to PaloAlto data,"'Identifies a match in PaloAlto data from any URL IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(Url)
| join (
  CommonSecurityLog
  | extend IngestionTime = ingestion_time()
  | where IngestionTime > ago(dt_lookBack)
  // Select on Palo Alto logs
  | where DeviceVendor =~ ""Palo Alto Networks""
  | where DeviceEventClassID =~ 'url'
  //Uncomment the line below to only alert on allowed connections
  //| where DeviceAction !~ ""block-url""
  //Select logs where URL data is populated
  | extend PA_Url = columnifexists(""RequestURL"", ""None"")
  | extend PA_Url = iif(isempty(PA_Url), extract(""([^\""]+)"", 1, tolower(AdditionalExtensions)), trim('""', PA_Url))
  | extend PA_Url = iif(PA_Url !startswith ""http://"" and ApplicationProtocol !~ ""ssl"", strcat('http://', PA_Url), iif(PA_Url !startswith ""https://"" and ApplicationProtocol =~ ""ssl"", strcat('https://', PA_Url), PA_Url))
  | where isnotempty(PA_Url)
  | extend CSL_TimeGenerated = TimeGenerated
) on $left.Url == $right.PA_Url
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, DeviceAction, SourceIP, CSL_TimeGenerated, PA_Url, DeviceName
| extend timestamp = CSL_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, URLCustomEntity = PA_Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_PaloAlto.yaml,2020-10-04,URLEntity_PaloAlto.yaml
b31037ea-6f68-4fbd-bab2-d0d0f44c2fcf,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map URL entity to Syslog data,"'Identifies a match in Syslog data from any URL IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(Url)
| join (
  Syslog
  | where TimeGenerated >= ago(dt_lookBack)
  // Extract URL from the Syslog message but only take messages that include URLs
  | extend Url = extract(""(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)"", 1,SyslogMessage)
  | where isnotempty(Url)
  | extend Syslog_TimeGenerated = TimeGenerated
) on Url
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Syslog_TimeGenerated, SyslogMessage, Computer, ProcessName, Url, HostIP
| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_Syslog.yaml,2020-10-04,URLEntity_Syslog.yaml
712fab52-2a7d-401e-a08c-ff939cc7c25e,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map URL entity to AuditLogs,"'Identifies a match in AuditLogs from any URL IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(Url)
| join (
  AuditLogs
  | where TimeGenerated >= ago(dt_lookBack)
  // Extract the URL that is contained within the JSON data
  | extend Url = extract(""(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+);"", 1,tostring(TargetResources))
  | where isnotempty(Url)
  | extend userPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
  | extend TargetResourceDisplayName = tostring(TargetResources[0].displayName)
  | extend Audit_TimeGenerated = TimeGenerated
) on Url
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
Audit_TimeGenerated, OperationName, Identity, userPrincipalName, TargetResourceDisplayName, Url
| extend timestamp = Audit_TimeGenerated, AccountCustomEntity = userPrincipalName, HostCustomEntity = TargetResourceDisplayName, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_AuditLogs.yaml,2020-10-04,URLEntity_AuditLogs.yaml
2fc5d810-c9cc-491a-b564-841427ae0e50,2020-10-04 07:11:15.6720053,,Impact,,,Windows,Detection,Azure Sentinel Community Github,(Preview) TI map Email entity to SecurityEvent,"'Identifies a match in SecurityEvent table from any Email IOC from TI'
",SecurityEvents,SecurityEvent,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$';
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
//Filtering the table for Email related IOCs
| where isnotempty(EmailRecipient)
| join (
    SecurityEvent | where TimeGenerated >= ago(dt_lookBack) and isnotempty(TargetUserName)
    //Normalizing the column to lower case for exact match with EmailRecipient column
    | extend TargetUserName = tolower(TargetUserName)
    // renaming timestamp column so it is clear the log this came from SecurityEvent table
    | extend SecurityEvent_TimeGenerated = TimeGenerated
)
on $left.EmailRecipient == $right.TargetUserName
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, SecurityEvent_TimeGenerated,
EmailSenderName, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, Computer, EventID, TargetUserName, Activity, IpAddress, AccountType,
LogonTypeName, LogonProcessName, Status, SubStatus
| extend timestamp = SecurityEvent_TimeGenerated, AccountCustomEntity = TargetUserName, IPCustomEntity = IpAddress, HostCustomEntity = Computer, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_SecurityEvent.yaml,2020-10-04,EmailEntity_SecurityEvent.yaml
5e45930c-09b1-4430-b2d1-cc75ada0dc0f,2020-10-04 07:11:15.6720053,,Impact,,,SaaS,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to W3CIISLog,"'Identifies a match in W3CIISLog from any IP IOC from TI'
",AzureMonitor(IIS),W3CIISLog,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    W3CIISLog
    | where TimeGenerated >= ago(dt_lookBack)
    | where isnotempty(cIP)
    // renaming time column so it is clear the log this came from
    | extend W3CIISLog_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.cIP
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
W3CIISLog_TimeGenerated, TI_ipEntity, Computer, sSiteName, cIP, sIP, sPort, csMethod, csUserName, scStatus, scSubStatus, scWin32Status,
NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = W3CIISLog_TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_W3CIISLog.yaml,2020-10-04,IPEntity_W3CIISLog.yaml
85aca4d1-5d15-4001-abd9-acb86ca1786a,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Domain entity to DnsEvent,"'Identifies a match in DnsEvent table from any Domain IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
//Create a list of TLDs in our threat feed for later validation
let list_tlds = ThreatIntelligenceIndicator
| where TimeGenerated > ago(ioc_lookBack)
| where isnotempty(DomainName)
| extend parts = split(DomainName, '.')
| extend tld = parts[(array_length(parts)-1)]
| summarize count() by tostring(tld)
| summarize make_list(tld);
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(DomainName)
| join (
     DnsEvents
    | where TimeGenerated > ago(dt_lookBack)
    //Extract domain patterns from syslog message
    | where isnotempty(Name)
    | extend parts = split(Name, '.')
    //Split out the TLD
    | extend tld = parts[(array_length(parts)-1)]
    //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed
    | where tld in~ (list_tlds)
    | extend DNS_TimeGenerated = TimeGenerated
) on $left.DomainName==$right.Name
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Url, DNS_TimeGenerated, Computer, ClientIP, Name, QueryType
| extend timestamp = DNS_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = ClientIP, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_DnsEvents.yaml,2020-10-04,DomainEntity_DnsEvents.yaml
36a9c9e5-3dc1-4ed9-afaa-1d13617bfc2b,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map URL entity to OfficeActivity data,"'Identifies a match in OfficeActivity data from any URL IOC from TI'
",ThreatIntelligence,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(Url)
| join (
 OfficeActivity
  | where TimeGenerated >= ago(dt_lookBack)
  //Extract the Url from a number of potential fields
  | extend Url = iif(OfficeWorkload == ""AzureActiveDirectory"",extract(""(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+);"", 1,ModifiedProperties),tostring(parse_json(ModifiedProperties)[12].NewValue))
  | where isnotempty(Url)
  // Ensure we get a clean URL
  | extend Url = tostring(split(Url, ';')[0])
  | extend Office_TimeGenerated = TimeGenerated
  // Project a single user identity that we can use for entity mapping
  | extend User = iif(isnotempty(UserId), UserId, iif(isnotempty(Actor), tostring(parse_json(Actor)[0].ID), tostring(parse_json(Parameters)[0].Vlaue))) 
) on Url
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Operation, 
UserType, OfficeWorkload, Parameters, Office_TimeGenerated, Url, User
| extend timestamp = Office_TimeGenerated, AccountCustomEntity = User, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_OfficeActivity.yaml,2020-10-04,URLEntity_OfficeActivity.yaml
5d33fc63-b83b-4913-b95e-94d13f0d379f,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map File Hash to CommonSecurityLog Event,"'Identifies a match in CommonSecurityLog Event data from any FileHash IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let fileHashIndicators = ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileHashValue);
// Handle matches against both lower case and uppercase versions of the hash:
( fileHashIndicators | extend  FileHashValue = tolower(FileHashValue)
  |union (fileHashIndicators | extend FileHashValue = toupper(FileHashValue)))
|  join (
   CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack)
   | where isnotempty(FileHash)
   | extend CommonSecurityLog_TimeGenerated = TimeGenerated
)
on $left.FileHashValue == $right.FileHash
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
CommonSecurityLog_TimeGenerated, SourceIP, SourcePort, DestinationIP, DestinationPort, SourceUserID, SourceUserName, DeviceName, DeviceAction,
RequestURL, DestinationUserName, DestinationUserID, ApplicationProtocol, Activity
| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, AccountCustomEntity = SourceUserName, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/FileHashEntity_CommonSecurityLog.yaml,2020-10-04,FileHashEntity_CommonSecurityLog.yaml
2be4ef67-a93f-4d8a-981a-88158cb73abd,2020-10-04 07:11:15.6720053,,Impact,,,GCP,Detection,Azure Sentinel Community Github,Microsoft COVID-19 file hash indicator matches,"'Identifies a match in CommonSecurityLog Event data from any FileHash published in the Microsoft COVID-19 Threat Intel Feed - as described at https://www.microsoft.com/security/blog/2020/05/14/open-sourcing-covid-threat-intelligence/'
",PaloAltoNetworks,CommonSecurityLog,"
let dt_lookBack = 1h;
let covidIndicators = (externaldata(TimeGenerated:datetime, FileHashValue:string, FileHashType: string, TlpLevel: string, Product: string, ThreatType: string, Description: string )
[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.Covid19.Indicators.csv""] with (format=""csv""));
let fileHashIndicators = covidIndicators
| where isnotempty(FileHashValue);
// Handle matches against both lower case and uppercase versions of the hash:
( fileHashIndicators | extend FileHashValue = tolower(FileHashValue)
  | union (fileHashIndicators | extend FileHashValue = toupper(FileHashValue)))
|  join (
   CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack) 
   | where isnotempty(FileHash)
   | extend CommonSecurityLog_TimeGenerated = TimeGenerated
)
on $left.FileHashValue == $right.FileHash
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by FileHashValue
| project LatestIndicatorTime, FileHashValue, FileHashType, Description, ThreatType,  
CommonSecurityLog_TimeGenerated, SourceIP, SourcePort, DestinationIP, DestinationPort, SourceUserID, SourceUserName, DeviceName, DeviceAction, 
RequestURL, DestinationUserName, DestinationUserID, ApplicationProtocol, Activity
| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, AccountCustomEntity = SourceUserName
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/FileHashEntity_Covid19_CommonSecurityLog.yaml,2020-10-04,FileHashEntity_Covid19_CommonSecurityLog.yaml
f110287e-1358-490d-8147-ed804b328514,2020-10-04 07:11:15.6720053,,Impact,,,AWS,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to AWSCloudTrail,"'Identifies a match in AWSCloudTrail from any IP IOC from TI'
",AWS,AWSCloudTrail,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    AWSCloudTrail | where TimeGenerated >= ago(dt_lookBack)
    // renaming time column so it is clear the log this came from
    | extend AWSCloudTrail_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.SourceIpAddress
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, AWSCloudTrail_TimeGenerated,
TI_ipEntity, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserIdentityUserName, SourceIpAddress,
NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = AWSCloudTrail_TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AWSCloudTrail.yaml,2020-10-04,IPEntity_AWSCloudTrail.yaml
532f62c1-fba6-4baa-bbb6-4a32a4ef32fa,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Domain entity to Syslog,"'Identifies a match in Syslog table from any Domain IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
//Create a list of TLDs in our threat feed for later validation
let list_tlds = ThreatIntelligenceIndicator
| where TimeGenerated > ago(ioc_lookBack)
| where isnotempty(DomainName)
| extend parts = split(DomainName, '.')
| extend tld = parts[(array_length(parts)-1)]
| summarize count() by tostring(tld)
| summarize make_list(tld);
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(DomainName)
| join (
    Syslog
    | where TimeGenerated > ago(dt_lookBack)
    //Extract domain patterns from syslog message
    | extend domain = extract(""(([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,})"",1, tolower(SyslogMessage))
    | where isnotempty(domain)
    | extend parts = split(domain, '.')
    //Split out the TLD
    | extend tld = parts[(array_length(parts)-1)]
    //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed
    | where tld in~ (list_tlds)
    | extend Syslog_TimeGenerated = TimeGenerated
) on $left.DomainName==$right.domain
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Syslog_TimeGenerated, SyslogMessage, Computer, ProcessName, domain, HostIP, Url
| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_Syslog.yaml,2020-10-04,DomainEntity_Syslog.yaml
87890d78-3e05-43ec-9ab9-ba32f4e01250,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Domain entity to SecurityAlert,"'Identifies a match in SecurityAlert table from any Domain IOC from TI'
",AzureSecurityCenter,SecurityAlert,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
//Create a list of TLDs in our threat feed for later validation
let list_tlds = ThreatIntelligenceIndicator
| where TimeGenerated > ago(ioc_lookBack)
| where isnotempty(DomainName)
| extend parts = split(DomainName, '.')
| extend tld = parts[(array_length(parts)-1)]
| summarize count() by tostring(tld)
| summarize make_list(tld);
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(DomainName)
| join (
    SecurityAlert
    | where TimeGenerated > ago(dt_lookBack)
    //Extract domain patterns from message
    | extend domain = extract(""(([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,})"", 1, tolower(Entities))
    | where isnotempty(domain)
    | extend parts = split(domain, '.')
    //Split out the TLD
    | extend tld = parts[(array_length(parts)-1)]
    //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed
    | where tld in~ (list_tlds)
    // Converting Entities into dynamic data type and use mv-expand to unpack the array
    | extend EntitiesDynamicArray = parse_json(Entities) | mv-expand EntitiesDynamicArray
    // Parsing relevant entity column extract hostname and IP address
    | extend EntityType = tostring(parse_json(EntitiesDynamicArray).Type), EntityAddress = tostring(EntitiesDynamicArray.Address), EntityHostName = tostring(EntitiesDynamicArray.HostName)
    | extend HostName = iif(EntityType == 'host', EntityHostName, '')
    | extend IP_addr = iif(EntityType == 'ip', EntityAddress, '')
    | extend Alert_TimeGenerated = TimeGenerated
    | extend Alert_Description = Description
) on $left.DomainName==$right.domain
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Alert_TimeGenerated, AlertName, Alert_Description, ProviderName, AlertSeverity, ConfidenceLevel, HostName, IP_addr, Url
| extend timestamp = Alert_TimeGenerated, HostCustomEntity = HostName, IPCustomEntity = IP_addr, URLCustomEntity = Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_SecurityAlert.yaml,2020-10-04,DomainEntity_SecurityAlert.yaml
dd0a6029-ecef-4507-89c4-fc355ac52111,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Domain entity to CommonSecurityLog,"'Identifies a match in CommonSecurityLog table from any Domain IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"let dt_lookBack = 1h;
let ioc_lookBack = 14d;
//Create a list of TLDs in our threat feed for later validation of extracted domains
let list_tlds = ThreatIntelligenceIndicator
    | where TimeGenerated > ago(ioc_lookBack)
    | where isnotempty(DomainName)
    | extend DomainName = tolower(DomainName)
    | extend parts = split(DomainName, '.')
    | extend tld = parts[(array_length(parts)-1)]
    | summarize count() by tostring(tld)
    | summarize make_list(tld);
    ThreatIntelligenceIndicator
    | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
    | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
    | where Active == true
    // Picking up only IOC's that contain the entities we want
    | where isnotempty(DomainName)
    | join (
        CommonSecurityLog
        | extend IngestionTime = ingestion_time()
        | where IngestionTime > ago(dt_lookBack)
        | where DeviceEventClassID =~ 'url'
        //Uncomment the line below to only alert on allowed connections
        //| where DeviceAction !~ ""block-url""
        //Extract domain from RequestURL, if not present extarct it from AdditionalExtentions
        | extend PA_Url = columnifexists(""RequestURL"", ""None"")
        | extend PA_Url = iif(isempty(PA_Url) and AdditionalExtensions !startswith ""PanOS"", extract(""([^\""]+)"", 1, tolower(AdditionalExtensions)), trim('""', PA_Url))
        | extend PA_Url = iif(PA_Url !startswith ""http://"" and ApplicationProtocol !~ ""ssl"", strcat('http://', PA_Url), iif(PA_Url !startswith ""https://"" and ApplicationProtocol =~ ""ssl"", strcat('https://', PA_Url), PA_Url))
        | extend Domain = trim(@"""""""",tostring(parse_url(PA_Url).Host))
        | where isnotempty(Domain)
        | extend Domain = tolower(Domain)
        | extend parts = split(Domain, '.')
        //Split out the TLD for the purpose of checking if we have any TI indicators with this TLD to match on
        | extend tld = parts[(array_length(parts)-1)]
        //Validate parsed domain by checking TLD against TLDs from threat feed and drop domains where there is no chance of a match
        | where tld in~ (list_tlds)
        | extend CSL_TimeGenerated = TimeGenerated
    ) on $left.DomainName==$right.Domain
    | project LatestIndicatorTime, Description, ActivityGroupNames, PA_Url, Domain, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, CSL_TimeGenerated, DeviceAction, DestinationIP, DestinationPort, DeviceName, SourceIP, SourcePort, ApplicationProtocol, RequestMethod
    | extend timestamp = CSL_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, URLCustomEntity = PA_Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_CommonSecurityLog.yaml,2020-10-04,DomainEntity_CommonSecurityLog.yaml
69b7723c-2889-469f-8b55-a2d355ed9c87,2020-10-04 07:11:15.6720053,,Impact,,,Windows,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to DnsEvents,"'Identifies a match in DnsEvents from any IP IOC from TI'
",DNS,DnsEvents,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    DnsEvents | where TimeGenerated >= ago(dt_lookBack)
    | where SubType =~ ""LookupQuery"" and isnotempty(IPAddresses)
    | extend SingleIP = split(IPAddresses, "","")
    | mvexpand SingleIP
    | extend SingleIP = tostring(SingleIP)
    // renaming time column so it is clear the log this came from
    | extend DNS_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.SingleIP
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, DNS_TimeGenerated,
TI_ipEntity, Computer, EventId, SubType, ClientIP, Name, IPAddresses, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = DNS_TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_DnsEvents.yaml,2020-10-04,IPEntity_DnsEvents.yaml
30fa312c-31eb-43d8-b0cc-bcbdfb360822,2020-10-04 07:11:15.6720053,,Impact,,,Azure AD,Detection,Azure Sentinel Community Github,(Preview) TI map Email entity to SigninLogs,"'Identifies a match in SigninLogs table from any Email IOC from TI'
",AzureActiveDirectory,SigninLogs,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$';
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
//Filtering the table for Email related IOCs
| where isnotempty(EmailRecipient)
| join (
    SigninLogs | where TimeGenerated >= ago(dt_lookBack) and isnotempty(UserPrincipalName)
    //Normalizing the column to lower case for exact match with EmailRecipient column
    | extend UserPrincipalName = tolower(UserPrincipalName)
    | where UserPrincipalName matches regex emailregex
    | extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
    | extend Region = tostring(LocationDetails[""countryOrRegion""]), State = tostring(LocationDetails[""state""]), City = tostring(LocationDetails[""city""])
    // renaming timestamp column so it is clear the log this came from SigninLogs table
    | extend SigninLogs_TimeGenerated = TimeGenerated
)
on $left.EmailRecipient == $right.UserPrincipalName
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, SigninLogs_TimeGenerated,
EmailSenderName, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, IPAddress, UserPrincipalName, AppDisplayName,
StatusCode, StatusDetails, NetworkIP, NetworkDestinationIP, NetworkSourceIP
| extend timestamp = SigninLogs_TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_SigninLogs.yaml,2020-10-04,EmailEntity_SigninLogs.yaml
a50766a7-0674-4ccb-8845-15dc55a80ba1,2020-10-04 07:11:15.6720053,,Impact,,,Linux,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to WireData,"'Identifies a match in WireData from any IP IOC from TI'
",AzureMonitor(WireData),WireData,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    WireData | where TimeGenerated >= ago(dt_lookBack)
    | where isnotempty(RemoteIP)
    // renaming time column so it is clear the log this came from
    | extend WireData_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.RemoteIP
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, WireData_TimeGenerated,
TI_ipEntity, Computer, LocalIP, RemoteIP, ProcessName, ApplicationProtocol, LocalPortNumber, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = WireData_TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = Computer, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_WireData.yaml,2020-10-04,IPEntity_WireData.yaml
f2eb15bd-8a88-4b24-9281-e133edfba315,2020-10-04 07:11:15.6720053,,Impact,,,Azure AD,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to SigninLogs,"'Identifies a match in SigninLogs from any IP IOC from TI'
",AzureActiveDirectory,SigninLogs,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    SigninLogs | where TimeGenerated >= ago(dt_lookBack)
    | extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
    | extend Region = tostring(LocationDetails[""countryOrRegion""]), State = tostring(LocationDetails[""state""]), City = tostring(LocationDetails[""city""])
    // renaming time column so it is clear the log this came from
    | extend SigninLogs_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.IPAddress
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, SigninLogs_TimeGenerated,
TI_ipEntity, IPAddress, UserPrincipalName, AppDisplayName, StatusCode, StatusDetails, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = SigninLogs_TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPentity_SigninLogs.yaml,2020-10-04,IPentity_SigninLogs.yaml
cca3b4d9-ac39-4109-8b93-65bb284003e6,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Email entity to AzureActivity,"'Identifies a match in AzureActivity table from any Email IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$';
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
//Filtering the table for Email related IOCs
| where isnotempty(EmailRecipient)
| join (
    AzureActivity | where TimeGenerated >= ago(dt_lookBack) and isnotempty(Caller)
    | extend Caller = tolower(Caller)
    | where Caller matches regex emailregex
    | extend AzureActivity_TimeGenerated = TimeGenerated
)
on $left.EmailRecipient == $right.Caller
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Url, AzureActivity_TimeGenerated,
EmailSenderName, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, Caller, Level, CallerIpAddress, Category, OperationName,
OperationNameValue, ActivityStatus, ResourceGroup, SubscriptionId
| extend timestamp = AzureActivity_TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_AzureActivity.yaml,2020-10-04,EmailEntity_AzureActivity.yaml
2441bce9-02e4-407b-8cc7-7d597f38b8b0,2020-10-04 07:11:15.6720053,,Impact,,,SaaS,Detection,Azure Sentinel Community Github,(Preview) TI map IP entity to AzureActivity,"'Identifies a match in AzureActivity from any IP IOC from TI'
",AzureActivity,AzureActivity,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
    AzureActivity | where TimeGenerated >= ago(dt_lookBack)
    // renaming time column so it is clear the log this came from
    | extend AzureActivity_TimeGenerated = TimeGenerated
)
on $left.TI_ipEntity == $right.CallerIpAddress
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, AzureActivity_TimeGenerated,
TI_ipEntity, CallerIpAddress, Caller, OperationName, ActivityStatus, Category, ResourceId, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = AzureActivity_TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AzureActivity.yaml,2020-10-04,IPEntity_AzureActivity.yaml
ec21493c-2684-4acd-9bc2-696dbad72426,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map Domain entity to PaloAlto,"'Identifies a match in Palo Alto data in CommonSecurityLog table from any Domain IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
//Create a list of TLDs in our threat feed for later validation of extracted domains
let list_tlds = ThreatIntelligenceIndicator
    | where TimeGenerated > ago(ioc_lookBack)
    | where isnotempty(DomainName)
    | extend DomainName = tolower(DomainName)
    | extend parts = split(DomainName, '.')
    | extend tld = parts[(array_length(parts)-1)]
    | summarize count() by tostring(tld)
    | summarize make_list(tld);
    ThreatIntelligenceIndicator
    | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
    | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
    | where Active == true
    // Picking up only IOC's that contain the entities we want
    | where isnotempty(DomainName)
    | join (
        CommonSecurityLog
        | extend IngestionTime = ingestion_time()
        | where IngestionTime > ago(dt_lookBack)
        | where DeviceVendor =~ 'Palo Alto Networks'
        | where DeviceEventClassID =~ 'url'
        //Uncomment the line below to only alert on allowed connections
        //| where DeviceAction !~ ""block-url""
        //Extract domain from RequestURL, if not present extarct it from AdditionalExtentions
        | extend PA_Url = columnifexists(""RequestURL"", ""None"")
        | extend PA_Url = iif(isempty(PA_Url) and AdditionalExtensions !startswith ""PanOS"", extract(""([^\""]+)"", 1, tolower(AdditionalExtensions)), trim('""', PA_Url))
        | extend PA_Url = iif(PA_Url !startswith ""http://"" and ApplicationProtocol !~ ""ssl"", strcat('http://', PA_Url), iif(PA_Url !startswith ""https://"" and ApplicationProtocol =~ ""ssl"", strcat('https://', PA_Url), PA_Url))
        | extend Domain = trim(@"""""""",tostring(parse_url(PA_Url).Host))
        | where isnotempty(Domain)
        | extend Domain = tolower(Domain)
        | extend parts = split(Domain, '.')
        //Split out the TLD for the purpose of checking if we have any TI indicators with this TLD to match on
        | extend tld = parts[(array_length(parts)-1)]
        //Validate parsed domain by checking TLD against TLDs from threat feed and drop domains where there is no chance of a match
        | where tld in~ (list_tlds)
        | extend CSL_TimeGenerated = TimeGenerated
    ) on $left.DomainName==$right.Domain
    | project LatestIndicatorTime, Description, ActivityGroupNames, PA_Url, Domain, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, CSL_TimeGenerated, DeviceAction, DestinationIP, DestinationPort, DeviceName, SourceIP, SourcePort, ApplicationProtocol, RequestMethod
    | extend timestamp = CSL_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, URLCustomEntity = PA_Url
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_PaloAlto.yaml,2020-10-04,DomainEntity_PaloAlto.yaml
a7427ed7-04b4-4e3b-b323-08b981b9b4bf,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,(Preview) TI map File Hash to Security Event,"'Identifies a match in Security Event data from any File Hash IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileHashValue)
|  join (
  SecurityEvent | where TimeGenerated >= ago(dt_lookBack)
      | where EventID in (""8003"",""8002"",""8005"")
      | where isnotempty(FileHash)
      | extend SecurityEvent_TimeGenerated = TimeGenerated, Event = EventID
)
on $left.FileHashValue == $right.FileHash
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
SecurityEvent_TimeGenerated, Process, FileHash, Computer, Account, Event
| extend timestamp = SecurityEvent_TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, URLCustomEntity = Url",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/FileHashEntity_SecurityEvent.yaml,2020-10-04,FileHashEntity_SecurityEvent.yaml
aac495a9-feb1-446d-b08e-a1164a539452,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Detection,Azure Sentinel Community Github,TI map IP entity to GitHub_CL,"'Identifies a match in GitHub_CL table from any IP IOC from TI'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(24h)
| where Action == true
// Picking up only IOC's that contain the entities we want
| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)
| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)
| join (
  GitHubAudit
  | where TimeGenerated >= ago(24h)
  | extend GitHubAudit_TimeGenerated = TimeGenerated
)
on on $left.TI_ipEntity == $right.IPaddress
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, GitHubAudit_TimeGenerated, TI_ipEntity, IPaddress, Actor, Action, Country, OperationType, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress
| extend timestamp = GitHubAudit_TimeGenerated, IPCustomEntity = IPaddress, AccountCustomEntity = Actor
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/Threat%20Intel%20Matches%20to%20GitHub%20Audit%20Logs.yaml,2020-10-04,Threat%20Intel%20Matches%20to%20GitHub%20Audit%20Logs.yaml
c01d95d3-ee85-4e7f-9aed-e62356f1de76,2020-10-04 07:11:15.6720053,,LateralMovement,,,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous RDP Activity,"'Adversaries may use Valid Accounts to log into a computer using the Remote Desktop Protocol (RDP). The adversary may then perform actions as the logged-on user. FIN10, for example, has used RDP to move laterally to systems in the victim environment.
",BehaviorAnalytics,BehaviorAnalytics,"
BehaviorAnalytics
| where ActivityType == ""LogOn""
| where ActionType == ""RemoteInteractiveLogon""
| where ActivityInsights has ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20RDP%20Activity.yaml,2020-10-04,Anomalous%20RDP%20Activity.yaml
782f3bad-31f7-468f-8f58-3b74fc931914,2020-10-04 07:11:15.6720053,,LateralMovement,,,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous Resource Access,"'Adversary may be trying to move through the environment. APT29 and APT32, for example, has used PtH & PtT techniques to lateral move around the network. The query below generates an output of all users performing an resource access (4624:3) to devices for the first time.'
",BehaviorAnalytics,BehaviorAnalytics,"
BehaviorAnalytics
| where ActivityType == ""LogOn""
| where ActionType == ""ResourceAccess""
| where ActivityInsights has ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Resource%20Access.yaml,2020-10-04,Anomalous%20Resource%20Access.yaml
af02987c-949d-47d5-b0ae-64d8e1b674e2,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Rare processes run by Service accounts,"'Service accounts normally are supposed to perform a limited set of tasks in a stable environment. 
The query collects a list of service account and then joins them with rare processes in an environment to detect anomalous behaviours.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let List1 = datatable(AccountName:string)[""MSSQLSERVER"", ""ReportServer"", ""MSDTSServer100"", ""IUSR""];         
// Provide a list of service account/ built-in accounts in an environment.
let List2 = SecurityEvent                                                                                   
// Self generating a list of Service account using event Id :4624
| where TimeGenerated >= ago(timeframe)
| where EventID == ""4624""
| where Account !contains ""$"" and Account !contains ""Local SYSTEM"" and Account !contains  ""Local SERVICE"" and Account !contains  ""Network SERVICE"" and Account !contains ""NT AUTHORITY"" and Account !contains ""NT-AUTORITÄT""
| where LogonType == ""5""                                                                                          
| extend AccountName = Account 
| distinct AccountName;
let Accounts = List1 | union (List2 | distinct AccountName);
let ProcessCreationEvents=() {
    let processEvents=SecurityEvent
	| where TimeGenerated >= ago(timeframe)
    | where EventID==4688
    // filter out common randomly named files related to MSI installers and browsers
    | where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{3}\.tmp"")
    | where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{4}\.tmp"")
    | where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{3}\.tmp"")
    | where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{4}\.tmp"")
    | project TimeGenerated, 
      ComputerName=Computer,
      AccountName=SubjectUserName, 
      AccountDomain=SubjectDomainName,
      FileName=tostring(split(NewProcessName, '\\')[-1]),
      ProcessCommandLine = CommandLine, 
      InitiatingProcessFileName=ParentProcessName,
      InitiatingProcessCommandLine="""",
      InitiatingProcessParentFileName="""";
    processEvents;
    };
    let normalizedProcesses = ProcessCreationEvents 
       // normalize guids
       | project TimeGenerated, AccountName, FileName = replace(""[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}"", ""<guid>"", FileName)
       // normalize digits away
       | project TimeGenerated, AccountName, FileName=replace(@'\d', 'n', FileName); 
let freqs = normalizedProcesses
    | summarize frequency = count() by FileName
    | join kind= leftouter (
       normalizedProcesses
       | summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated)  by FileName, AccountName
    ) on FileName;
   let Finalfreqs = freqs 
    | where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 10))
    | order by frequency asc
    | project FileName, frequency, Since, LastSeen , AccountName 
    // restrict results to unusual processes seen in last day 
    | where LastSeen >= ago(timeframe);
Accounts
    | join kind= inner (
        Finalfreqs
) on AccountName
| where frequency < 10
| project-away AccountName1
| extend AccountCustomEntity = AccountName ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcbyServiceAccount.yaml,2020-10-04,RareProcbyServiceAccount.yaml
60304ebf-ebdd-4869-a702-e0216d90ab46,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Masquerading files,"'Malware writers often use windows system process names for their malicious process names to make them blend 
in with other legitimate commands that the Windows system executes.
An analyst can create a simple query looking for a process named svchost.exe. 
It is recommended to filter out well-known security identifiers (SIDs) that are used to launch the legitimate svchost.exe process. 
The query also filters out the legitimate locations from which svchost.exe is launched.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where NewProcessName endswith ""\\svchost.exe""
| where SubjectUserSid !in (""S-1-5-18"", ""S-1-5-19"", ""S-1-5-20"")
| where NewProcessName !contains "":\\Windows\\System32""
| where NewProcessName !contains "":\\Windows\\Syswow64""
| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by Computer, SubjectUserName, NewProcessName, CommandLine, Account
| project minTimeGenerated , maxTimeGenerated , count_ , Computer , SubjectUserName , NewProcessName , CommandLine, Account 
| extend timestamp = minTimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/masquerading_files.yaml,2020-10-04,masquerading_files.yaml
0ff22697-dc58-4623-b844-a767629840cd,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Rare Process Path,"'Identifies when a process is running from a rare path. This could indicate malicious or unexpected activity as attacks 
often try to use common process names running from non-standard locations'
",SecurityEvents,SecurityEvent,"
let end = startofday(now());
let start = end - 8d;
let processEvents=
SecurityEvent
| where TimeGenerated >= start and TimeGenerated <= end
| where EventID==4688
// excluding well known processes
| where NewProcessName !endswith ':\\Windows\\System32\\conhost.exe' and ParentProcessName !endswith ':\\Windows\\System32\\conhost.exe'
| where ParentProcessName !endswith "":\\Windows\\System32\\wuauclt.exe"" and NewProcessName !startswith ""C:\\Windows\\SoftwareDistribution\\Download\\Install\\AM_Delta_Patch_""
| where NewProcessName !has "":\\Windows\\WinSxS\\amd64_microsoft-windows-servicingstack_"" and ParentProcessName !has "":\\Windows\\WinSxS\\amd64_microsoft-windows-servicingstack_""
| where NewProcessName !endswith "":\\WindowsAzure\\SecAgent\\WaSecAgentProv.exe"" 
| where ParentProcessName !has "":\\WindowsAzure\\GuestAgent_"" and NewProcessName !has "":\\WindowsAzure\\GuestAgent_""
| where ParentProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_"" and NewProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_""
| where ParentProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and ParentProcessName !endswith ""\\MpCmdRun.exe"" 
| where NewProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and NewProcessName !endswith ""\\MpCmdRun.exe"" 
| where NewProcessName !has ':\\Program Files\\Microsoft Monitoring Agent\\Agent\\'
// filter out common randomly named paths and files
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{4}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{4}\.tmp"")
| where not(NewProcessName matches regex @""\\Windows\\Temp\\[0-9A-Za-z-]*\\DismHost\.exe"")
| where not(NewProcessName matches regex @""\\Users\\[0-9A-Za-z-_~\.]*\\AppData\\Local\\Temp\\[0-9A-Za-z-]*\\DismHost\.exe"")
| where not(NewProcessName matches regex @""\\Windows\\Temp\\[0-9A-Za-z-]*\\MpSigStub\.exe"")
| where not(NewProcessName matches regex @""\\[0-9A-Za-z]*\\amd64\\setup\.exe"") and (ParentProcessName !has "":\\Windows\\SoftwareDistribution\\Download\\Install\\"" 
or ParentProcessName !has ""\\AppData\\Local\\Temp\\mpam-"")
| where not(NewProcessName matches regex @""\\Windows\\Microsoft.NET\\(Framework|Framework64)\\v[0-9].[0-9].[0-9]*\\(csc\.exe|cvtres\.exe|mscorsvw\.exe|ngentask\.exe|ngen\.exe)"")
| where not(NewProcessName matches regex @""\\WindowsAzure\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\"") 
and not(ParentProcessName matches regex @""\\WindowsAzure\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\"")
| where not(NewProcessName matches regex @""\\[0-9A-Za-z]*\\epplauncher.exe"")
| where not(NewProcessName matches regex @""\\Packages\\Plugins\\Microsoft\."")
| extend path_parts = parse_path(NewProcessName)
| extend ProcessPath = tostring(path_parts.DirectoryPath)
;
let normalizedProcessPath = processEvents
| extend NormalizedProcessPath = ProcessPath
// normalize guids
| project TimeGenerated, Computer, Account, Process, ProcessPath, 
NormalizedProcessPath = replace(""[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}"", ""<guid>"", NormalizedProcessPath)
// normalize digits away
| project TimeGenerated, Computer, Account, Process, ProcessPath, NormalizedProcessPath = replace(@'\d', '#', NormalizedProcessPath)
; 
let freqs = normalizedProcessPath
| summarize makelist(Computer), makelist(Account), makelist(ProcessPath), frequency=count() by NormalizedProcessPath, Process
| join kind= leftouter (
normalizedProcessPath
| summarize StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated) by NormalizedProcessPath, Process
) on NormalizedProcessPath, Process;
freqs
| where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))
| order by frequency asc  
| mvexpand Computer = list_Computer, Account = list_Account, ProcessPath = list_ProcessPath
| project StartTimeUtc, EndTimeUtc, frequency, Process, NormalizedProcessPath, tostring(ProcessPath), tostring(Computer), tostring(Account)",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcessPath.yaml,2020-10-04,RareProcessPath.yaml
513e3a11-e1bb-4cfc-8af9-451da0407e6b,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,New processes observed in last 24 hours,"'These new processes could be benign new programs installed on hosts; however, especially in normally stable environments, 
these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. 
Reviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.'
",SecurityEvents,SecurityEvent,"
let starttime = 14d;
let endtime = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where TimeGenerated >= ago(starttime) 
| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, @'')[(-1)]), ProcessCommandLine = CommandLine, InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine='',InitiatingProcessParentFileName='';
processEvents};
ProcessCreationEvents
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)
| summarize HostCount=dcount(ComputerName) by tostring(FileName)
| join kind=rightanti (
    ProcessCreationEvents
    | where TimeGenerated >= ago(endtime)
    | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computers = makeset(ComputerName) , HostCount=dcount(ComputerName) by tostring(FileName)
) on FileName
| project StartTimeUtc, Computers, HostCount, FileName
| extend timestamp = StartTimeUtc",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/new_processes.yaml,2020-10-04,new_processes.yaml
892cd37e-f9e1-49c3-b0b2-d74f52ac7b71,2020-10-04 07:11:15.6720053,,CredentialAccess,,,Windows,Hunting Query,Azure Sentinel Community Github,VIP account more than 6 failed logons in 10,"'VIP Account with more than 6 failed logon attempts in 10 minutes, include your own VIP list in the table below
 NTSTATUS codes - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55'
",SecurityEvents,SecurityEvent,"
// Create DataTable with your own values, example below shows dummy usernames and domain
let List = datatable(VIPUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN"", ""administrator"", """"];
let timeframe = 10m;
List
| project TargetUserName = tolower(VIPUser), TargetDomainName = toupper(Domain)
| join kind= rightsemi ( 
SecurityEvent 
| where TimeGenerated > ago(2*timeframe) 
| where EventID == ""4625""
| where AccountType == ""User""
) on TargetUserName, TargetDomainName
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, SubStatus
| where FailedVIPLogons >= 6
// map the most common ntstatus codes
| extend StatusDesc = case(
Status =~ ""0x80090302"", ""SEC_E_UNSUPPORTED_FUNCTION"",
Status =~ ""0x80090308"", ""SEC_E_INVALID_TOKEN"",
Status =~ ""0x8009030E"", ""SEC_E_NO_CREDENTIALS"",
Status =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
Status =~ ""0xC0000017"", ""STATUS_NO_MEMORY"",
Status =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
Status =~ ""0xC0000034"", ""STATUS_OBJECT_NAME_NOT_FOUND"",
Status =~ ""0xC000005E"", ""STATUS_NO_LOGON_SERVERS"",
Status =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
Status =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
Status =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
Status =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
Status =~ ""0xC00000FE"", ""STATUS_NO_SUCH_PACKAGE"",
Status =~ ""0xC000009A"", ""STATUS_INSUFFICIENT_RESOURCES"",
Status =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
Status =~ ""0xC0000106"", ""STATUS_NAME_TOO_LONG"",
Status =~ ""0xC000010B"", ""STATUS_INVALID_LOGON_TYPE"",
Status =~ ""0xC000015B"", ""STATUS_LOGON_TYPE_NOT_GRANTED"",
Status =~ ""0xC000018B"", ""STATUS_NO_TRUST_SAM_ACCOUNT"",
Status =~ ""0xC0000224"", ""STATUS_PASSWORD_MUST_CHANGE"",
Status =~ ""0xC0000234"", ""STATUS_ACCOUNT_LOCKED_OUT"",
Status =~ ""0xC00002EE"", ""STATUS_UNFINISHED_CONTEXT_DELETED"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| extend SubStatusDesc = case(
SubStatus =~ ""0x80090325"", ""SEC_E_UNTRUSTED_ROOT"",
SubStatus =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
SubStatus =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
SubStatus =~ ""0xC0000064"", ""STATUS_NO_SUCH_USER"",
SubStatus =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
SubStatus =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
SubStatus =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
SubStatus =~ ""0xC000006F"", ""STATUS_INVALID_LOGON_HOURS"",
SubStatus =~ ""0xC0000070"", ""STATUS_INVALID_WORKSTATION"",
SubStatus =~ ""0xC0000071"", ""STATUS_PASSWORD_EXPIRED"",
SubStatus =~ ""0xC0000072"", ""STATUS_ACCOUNT_DISABLED"",
SubStatus =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
SubStatus =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
SubStatus =~ ""0xC0000133"", ""STATUS_TIME_DIFFERENCE_AT_DC"",
SubStatus =~ ""0xC000018D"", ""STATUS_TRUSTED_RELATIONSHIP_FAILURE"",
SubStatus =~ ""0xC0000193"", ""STATUS_ACCOUNT_EXPIRED"",
SubStatus =~ ""0xC0000380"", ""STATUS_SMARTCARD_WRONG_PIN"",
SubStatus =~ ""0xC0000381"", ""STATUS_SMARTCARD_CARD_BLOCKED"",
SubStatus =~ ""0xC0000382"", ""STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED"",
SubStatus =~ ""0xC0000383"", ""STATUS_SMARTCARD_NO_CARD"",
SubStatus =~ ""0xC0000384"", ""STATUS_SMARTCARD_NO_KEY_CONTAINER"",
SubStatus =~ ""0xC0000385"", ""STATUS_SMARTCARD_NO_CERTIFICATE"",
SubStatus =~ ""0xC0000386"", ""STATUS_SMARTCARD_NO_KEYSET"",
SubStatus =~ ""0xC0000387"", ""STATUS_SMARTCARD_IO_ERROR"",
SubStatus =~ ""0xC0000388"", ""STATUS_DOWNGRADE_DETECTED"",
SubStatus =~ ""0xC0000389"", ""STATUS_SMARTCARD_CERT_REVOKED"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| project StartTimeUtc, EndTimeUtc, FailedVIPLogons, EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, StatusDesc, SubStatus, SubStatusDesc
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/CustomUserList_FailedLogons.yaml,2020-10-04,CustomUserList_FailedLogons.yaml
5550b630-7b8a-444e-a585-ec8c7533c028,2020-10-04 07:11:15.6720053,,Collection,,,Windows,Hunting Query,Azure Sentinel Community Github,Hosts running a rare process with commandline,"Looking for hosts running a rare process. Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days
",SecurityEvents,SecurityEvent,"let v_StartTime = ago(7d);
let v_EndTime = ago(1m);
let basic=materialize(
  SecurityEvent
    | where TimeGenerated >= ago(30d)
    | where EventID == 4688
    | where isnotempty(CommandLine) and NewProcessName !endswith "":\\windows\\system32\\conhost.exe"" and CommandLine !~ NewProcessName and CommandLine !~ strcat('\""',NewProcessName,'\""',"" ""))
    | extend CommandLine=tolower(CommandLine)
    | summarize FullCount = count()
                , Count= countif(TimeGenerated between (v_StartTime .. v_EndTime))
                , min_TimeGenerated=min(TimeGenerated)
                , max_TimeGenerated=max(TimeGenerated) 
                      by Computer, NewProcessName, CommandLine
    | where Count > 0 and Count < 100);
let basic_avg = basic
    | summarize Avg = avg(FullCount) by  NewProcessName, CommandLine;
basic | project-away FullCount
  | join kind=inner 
basic_avg 
  on NewProcessName, CommandLine | project-away NewProcessName1, CommandLine1
  | where Count < 7 or (Count <= Avg*0.01 and Count < 100) 
  | extend HostCustomEntity=Computer",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcessWithCmdLine.yaml,2020-10-04,RareProcessWithCmdLine.yaml
6d04a1ef-1b4d-4ff8-a76c-ad7d1a396136,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Least Common Processes Including Folder Depth,"'Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo'
",SecurityEvents,SecurityEvent,"
let Allowlist = dynamic (['foo.exe', 'baz.exe']);
let Sensitivity = 15;
let StartDate = ago(7d);
let Duration = 7d;
SecurityEvent
| where EventID == 4688 and TimeGenerated > StartDate and TimeGenerated < (StartDate + Duration)
| extend ProcArray = split(NewProcessName, '\\')
// ProcArrayLength is Folder Depth
| extend ProcArrayLength = arraylength(ProcArray)
| extend LastIndex = ProcArrayLength - 1
| extend Proc = ProcArray[LastIndex]
| where Proc !in (Allowlist)
// ProcArray[0] is the proc's Drive
| extend DriveDepthProc = strcat(ProcArray[0], '-', ProcArrayLength, '-', Proc)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by DriveDepthProc
| where TimesSeen < Sensitivity
| extend timestamp = StartTimeUtc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Least_Common_Process_With_Depth.yaml,2020-10-04,Least_Common_Process_With_Depth.yaml
d83f40fc-bbcc-4020-8d45-ad2d82355cb2,2020-10-04 07:11:15.6720053,,CommandAndControl,,,Windows,Hunting Query,Azure Sentinel Community Github,PowerShell downloads,"'Finds PowerShell execution events that could involve a download'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,
  FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents};
ProcessCreationEvents
| where TimeGenerated >= ago(timeframe) 
| where FileName in~ (""powershell.exe"", ""powershell_ise.exe"")
| where ProcessCommandLine has ""Net.WebClient""
   or ProcessCommandLine has ""DownloadFile""
   or ProcessCommandLine has ""Invoke-WebRequest""
   or ProcessCommandLine has ""Invoke-Shellcode""
   or ProcessCommandLine contains ""http:""
| project TimeGenerated, ComputerName, AccountName, InitiatingProcessFileName, FileName, ProcessCommandLine
| top 100 by TimeGenerated
| extend timestamp = TimeGenerated, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/powershell_downloads.yaml,2020-10-04,powershell_downloads.yaml
088d30e9-c02b-46b1-bd1f-d5b6d6b782f0,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Least Common Processes by Command Line,"'Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo'
",SecurityEvents,SecurityEvent,"
let Allowlist = dynamic (['foo.exe', 'baz.exe']);
let Sensitivity = 5;
let StartDate = ago(7d);
let Duration = 7d;
SecurityEvent
| where EventID == 4688 and TimeGenerated > StartDate and TimeGenerated < (StartDate + Duration) and NewProcessName !endswith 'conhost.exe'
| extend ProcArray = split(NewProcessName, '\\')
// ProcArrayLength is Folder Depth
| extend ProcArrayLength = arraylength(ProcArray)
| extend LastIndex = ProcArrayLength - 1
| extend Proc = ProcArray[LastIndex]
| where Proc !in (Allowlist)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by CommandLine
| where TimesSeen < Sensitivity
| extend timestamp = StartTimeUtc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Least_Common_Process_Command_Lines.yaml,2020-10-04,Least_Common_Process_Command_Lines.yaml
3712595d-6f47-416b-963a-605201ed2764,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Least Common Parent And Child Process Pairs,"'Looks across your environment for least common Parent/Child process combinations.  
Will possibly find some malicious activity disguised as well known process names.  
By ZanCo'
",SecurityEvents,SecurityEvent,"
let Allowlist = dynamic (['foo.exe', 'baz.exe']);
let Sensitivity = 5;
let StartDate = ago(7d);
let Duration = 7d;
SecurityEvent
| where EventID == 4688 and TimeGenerated > StartDate and TimeGenerated < (StartDate + Duration) and isnotnull(ParentProcessName)
| extend ProcArray = split(NewProcessName, '\\'), ParentProcArray = split(ParentProcessName, '\\')
// ProcArrayLength is Folder Depth
| extend ProcArrayLength = arraylength(ProcArray), ParentProcArrayLength = arraylength(ParentProcArray)
| extend LastIndex = ProcArrayLength - 1, ParentLastIndex = ParentProcArrayLength - 1
| extend Proc = ProcArray[LastIndex], ParentProc = ParentProcArray[ParentLastIndex]
| where Proc !in (Allowlist)
| extend ParentChildPair = strcat(ParentProc , ' > ', Proc)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by ParentChildPair
| where TimesSeen < Sensitivity
| extend timestamp = StartTimeUtc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Least_Common_Parent_Child_Process.yaml,2020-10-04,Least_Common_Parent_Child_Process.yaml
2ff4b10c-7056-4898-83fd-774104189fd5,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Uncommon processes - bottom 5%,"'Shows the rarest processes seen running for the first time. (Performs best over longer time ranges - eg 3+ days rather than 24 hours!)
These new processes could be benign new programs installed on hosts; 
However, especially in normally stable environments, these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. 
Reviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
// filter out common randomly named files related to MSI installers and browsers
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{4}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{4}\.tmp"")
| project TimeGenerated, ComputerName=Computer, AccountName=SubjectUserName, AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]), ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName, InitiatingProcessCommandLine="""", InitiatingProcessParentFileName="""";
processEvents;
};
let normalizedProcesses = ProcessCreationEvents 
| where TimeGenerated >= ago(timeframe)
// normalize guids
| project TimeGenerated, FileName = replace(""[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}"", ""<guid>"", FileName)
// normalize digits away
| project TimeGenerated, FileName=replace(@'\d', 'n', FileName); 
let freqs = normalizedProcesses
| summarize frequency=count() by FileName
| join kind= leftouter (
normalizedProcesses
| summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated) by FileName
) on FileName;
freqs 
| where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))
| order by frequency asc
| project FileName, frequency, Since, LastSeen 
// restrict results to unusual processes seen in last day 
| where LastSeen >= ago(1d)
| extend timestamp = LastSeen 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/uncommon_processes.yaml,2020-10-04,uncommon_processes.yaml
36abe031-962d-482e-8e1e-a556ed99d5a3,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Cscript script daily summary breakdown,"'breakdown of scripts running in the environment'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project EventTime=TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]),  ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents;
};
// Daily summary of cscript activity  extracting script name and parameters from commandline:
ProcessCreationEvents 
| where EventTime >= ago(timeframe)
| where FileName =~ ""cscript.exe""
// remove commandline switches
| project EventTime, ComputerName, AccountName, removeSwitches = replace(@""/+[a-zA-Z0-9:]+"", """", ProcessCommandLine)
// remove the leading cscript.exe process name 
| project EventTime, ComputerName, AccountName, CommandLine = trim(@""[a-zA-Z0-9\\:""""]*cscript(.exe)?("""")?(\s)+"", removeSwitches)
// extract the script name:
| project EventTime, ComputerName, AccountName, 
// handle case where script name is enclosed in "" characters or is not enclosed in quotes 
ScriptName= iff(CommandLine startswith @"""""""", 
extract(@""([:\\a-zA-Z_\-\s0-9\.()]+)(""""?)"", 0, CommandLine), 
extract(@""([:\\a-zA-Z_\-0-9\.()]+)(""""?)"", 0, CommandLine)), CommandLine 
| project EventTime, ComputerName, AccountName, ScriptName=trim(@"""""""", ScriptName) , ScriptNameLength=strlen(ScriptName), CommandLine 
// extract remainder of commandline as script parameters: 
| project EventTime, ComputerName, AccountName, ScriptName, ScriptParams = iff(ScriptNameLength < strlen(CommandLine), substring(CommandLine, ScriptNameLength +1), """")
| summarize min(EventTime), count() by ComputerName, AccountName, ScriptName, ScriptParams
| order by count_ asc nulls last 
| extend timestamp = min_EventTime, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/cscript_summary.yaml,2020-10-04,cscript_summary.yaml
82e04ff9-a289-4005-9fcd-f1deec72e3fc,2020-10-04 07:11:15.6720053,,Collection,,,Windows,Hunting Query,Azure Sentinel Community Github,Hosts running a rare process,"Looking for hosts running a rare process. Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days
",SecurityEvents,SecurityEvent,"let v_StartTime = ago(1d);
let v_EndTime = ago(1m);
let basic=materialize(
  SecurityEvent
    | where TimeGenerated >= ago(30d)
    | where EventID == 4688
    | summarize FullCount = count()
                , Count= countif(TimeGenerated between (v_StartTime .. v_EndTime))
                , min_TimeGenerated=min(TimeGenerated)
                , max_TimeGenerated=max(TimeGenerated) 
                      by Computer, NewProcessName
    | where Count > 0 and Count < 100);
let basic_avg = basic
    | summarize Avg = avg(FullCount) by  NewProcessName;
basic | project-away FullCount
  | join kind=inner 
basic_avg 
  on NewProcessName | project-away NewProcessName1
  | where Count < 14 or (Count <= Avg*0.01 and Count < 100) 
  | extend HostCustomEntity=Computer",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcess_forWinHost.yaml,2020-10-04,RareProcess_forWinHost.yaml
05208917-82de-46f7-a190-a65739a690f4,2020-10-04 07:11:15.6720053,,Execution,,,Windows,Hunting Query,Azure Sentinel Community Github,Entropy for Processes for a given Host,"'Entropy calculation used to help identify Hosts where they have a high variety of processes(a high entropy process list on a given Host over time).
This helps us identify rare processes on a given Host. Rare here means a process shows up on the Host relatively few times in the the last 7days.
The Weight is calculated based on the Entropy, Process Count and Distinct Hosts with that Process. The lower the Weight/ProcessEntropy the, more interesting.
The Weight calculation increases the Weight if the process executes more than once on the Host or has executed on more than 1 Hosts.
In general, this should identify processes on a Host that are rare and rare for the environment.
References: https://medium.com/udacity/shannon-entropy-information-gain-and-picking-balls-from-buckets-5810d35d54b4
https://en.wiktionary.org/wiki/Shannon_entropy'
",SecurityEvents,SecurityEvent,"
// May need to reduce the number of days if the environment is very large.  Try 3-5 days, but less accuracy.
let end = startofday(now());
let start = end - 7d;
let Exclude = SecurityEvent
// Timeframe is set so that results do not change during the same day (UTC time)
| where TimeGenerated >= start and TimeGenerated <= end
| where EventID == 4688
| summarize ExcludeCompCount = dcount(Computer),  ExcludeProcCount = count() by Process 
// Removing noisy processes for an environment, adjust as needed
| where ExcludeProcCount >= 2000 and ExcludeCompCount > 2
;
let AllSecEvents = SecurityEvent
| where TimeGenerated >= start and TimeGenerated <= end
| where EventID == 4688
// excluding well known processes
| where NewProcessName !endswith ':\\Windows\\System32\\conhost.exe' and ParentProcessName !endswith ':\\Windows\\System32\\conhost.exe'
| where ParentProcessName !endswith "":\\Windows\\System32\\wuauclt.exe"" and NewProcessName !startswith ""C:\\Windows\\SoftwareDistribution\\Download\\Install\\AM_Delta_Patch_""
| where ParentProcessName !has "":\\WindowsAzure\\GuestAgent_"" and NewProcessName !has "":\\WindowsAzure\\GuestAgent_""
| where ParentProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_"" and NewProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_""
| where ParentProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and ParentProcessName !endswith ""\\MpCmdRun.exe"" 
| project Computer, Process;
// Removing noisy process from full list
let Include = Exclude | join kind= rightanti (
AllSecEvents
) on Process;
// Identifying prevalence for a given process in the environment
let DCwPC = Include | summarize DistinctComputersWithProcessCount = dcount(Computer) by Process
| join kind=inner (
Include 
) on Process
| distinct Computer, Process, DistinctComputersWithProcessCount;
// Getting the Total process count on each host to use as the denominator in the entropy calc
let TPCoH = Include | summarize TotalProcessCountOnHost = count(Process) by Computer
| join kind=inner (
Include 
) on Computer
| distinct Computer, Process, TotalProcessCountOnHost
//Getting a decimal value for later computation
| extend TPCoHValue = todecimal(TotalProcessCountOnHost);
// Need the count of each class in my bucket or also said as count of ProcName(Class) per Host(Bucket) for use in the entropy calc
let PCoH = Include | summarize ProcessCountOnHost = count(Process) by Computer, Process
| join kind=inner (
Include
) on Computer,Process
| distinct Computer, Process, ProcessCountOnHost
//Getting a decimal value for later computation
| extend PCoHValue = todecimal(ProcessCountOnHost);
let Combined = DCwPC | join ( TPCoH ) on Computer, Process | join ( PCoH ) on Computer, Process; 
let Results = Combined
// Entropy calculation
| extend ProcessEntropy = -log2(PCoHValue/TPCoHValue)*(PCoHValue/TPCoHValue)
| extend AdjustedProcessEntropy = toreal(ProcessEntropy*10000)
// Calculating Weight, see details in description
| extend Weight = toreal((ProcessEntropy*10000)*ProcessCountOnHost*DistinctComputersWithProcessCount)
// Remove or increase value to see processes with low entropy, meaning more common.
| where Weight <= 75
| project Computer, Process, Weight , ProcessEntropy, TotalProcessCountOnHost, ProcessCountOnHost, DistinctComputersWithProcessCount, AdjustedProcessEntropy;
// Join back full entry
Results | join kind= inner (
    SecurityEvent
    | where TimeGenerated >= start and TimeGenerated <= end
    | where EventID == 4688
    // excluding well known processes
    | where NewProcessName !endswith ':\\Windows\\System32\\conhost.exe' and ParentProcessName !endswith ':\\Windows\\System32\\conhost.exe'
    | where ParentProcessName !endswith "":\\Windows\\System32\\wuauclt.exe"" and NewProcessName !startswith ""C:\\Windows\\SoftwareDistribution\\Download\\Install\\AM_Delta_Patch_""
    | where ParentProcessName !has "":\\WindowsAzure\\GuestAgent_"" and NewProcessName !has "":\\WindowsAzure\\GuestAgent_""
    | where ParentProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_"" and NewProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_""
    | where ParentProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and ParentProcessName !endswith ""\\MpCmdRun.exe"" 
    | project TimeGenerated, EventID, Computer, SubjectUserSid, Account, AccountType, Process, NewProcessName, CommandLine, ParentProcessName
) on Computer, Process
| project TimeGenerated, EventID, Computer, SubjectUserSid, Account, Weight, AdjustedProcessEntropy, FullDecimalProcessEntropy = ProcessEntropy, Process, NewProcessName, CommandLine, ParentProcessName, TotalProcessCountOnHost, ProcessCountOnHost, DistinctComputersWithProcessCount
| sort by Weight asc, AdjustedProcessEntropy asc, NewProcessName asc
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ProcessEntropy.yaml,2020-10-04,ProcessEntropy.yaml
4e78daf1-8bba-4b5d-8a8b-c75fe9bbc2d9,2020-10-04 07:11:15.6720053,,CommandAndControl,,,Windows,Hunting Query,Azure Sentinel Community Github,New PowerShell scripts encoded on the commandline,"'Identify and decode new encoded powershell scripts this week versus previous 14 days'
",SecurityEvents,SecurityEvent,"
let starttime = 21d;
let midtime = 14d;
let endtime = 7d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,AccountDomain=SubjectDomainName,
  FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents};
let encodedPSScripts = 
ProcessCreationEvents 
| where TimeGenerated >= ago(midtime)
| where FileName =~ ""powershell.exe""
| where ProcessCommandLine contains ""-encodedCommand"";
encodedPSScripts
| where TimeGenerated > ago(endtime)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ProcessCommandLine
| parse ProcessCommandLine with * ""-EncodedCommand "" encodedCommand
| project StartTimeUtc, EndTimeUtc, decodedCommand=base64_decodestring(substring(encodedCommand, 0, 
 strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand 
| join kind=anti (encodedPSScripts
  | where TimeGenerated between(ago(starttime)..ago(endtime))
  | summarize count() by ProcessCommandLine
  | parse ProcessCommandLine with * ""-EncodedCommand "" encodedCommand
  | project decodedCommand=base64_decodestring(substring(encodedCommand, 0, 
   strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand 
) on encodedCommand, decodedCommand 
| extend timestamp = StartTimeUtc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/powershell_newencodedscipts.yaml,2020-10-04,powershell_newencodedscipts.yaml
a1e993de-770a-4434-83e9-9e3b47a6e470,2020-10-04 07:11:15.6720053,,Discovery,,,Windows,Hunting Query,Azure Sentinel Community Github,Enumeration of users and groups,"'Finds attempts to list users or groups using the built-in Windows 'net' tool '
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
FolderPath = """",
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents};
ProcessCreationEvents
| where TimeGenerated >= ago(timeframe)
| where FileName == 'net.exe' and AccountName != """" and ProcessCommandLine !contains '\\'  and ProcessCommandLine !contains '/add' 
| where (ProcessCommandLine contains ' user ' or ProcessCommandLine contains ' group ') and (ProcessCommandLine endswith ' /do' or ProcessCommandLine endswith ' /domain') 
| extend Target = extract(""(?i)[user|group] (\""*[a-zA-Z0-9-_ ]+\""*)"", 1, ProcessCommandLine) | filter Target  != '' 
| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by AccountName, Target, ProcessCommandLine, ComputerName
| project minTimeGenerated, maxTimeGenerated, count_, AccountName, Target, ProcessCommandLine, ComputerName
| sort by AccountName, Target
| extend timestamp = minTimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = ComputerName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/enumeration_user_and_group.yaml,2020-10-04,enumeration_user_and_group.yaml
4eb6d052-9873-4092-b989-66eae780e203,2020-10-04 07:11:15.6720053,,Impact,,,Azure AD,Hunting Query,Azure Sentinel Community Github,Signin Logs with expanded Conditional Access Policies,"'Example query for SigninLogs showing how to break out packed fields.  In this case extending conditional access Policies '
",AzureActiveDirectory,SigninLogs,"
let timeframe = 1d;
SigninLogs 
| where TimeGenerated >= ago(timeframe)
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName), ConditionalAccessPol0Result = tostring(ConditionalAccessPolicies[0].result)
| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName), ConditionalAccessPol1Result = tostring(ConditionalAccessPolicies[1].result)
| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName), ConditionalAccessPol2Result = tostring(ConditionalAccessPolicies[2].result)
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| extend Date = startofday(TimeGenerated), Hour = datetime_part(""Hour"", TimeGenerated)
| summarize count() by Date, Identity, UserDisplayName, UserPrincipalName, IPAddress, ResultType, ResultDescription, StatusCode, StatusDetails, 
ConditionalAccessPol0Name, ConditionalAccessPol0Result, ConditionalAccessPol1Name, ConditionalAccessPol1Result, ConditionalAccessPol2Name, ConditionalAccessPol2Result, 
Location, State, City
| extend timestamp = Date, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
| sort by Date 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SignInLogsWithExpandedPolicies.yaml,2020-10-04,SignInLogsWithExpandedPolicies.yaml
66d494c0-233c-438a-9b1b-5fe839790d38,2020-10-04 07:11:15.6720053,,InitialAccess,,,Azure,Hunting Query,Azure Sentinel Community Github,Check critical ports opened to the entire internet,"'Discover all critical ports from a list having rules like 'Any' for sourceIp, which means that they are opened to everyone. Critial ports should not be opened to everyone, and should be filtered.'
",WAF,AzureDiagnostics,"
//Check critical ports opened to the entire internet
AzureDiagnostics
| where Category == ""NetworkSecurityGroupEvent"" 
| where direction_s == ""In"" 
| where conditions_destinationPortRange_s in (
""22"",""22-22""          //SSH
,""3389"",""3389-3389""   //RDP
,""137"",""137-137""      //NetBIOS
,""138"",""138-138""      //NetBIOS
,""139"",""139-139""      //SMB
,""53"",""53-53""         //DNS
,""3020"",""3020-3020""   //CIFS
,""3306"",""3306-3306""   //MySQL
,""1521"",""1521-1521""   //Oracle Database
,""2483"",""2483-2483""   //Oracle Database
,""5432"",""5432-5432""   //PostgreSQL
,""389"",""389-389""      //LDAP
,""27017"",""27017-27017""//MongoDB
,""20"",""20-20""         //FTP
,""21"",""21-21""         //FTP
,""445"",""445-445""      //Active Directory
,""161"",""161-161""      //SNMP
,""25"",""25-25""         //SMTP
)
 or (conditions_destinationPortRange_s == ""0-65535"" and conditions_sourcePortRange_s == ""0-65535"")
| where priority_d < 65000    //Not to check the Azure defaults
| where conditions_sourceIP_s == ""0.0.0.0/0,0.0.0.0/0"" or conditions_sourceIP_s == ""0.0.0.0/0"" //With rules Any/Any
| where type_s !~ ""block""
| order by TimeGenerated desc
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by OperationName, systemId_g, vnetResourceGuid_g, subnetPrefix_s, macAddress_s, primaryIPv4Address_s, ruleName_s,
 direction_s, priority_d, type_s, conditions_destinationIP_s, conditions_destinationPortRange_s, conditions_sourceIP_s, conditions_sourcePortRange_s, ResourceId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/CriticalPortsOpened.yaml,2020-10-04,CriticalPortsOpened.yaml
d0a3cb7b-375e-402d-9827-adafe0ce386d,2020-10-04 07:11:15.6720053,,Persistence,,,SaaS,Hunting Query,Azure Sentinel Community Github,Web shell file alert enrichment,"'Extracts MDATP Alert for a web shell being placed on the server and then enriches this event with information from W3CIISLog to idnetigy the Attacker that placed the shell'
",AzureMonitor(IIS),W3CIISLog,"let timeWindow = 3d;
let scriptExtensions = dynamic(["".php"", "".jsp"", "".js"", "".aspx"", "".asmx"", "".asax"", "".cfm"", "".shtml""]);  
SecurityAlert  
| where TimeGenerated > ago(timeWindow)  
| where ProviderName =~ ""MDATP"" 
| extend alertData = parse_json(Entities)  
| mvexpand alertData  
// Get only the file type from the JSON, this gives us the file name
| where alertData.Type =~ ""file""  
// This can be expanded to include other script extensions 
| where alertData.Name has_any(scriptExtensions)
| extend FileName = alertData.Name 
| project TimeGenerated, tostring(FileName), alertData.Directory 
| join (  
W3CIISLog  
| where TimeGenerated > ago(timeWindow)  
| where csUriStem has_any(scriptExtensions) 
| extend splitUriStem = split(csUriStem, ""/"")  
| extend FileName = splitUriStem[-1] 
| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by AttackerIP=cIP, AttackerUserAgent=csUserAgent, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName)  
) on FileName 
| project StartTime, EndTime, AttackerIP, AttackerUserAgent, SiteName, ShellLocation
| extend timestamp = StartTime, IPCustomEntity = AttackerIP  
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/WebShellFileAlertEnrich.yaml,2020-10-04,WebShellFileAlertEnrich.yaml
635cba46-c077-4959-a2d9-b7eb6fecb854,2020-10-04 07:11:15.6720053,,Collection,,,Office 365,Hunting Query,Azure Sentinel Community Github,Alerts With This Process,"'Any Alerts that fired on any host with this same process in the range of +-1d'
",MicrosoftCloudAppSecurity,SecurityAlert,"
let GetAllAlertsWithProcess = (suspiciousEventTime:datetime, v_Process:string){
let v_StartTime = suspiciousEventTime-1d;
let v_EndTime = suspiciousEventTime+1d;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
| where ProcessName has v_Process
| extend Extprop = parsejson(ExtendedProperties)
| extend ProcessName = parse_json(ExtendedProperties).[""Suspicious Process""]
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| project TimeGenerated, AlertName, ProcessName, Computer, Account, IpAddress, ExtendedProperties 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
| top 10 by TimeGenerated desc nulls last
};
// change datetime value and <processname> value below
GetAllAlertsWithProcess(datetime('2019-01-18T10:36:07Z'), ""<processname>"")
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsWithProcess.yaml,2020-10-04,AlertsWithProcess.yaml
0b520385-6a16-4e6f-ba89-c320d857695f,2020-10-04 07:11:15.6720053,,Collection,,,Office 365,Hunting Query,Azure Sentinel Community Github,Alerts related to IP,"'Any Alerts that fired related to a given IpAddress during the range of +6h and -3d'
",MicrosoftCloudAppSecurity,SecurityAlert,"
let GetAllAlertsWithIp = (suspiciousEventTime:datetime, v_ipAddress:string){
//-3d and +6h as some alerts fire after accumulation of events
let v_StartTime = suspiciousEventTime-3d;
let v_EndTime = suspiciousEventTime+6h;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
// expand JSON properties
| where ExtendedProperties contains v_ipAddress or Entities contains v_ipAddress
| extend Extprop = parsejson(ExtendedProperties)
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| project StartTimeUtc = StartTime, EndTimeUtc = EndTime, AlertName, Computer, Account, IpAddress, ExtendedProperties, Entities
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and <ipaddress> value below
GetAllAlertsWithIp(datetime('2019-02-05T10:02:51.000'), (""<ipaddress>""))
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsForIP.yaml,2020-10-04,AlertsForIP.yaml
11d808a1-32fe-4618-946a-cfd43523347a,2020-10-04 07:11:15.6720053,,Collection,,,Office 365,Hunting Query,Azure Sentinel Community Github,Alerts related to File,"'Any Alerts that fired related to a given File during the range of +6h and -3d'
",MicrosoftCloudAppSecurity,SecurityAlert,"
let GetAllAlertsWithFile = (suspiciousEventTime:datetime, v_File:string){
let v_StartTime = suspiciousEventTime-1d;
let v_EndTime = suspiciousEventTime+1d;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
| where ExtendedProperties has v_File
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and <filename> value below
GetAllAlertsWithFile(datetime('2019-01-18T10:36:07Z'), ""<filename>"")
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsWithFile.yaml,2020-10-04,AlertsWithFile.yaml
d2e6f31b-add1-4f44-b54d-1975a5605c1d,2020-10-04 07:11:15.6720053,,Persistence,,,SaaS,Hunting Query,Azure Sentinel Community Github,Web shell command alert enrichment,"'Extracts MDATP Alerts that indicate a command was executed by a web shell. Uses time window based querying to idneitfy the potential web shell location on the server, then enriches with Attacker IP and User Agent'
",AzureMonitor(IIS),W3CIISLog,"let scriptExtensions = dynamic(["".php"", "".jsp"", "".js"", "".aspx"", "".asmx"", "".asax"", "".cfm"", "".shtml""]);
let timeRange = 3d; 
let lookupWindow = 1m;  
let lookupBin = lookupWindow / 2.0; 
let distinctIpThreshold = 3; 
let alerts = SecurityAlert  
| where TimeGenerated > ago(timeRange) 
| extend alertData = parse_json(Entities), recordGuid = new_guid(); 
let shellAlerts = alerts 
| where ProviderName =~ ""MDATP""  
| mvexpand alertData 
| where alertData.Type =~ ""file"" and alertData.Name =~ ""w3wp.exe"" 
| distinct SystemAlertId 
| join kind=inner (alerts) on SystemAlertId; 
let alldata = shellAlerts  
| mvexpand alertData 
| extend Type = alertData.Type; 
let filedata = alldata  
| extend id = tostring(alertData.$id)  
| extend ImageName = alertData.Name  
| where Type =~ ""file"" and ImageName != ""w3wp.exe"" 
| extend imagefileref = id;  
let commanddata = alldata  
| extend CommandLine = tostring(alertData.CommandLine)  
| extend creationtime = tostring(alertData.CreationTimeUtc)  
| where Type =~ ""process""  
| where isnotempty(CommandLine)  
| extend imagefileref = tostring(alertData.ImageFile.$ref); 
let hostdata = alldata 
| where Type =~ ""host"" 
| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId 
| distinct HostName, DnsDomain, SystemAlertId; 
let commandKeyedData = filedata 
| join kind=inner (  
commanddata  
) on imagefileref 
| join kind=inner (hostdata) on SystemAlertId 
| project recordGuid, TimeGenerated, ImageName, CommandLine, TimeKey = bin(TimeGenerated, lookupBin), HostName, DnsDomain 
| extend Start = TimeGenerated; 
let baseline = W3CIISLog  
| where TimeGenerated > ago(timeRange) 
| project-rename SourceIP=cIP, PageAccessed=csUriStem 
| summarize dcount(SourceIP) by PageAccessed 
| where dcount_SourceIP <= distinctIpThreshold; 
commandKeyedData 
| join kind=inner ( 
W3CIISLog  
| where TimeGenerated > ago(timeRange) 
| where csUriStem has_any(scriptExtensions)  
| extend splitUriStem = split(csUriStem, ""/"")  
| extend FileName = splitUriStem[-1] | extend firstDir = splitUriStem[-2] | extend TimeKey = range(bin(TimeGenerated-lookupWindow, lookupBin), bin(TimeGenerated, lookupBin),lookupBin)  
| mv-expand TimeKey to typeof(datetime)  
| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Site=sSiteName, HostName=sComputerName, AttackerIP=cIP, AttackerUserAgent=csUserAgent, csUriStem, filename=tostring(FileName), tostring(firstDir), TimeKey 
) on TimeKey, HostName 
| where (StartTime - EndTime) between (0min .. lookupWindow) 
| extend IPCustomEntity = AttackerIP, timestamp = StartTime
| extend attackerP = pack(AttackerIP, AttackerUserAgent)  
| summarize Site=make_set(Site), Attacker=make_bag(attackerP) by csUriStem, filename, tostring(ImageName), CommandLine, HostName, IPCustomEntity, timestamp
| project Site, ShellLocation=csUriStem, ShellName=filename, ParentProcess=ImageName, CommandLine, Attacker, HostName, IPCustomEntity, timestamp
| join kind=inner (baseline) on $left.ShellLocation == $right.PageAccessed",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/WebShellCommandAlertEnrich.yaml,2020-10-04,WebShellCommandAlertEnrich.yaml
61a6edc0-e71a-4084-8f3c-05a58e1b9012,2020-10-04 07:11:15.6720053,,Collection,,,Office 365,Hunting Query,Azure Sentinel Community Github,Alerts On Host,"'Any Alerts that fired on a given host during the range of +6h and -3d'
",MicrosoftCloudAppSecurity,SecurityAlert,"
let GetAllAlertsOnHost = (suspiciousEventTime:datetime, v_Host:string){
//-3d and +6h as some alerts fire after accumulation of events
let v_StartTime = suspiciousEventTime-3d;
let v_EndTime = suspiciousEventTime+6h;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
| where Computer contains v_Host
// expand JSON properties
| extend Extprop = parsejson(ExtendedProperties)
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and hostname value below
GetAllAlertsOnHost(datetime('2019-01-20T10:02:51.000'), toupper(""<hostname>""))
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsOnHost.yaml,2020-10-04,AlertsOnHost.yaml
3a72ba65-00fa-4bbc-b246-be1ff3f73ce1,2020-10-04 07:11:15.6720053,,Collection,,,Office 365,Hunting Query,Azure Sentinel Community Github,Alerts related to account,"'Any Alerts that fired related to a given account during the range of +6h and -3d'
",MicrosoftCloudAppSecurity,SecurityAlert,"
let GetAllAlertsForUser = (suspiciousEventTime:datetime, v_User:string){
//-3d and +6h as some alerts fire after accumulation of events
let v_StartTime = suspiciousEventTime-3d;
let v_EndTime = suspiciousEventTime+6h;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
| where Account contains v_User
// expand JSON properties
| extend Extprop = parsejson(ExtendedProperties)
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and username value below
GetAllAlertsForUser(datetime('2019-01-20T10:02:51.000'), toupper(""<username>""))
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsForUser.yaml,2020-10-04,AlertsForUser.yaml
172a321b-c46b-4508-87c6-e2691c778107,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Hunting Query,Azure Sentinel Community Github,Preview - TI map File entity to VMConnection Event,"'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ""."")[-2])
|  join (
   VMConnection | where TimeGenerated >= ago(dt_lookBack)
   | where isnotempty(ProcessName)
   | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
VMConnection_TimeGenerated, FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml,2020-10-04,FileEntity_VMConnection.yaml
a411fe4c-2ee0-4ee0-b579-55d74b6e7371,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Hunting Query,Azure Sentinel Community Github,Preview - DNS Events that match threat intelligence,"'This sample hunting query demonstrates how to utilize the threat intelligence data with the DNS event logs'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let timeframe = 1d;
DnsEvents
| where TimeGenerated >= ago(timeframe)
| join (ThreatIntelligenceIndicator
  | summarize arg_max(TimeGenerated, *) by IndicatorId
  | summarize by Url) on $left.Name == $right.Url
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count()
by Computer, ClientIP, ThreatIntel_Related_Domain = Name, Url
| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, IPCustomEntity = ClientIP, URLCustomEntity = Url
",,,,,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/Sample-DNSEventsMatchToThreatIntel.yaml,2020-10-04,Sample-DNSEventsMatchToThreatIntel.yaml
689a9475-440b-4e69-8ab1-a5e241685f39,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Hunting Query,Azure Sentinel Community Github,Preview - TI map File entity to WireData Event,"'Identifies a match in WireData Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
|  join (
 WireData | where TimeGenerated >= ago(dt_lookBack)
          | where isnotempty(ProcessName)
          | extend Process =reverse(substring(reverse(ProcessName), 0, indexof(reverse(ProcessName), ""\\"")))
      | extend WireData_TimeGenerated = TimeGenerated
)
on $left.FileName == $right.Process
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
WireData_TimeGenerated, FileName, Computer, Direction, LocalIP, RemoteIP, LocalPortNumber, RemotePortNumber
| extend timestamp = WireData_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = RemoteIP, URLCustomEntity = Url",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_WireData.yaml,2020-10-04,FileEntity_WireData.yaml
18f7de84-de55-4983-aca3-a18bc846b4e0,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Hunting Query,Azure Sentinel Community Github,Preview - TI map File entity to Syslog Event,"'Identifies a match in Syslog Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ""."")[-2])
|  join (
     Syslog | where TimeGenerated >= ago(dt_lookBack)
     | where isnotempty(ProcessName)
     | extend Syslog_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
Syslog_TimeGenerated, FileName, Computer, HostIP, SyslogMessage
| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_Syslog.yaml,2020-10-04,FileEntity_Syslog.yaml
233441b9-cc92-4c9b-87fa-73b855fcd4b8,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Hunting Query,Azure Sentinel Community Github,Preview - TI map File entity to Security Event,"'Identifies a match in Security Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
|  join (
  SecurityEvent | where TimeGenerated >= ago(dt_lookBack)
      | where EventID in (""4688"",""8002"",""4648"",""4673"")
                 | where isnotempty(Process)
      | extend SecurityEvent_TimeGenerated = TimeGenerated, Event = EventID
)
on $left.FileName == $right.Process
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
SecurityEvent_TimeGenerated, FileName, Computer, IpAddress, Account, Event, Activity
| extend timestamp = SecurityEvent_TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress, URLCustomEntity = Url",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_SecurityEvent.yaml,2020-10-04,FileEntity_SecurityEvent.yaml
410da56d-4a63-4d22-b68c-9fb1a303be6d,2020-10-04 07:11:15.6720053,,Impact,,,Office 365,Hunting Query,Azure Sentinel Community Github,Preview - TI map File entity to OfficeActivity Event,"'Identifies a match in OfficeActivity Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'
",ThreatIntelligenceTaxii,ThreatIntelligenceIndicator,"
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
|  join (
OfficeActivity| where TimeGenerated >= ago(dt_lookBack)
      | where isnotempty(SourceFileName)
      | extend OfficeActivity_TimeGenerated = TimeGenerated
)
on $left.FileName == $right.SourceFileName
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
OfficeActivity_TimeGenerated, FileName, UserId, ClientIP, OfficeObjectId
| extend timestamp = OfficeActivity_TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Url",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_OfficeActivity.yaml,2020-10-04,FileEntity_OfficeActivity.yaml
5436f471-b03d-41cb-b333-65891f887c43,2020-10-04 07:11:15.6720053,,,,,,Detection,Azure Sentinel Community Github,GitHub Security Vulnerability in Repository,"'This alerts when there is a new security vulnerability in a GitHub repository.'
",CustomConnector,CustomLogs_CL,"
let timeframe = 14d;
GitHubRepo
| where TimeGenerated > ago(timeframe)
| where Action == ""vulnerabilityAlert""
| project TimeGenerated, DismmisedAt, Reason, vulnerableManifestFilename, Description, Link, PublishedAt, Severity, Summary
",1h,1h,gt,0.0,Informational,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/Security%20Vulnerability%20in%20Repo.yaml,2020-10-04,Security%20Vulnerability%20in%20Repo.yaml
4acd3a04-2fad-4efc-8a4b-51476594cec4,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1483,Domain Generation Algorithms,GCP,Detection,Azure Sentinel Community Github,Possible contact with a domain generated by a DGA,"'Identifies contacts with domains names in CommonSecurityLog that might have been generated by a Domain Generation Algorithm (DGA). DGAs can be used
by malware to generate rendezvous points that are difficult to predict in advance. This detection uses the Alexa Top 1 million domain names to build a model
of what normal domains look like. It uses this to identify domains that may have been randomly generated by an algorithm.
The triThreshold is set to 500 - increase this to report on domains that are less likely to have been randomly generated, decrease it for more likely.
The start time and end time look back over 6 hours of data and the dgaLengthThreshold is set to 8 - meaning domains whose length is 8 or more are reported.'
",PaloAltoNetworks,CommonSecurityLog,"
let triThreshold = 500;
let startTime = 6h;
let dgaLengthThreshold = 8;
// fetch the alexa top 1M domains
let top1M =  (externaldata (Position:int, Domain:string)   [@""http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip""]  with (format=""csv"", zipPattern=""*.csv""));
// extract tri grams that are above our threshold - i.e. are common
let triBaseline =   top1M
| extend Domain = tolower(extract(""([^.]*).{0,7}$"", 1, Domain))
| extend AllTriGrams = array_concat(extract_all(""(...)"", Domain), extract_all(""(...)"", substring(Domain, 1)), extract_all(""(...)"", substring(Domain, 2)))
| mvexpand Trigram=AllTriGrams
| summarize triCount=count() by tostring(Trigram)
| sort by triCount desc
| where triCount > triThreshold
| distinct Trigram;
// collect domain information from common security log, filter and extract the DGA candidate and its trigrams
let allDataSummarized =   CommonSecurityLog
| where TimeGenerated > ago(startTime)
| where isnotempty(DestinationHostName)
| extend Name = tolower(DestinationHostName)
| distinct Name
| where Name has "".""
| where Name !endswith "".home"" and Name !endswith "".lan""
// extract DGA candidate
| extend DGADomain = extract(""([^.]*).{0,7}$"", 1, Name)
| where strlen(DGADomain) > dgaLengthThreshold
// throw out domains with number in them
| where DGADomain matches regex ""^[A-Za-z]{0,}$""
// extract the tri grams from summarized data
| extend AllTriGrams = array_concat(extract_all(""(...)"", DGADomain), extract_all(""(...)"", substring(DGADomain, 1)), extract_all(""(...)"", substring(DGADomain, 2)));
// throw out domains that have repeating tri's and/or >=3 repeating letters
let nonRepeatingTris =  allDataSummarized
| join kind=leftanti
(
    allDataSummarized
    | mvexpand AllTriGrams
    | summarize count() by tostring(AllTriGrams), DGADomain
    | where count_ > 1
    | distinct DGADomain
)
on DGADomain;
// find domains that do not have a common tri in the baseline
let dataWithRareTris =  nonRepeatingTris
| join kind=leftanti
(
    nonRepeatingTris
    | mvexpand AllTriGrams
    | extend Trigram = tostring(AllTriGrams)
    | distinct Trigram, DGADomain
    | join kind=inner
    (
        triBaseline
    )
    on Trigram
    | distinct DGADomain
)
on DGADomain;
dataWithRareTris
// join DGAs back on connection data
| join kind=inner
(
    CommonSecurityLog
    | where TimeGenerated > ago(startTime)
    | where isnotempty(DestinationHostName)
    | extend DestinationHostName = tolower(DestinationHostName)
    | project-rename Name=DestinationHostName, DataSource=DeviceVendor
    | summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Name, SourceIP, DestinationIP, DataSource
)
on Name
| project StartTime, EndTime, Name, DGADomain, SourceIP, DestinationIP, DataSource
| extend timestamp=StartTime, IPCustomEntity=SourceIP",6h,6h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/MultiVendor-PossibleDGAContacts.yaml,2020-10-04,MultiVendor-PossibleDGAContacts.yaml
b8266f81-2715-41a6-9062-42486cbc9c73,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1008,Fallback Channels,Linux,Detection,Azure Sentinel Community Github,Excessive NXDOMAIN DNS Queries,"'This creates an incident in the event a client generates excessive amounts of DNS queries for non-existent domains.'
",InfobloxNIOS,Syslog,"
let timeframe = 1h;
let threshold = 200;
InfobloxNIOS
| where TimeGenerated >= ago(timeframe)
| where ProcessName =~ ""named"" and Log_Type =~ ""client""
| where isnotempty(ResponseCode)
| where ResponseCode =~ ""NXDOMAIN""
| summarize count() by Client_IP, bin(TimeGenerated,15m)
| where count_ > threshold
| join kind=inner (InfobloxNIOS
    | where TimeGenerated >= ago(timeframe)
    | where ProcessName =~ ""named"" and Log_Type =~ ""client""
    | where isnotempty(ResponseCode)
    | where ResponseCode =~ ""NXDOMAIN""
    ) on Client_IP
| extend timestamp = TimeGenerated, IPCustomEntity = Client_IP
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/InfobloxNIOS/ExcessiveNXDOMAINDNSQueries.yaml,2020-10-04,ExcessiveNXDOMAINDNSQueries.yaml
a0907abe-6925-4d90-af2b-c7e89dc201a6,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1008,Fallback Channels,Windows,Detection,Azure Sentinel Community Github,Potential DGA detected,"'Identifies clients with a high NXDomain count which could be indicative of a DGA (cycling through possible C2 domains
where most C2s are not live). Alert is generated when a new IP address is seen (based on not being seen associated with 
NXDomain records in prior 10-day baseline period).'
",DNS,DnsEvents,"
let starttime = 10d;
let endtime = 1d;
let threshold = 100;
let nxDomainDnsEvents = DnsEvents 
| where ResultCode == 3 
| where QueryType in (""A"", ""AAAA"")
| where ipv4_is_match(""127.0.0.1"", ClientIP) == False
| where Name !contains ""/""
| where Name contains ""."";
nxDomainDnsEvents
| where TimeGenerated > ago(endtime)
| extend sld = tostring(split(Name, ""."")[-2])
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), dcount(sld) by ClientIP
| where dcount_sld > threshold
// Filter out previously seen IPs
| join kind=leftanti (nxDomainDnsEvents
    | where TimeGenerated between(ago(starttime)..ago(endtime))
    | extend sld = tostring(split(Name, ""."")[-2])
    | summarize dcount(sld) by ClientIP
    | where dcount_sld > threshold ) on ClientIP
// Pull out sample NXDomain responses for those remaining potentially infected IPs
| join kind = inner (nxDomainDnsEvents | summarize by Name, ClientIP) on ClientIP
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), sampleNXDomainList=make_list(Name, 100)  by ClientIP, dcount_sld
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",1d,10d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DnsEvents/DNS_HighNXDomainCount_detection.yaml,2020-10-04,DNS_HighNXDomainCount_detection.yaml
dde206fc-3f0b-4175-bb5d-42d2aae9d4c9,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1008,Fallback Channels,Azure,Hunting Query,Azure Sentinel Community Github,Cobalt Strike DNS Beaconing,"'Cobalt Strike is a famous Pen Test tool that is used by pen testers as well as attackers alike To compromise an environment. 
The query tries to detect suspicious DNS queries known from Cobalt Strike beacons.
This is based out of sigma rules described here: https://github.com/Neo23x0/sigma/blob/master/rules/network/net_mal_dns_cobaltstrike.yml'
",AzureMonitor(VMInsights),VMConnection,"
let timeframe = 1d;
let badNames = dynamic([""aaa.stage."", ""post.1""]);
(union isfuzzy=true
(DnsEvents
| where TimeGenerated >= ago(timeframe) 
| where Name has_any (badNames)
| extend Domain = Name, SourceIp = ClientIP, RemoteIP = todynamic(IPAddresses)
| mvexpand RemoteIP
| extend RemoteIP = tostring(RemoteIP)),
(VMConnection
| where TimeGenerated >= ago(timeframe)
| where isnotempty(RemoteDnsCanonicalNames) 
| parse RemoteDnsCanonicalNames with * '[""' DNSName '""]' *
| where DNSName has_any (badNames)
| extend Domain = DNSName, RemoteIP = RemoteIp
))
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by Domain, SourceIp, RemoteIP, Computer
| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, IPCustomEntity = RemoteIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/CobaltDNSBeacon.yaml,2020-10-04,CobaltDNSBeacon.yaml
7aaa7675-1580-47d8-a404-039cb7284279,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1008,Fallback Channels,Linux,Hunting Query,Azure Sentinel Community Github,Squid commonly abused TLDs,"'Some top level domains (TLDs) are more commonly associated with malware for a range of reasons - including how easy domains on these TLDs are to obtain. 
Many of these may be undesirable from an enterprise policy perspective. The clientCount column provides an initial insight into how widespread the domain 
usage is across the estate. This query presumes the default squid log format is being used. http://www.squid-cache.org/Doc/config/access_log/'
",Syslog,Syslog,"
let suspicious_tlds = dynamic([ "".click"", "".club"", "".download"",  "".xxx"", "".xyz""]);
let timeframe = 14d;
Syslog
| where TimeGenerated >= ago(timeframe) 
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where TLD in (suspicious_tlds)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), clientCount = dcount(SourceIP) by TLD, User, URL
| order by TLD asc, clientCount desc
| extend timestamp = StartTimeUtc, AccountCustomEntity = User, URLCustomEntity = URL
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/squid_abused_tlds.yaml,2020-10-04,squid_abused_tlds.yaml
543e1ec6-ee5e-4368-aaa6-405f0551ba5c,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1008,Fallback Channels,Windows,Hunting Query,Azure Sentinel Community Github,Potential DGA detected,"'Clients with a high NXDomain count could be indicative of a DGA (cycling through possible C2 domains
where most C2s are not live). Based on quartile precent analysis aglorithm.'
",DNS,DnsEvents,"
let timeframe = 1d;
let excludeTLD = dynamic([""arris"",""ati"",""virtusa"",""unknowndomain"",""onion"",""corp"",""domain"",""local"",""localdomain"",""host"",""home"",""gateway"",""lan"",
""services"",""hub"",""domain.name"",""WirelessAP"",""Digicom-ADSL"",""OpenDNS"",""dlinkrouter"",""Dlink"",""ASUS"",""device"",""router"",""Belkin"",""DHCP"",""Cisco""]);
let nxDomainDnsEvents = DnsEvents
| where ResultCode == 3 
| where QueryType in (""A"", ""AAAA"")
| where ipv4_is_match(""127.0.0.1"", ClientIP) == False
| where Name !contains ""/""
| where Name contains "".""
| extend mytld = tostring(split(Name, '.')[-1])
| where mytld !in~ (excludeTLD)
| extend truncatedDomain = iff((strlen(Name) - indexof(Name, tostring(split(Name, ""."")[-2])) ) >= 7, 
strcat(tostring(split(Name, ""."")[-2]), ""."", tostring(split(Name, ""."")[-1])) , 
strcat(tostring(split(Name, ""."")[-3]), ""."", tostring(split(Name, ""."")[-2]), ""."", tostring(split(Name, ""."")[-1])));
let quartileFunctionForIPThreshold = view (mypercentile:long, startTimeSpan:timespan, endTimeSpan:timespan) {
(nxDomainDnsEvents
| where TimeGenerated between (ago(startTimeSpan)..ago(endTimeSpan))
| summarize domainCount = dcount(truncatedDomain) by ClientIP, bin(TimeGenerated, 1d)
| project SearchList = (domainCount), ClientIP
| summarize qPercentiles = percentiles(SearchList, mypercentile) by ClientIP);
};
let firstQT = quartileFunctionForIPThreshold(25, 7d, 2d) | project-rename percentile_SearchList_25 = qPercentiles;
let thirdQT = quartileFunctionForIPThreshold(75, 7d, 2d) | project-rename percentile_SearchList_75 = qPercentiles;
// The IP threshold could be adjusted for based on the skewness of the IPthreshold distribution per IP - https://wis.kuleuven.be/stat/robust/papers/2008/outlierdetectionskeweddata-revision.pdf
let threshold = (firstQT
| join thirdQT on ClientIP
| extend IPthreshold = percentile_SearchList_75 + (1.5*exp(3)*(percentile_SearchList_75 - percentile_SearchList_25))
| project ClientIP, IPthreshold);
let FilterOnIPThreshold_MainTable = (
nxDomainDnsEvents
| where TimeGenerated > ago(timeframe)
| summarize TotalNXLookups=dcount(truncatedDomain) by ClientIP
| sort by TotalNXLookups desc
| join ['threshold'] on ClientIP
// Comment the line below in order to view results filtered by Global Threshold only. 
| where TotalNXLookups > IPthreshold 
| join kind = leftouter (nxDomainDnsEvents
    | where TimeGenerated > ago(timeframe)
    | summarize domainCount = dcount(Name) by truncatedDomain, ClientIP
    | project SearchList = strcat(truncatedDomain,"" ("",tostring(domainCount),"")""), ClientIP
    ) on ClientIP
| summarize SLDs_DistinctLookups = make_list(SearchList) by ClientIP, TotalNXLookups, IPthreshold
| sort by TotalNXLookups desc);
//
let quartileFunctionForGlobalThreshold = view (mypercentile:long, startTimeSpan:timespan) {
(nxDomainDnsEvents
| where TimeGenerated > ago(startTimeSpan)
| summarize domainCount = dcount(truncatedDomain) by ClientIP
| summarize event_count = count() by domainCount
| summarize perc2 = percentilesw(domainCount, event_count, mypercentile));
};
let firstQ = toscalar(quartileFunctionForGlobalThreshold(25, 1d));
let thirdQ = toscalar(quartileFunctionForGlobalThreshold(75, 1d));
// The Global threshold could be adjusted for based on the skewness of the GlobalThreshold distribution per IP - https://wis.kuleuven.be/stat/robust/papers/2008/outlierdetectionskeweddata-revision.pdf
let GlobalThreshold = toscalar(thirdQ + (1.5*exp(3)*(thirdQ - firstQ)));
let FilterOnGlobalThreshold_MainTable = (
nxDomainDnsEvents
| where TimeGenerated > ago(timeframe)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TotalNXLookups = dcount(truncatedDomain) by ClientIP
| sort by TotalNXLookups desc
// Comment the line below in order to view results filtered by IPThreshold only. 
| where TotalNXLookups > GlobalThreshold 
| join kind = leftouter (nxDomainDnsEvents
    | where TimeGenerated > ago(timeframe)
    | summarize domainCount = dcount(Name) by truncatedDomain, ClientIP
    | project truncatedDomain = strcat(truncatedDomain,"" ("",tostring(domainCount),"")""), ClientIP
    ) on ClientIP
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), SLDs_DistinctLookups = make_list(truncatedDomain), UniqueSLDsCount=count(truncatedDomain) by ClientIP, TotalNXLookups, GlobalThreshold
| sort by TotalNXLookups desc);
FilterOnIPThreshold_MainTable
| join FilterOnGlobalThreshold_MainTable on ClientIP
| project StartTimeUtc, EndTimeUtc, ClientIP, TotalNXLookups, IPthreshold, GlobalThreshold, SLDs_DistinctLookups, UniqueSLDsCount
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",1d,10d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_HighPercentNXDomainCount.yaml,2020-10-04,DNS_HighPercentNXDomainCount.yaml
57e56fc9-417a-4f41-a579-5475aea7b8ce,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1200,Hardware Additions,Linux,Detection,Azure Sentinel Community Github,Potential DHCP Starvation Attack,"'This creates an incident in the event that an excessive amount of DHCPREQUEST have been recieved by a DHCP Server and could potentially be an indication of a DHCP Starvation Attack.'
",InfobloxNIOS,Syslog,"
let timeframe = 1h;
let threshold = 1000;
InfobloxNIOS
| where TimeGenerated >= ago(timeframe)
| where ProcessName =~ ""dhcpd"" and Log_Type =~ ""DHCPREQUEST""
| summarize count() by ServerIP, bin(TimeGenerated,5m)
| where count_ > threshold
| join kind=inner (InfobloxNIOS
    | where ProcessName =~ ""dhcpd"" and Log_Type =~ ""DHCPREQUEST""
    | where TimeGenerated >= ago(timeframe)
    ) on ServerIP
| extend timestamp = TimeGenerated, IPCustomEntity = ServerIP
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/InfobloxNIOS/PotentialDHCPStarvationAttack.yaml,2020-10-04,PotentialDHCPStarvationAttack.yaml
7a58b253-0ef2-4248-b4e5-c350f15a8346,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1090,Proxy,Linux,Detection,Azure Sentinel Community Github,Excessive Denied Proxy Traffic,"'This alert creates an incident when a client generates an excessive amounts of denied proxy traffic.'
",SymantecProxySG,Syslog,"
let timeframe = ago(1h);
let threshold = 100;
SymantecProxySG 
| where TimeGenerated >= timeframe
| where sc_filter_result =~ ""DENIED""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by c_ip, cs_host
| where count_ > threshold
| extend timestamp = StartTime, HostCustomEntity = cs_host, IPCustomEntity = c_ip
",1h,1h,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SymantecProxySG/ExcessiveDeniedProxyTraffic.yaml,2020-10-04,ExcessiveDeniedProxyTraffic.yaml
fb0f4a93-d8ad-4b54-9931-85bdb7550f90,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1090,Proxy,Linux,Detection,Azure Sentinel Community Github,User Accessed Suspicious URL Categories,"'Creates an incident in the event the requested URL accessed by the user has been identified as Suspicious, Phishing, or Hacking.'
",SymantecProxySG,Syslog,"
let timeframe = ago(1h);
SymantecProxySG
| where TimeGenerated >= timeframe
| mv-expand cs_categories
| where cs_categories has_any (""Suspicious"",""phishing"", ""hacking"")
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by sc_filter_result, cs_userdn, c_ip, cs_host, Computer,  tostring(cs_categories)
| extend timestamp = StartTime, AccountCustomEntity = cs_userdn, IPCustomEntity = c_ip, HostCustomEntity = Computer
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SymantecProxySG/UserAccessedSuspiciousURLCategories.yaml,2020-10-04,UserAccessedSuspiciousURLCategories.yaml
90d3f6ec-80fb-48e0-9937-2c70c9df9bad,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1008,Fallback Channels,Linux,Detection,Azure Sentinel Community Github,Squid proxy events for ToR proxies,"'Check for Squid proxy events associated with common ToR proxies. This query presumes the default squid log format is being used.
http://www.squid-cache.org/Doc/config/access_log/'
",Syslog,Syslog,"
let timeframe = 1d;
let DomainList = dynamic([""tor2web.org"", ""tor2web.com"", ""torlink.co"", ""onion.to"", ""onion.ink"", ""onion.cab"", ""onion.nu"", ""onion.link"", 
""onion.it"", ""onion.city"", ""onion.direct"", ""onion.top"", ""onion.casa"", ""onion.plus"", ""onion.rip"", ""onion.dog"", ""tor2web.fi"", 
""tor2web.blutmagie.de"", ""onion.sh"", ""onion.lu"", ""onion.pet"", ""t2w.pw"", ""tor2web.ae.org"", ""tor2web.io"", ""tor2web.xyz"", ""onion.lt"", 
""s1.tor-gateways.de"", ""s2.tor-gateways.de"", ""s3.tor-gateways.de"", ""s4.tor-gateways.de"", ""s5.tor-gateways.de"", ""hiddenservice.net""]);
Syslog
| where TimeGenerated >= ago(timeframe)
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
        SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
        Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
        HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
        User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
        RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
        Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
        Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
        contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where HTTP_Status_Code == ""200""
| where Domain contains "".""
| where Domain has_any (DomainList)
| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/squid_tor_proxies.yaml,2020-10-04,squid_tor_proxies.yaml
3533f74c-9207-4047-96e2-0eb9383be587,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1528,Steal Application Access Token,SaaS,Detection,Azure Sentinel Community Github,Suspicious application consent for offline access,"'This will alert when a user consents to provide a previously-unknown Azure application with offline access via OAuth.
Offline access will provide the Azure App with access to the listed resources without requiring two-factor authentication.
Consent to applications with offline access and read capabilities should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!
For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'
",AzureActiveDirectory,AuditLogs,"let detectionTime = 1d;
let joinLookback = 14d;
AuditLogs
| where TimeGenerated > ago(detectionTime)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Consent to application""
| where TargetResources has ""offline""
| extend AppDisplayName = TargetResources.[0].displayName
| extend AppClientId = tolower(TargetResources.[0].id)
| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv""] with (format=""csv"")))
| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue
| parse ConsentFull with * ""ConsentType: "" GrantConsentType "", Scope: "" GrantScope1 ""]"" *
| where ConsentFull contains ""offline_access"" and ConsentFull contains ""Files.Read"" or ConsentFull contains ""Mail.Read"" or ConsentFull contains ""Notes.Read"" or ConsentFull contains ""ChannelMessage.Read"" or ConsentFull contains ""Chat.Read"" or ConsentFull contains ""TeamsActivity.Read"" or ConsentFull contains ""Group.Read"" or ConsentFull contains ""EWS.AccessAsUser.All"" or ConsentFull contains ""EAS.AccessAsUser.All""
| where GrantConsentType != ""AllPrincipals"" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally
| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)
| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)
| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ ""User-Agent"", AdditionalDetails[0].value, """")
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId
| join kind = leftouter (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add service principal""
| extend AppClientId = tolower(TargetResources[0].id)
| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has ""AddressType"", TargetResources[0].modifiedProperties[1].newValue, """")
| distinct AppClientId, tostring(AppReplyURLs)
)
on AppClientId
| join kind = innerunique (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add OAuth2PermissionGrant"" or OperationName =~ ""Add delegated permission grant""
| extend GrantAuthentication = tostring(TargetResources[0].displayName)
| extend GrantOperation = OperationName
| project GrantAuthentication, GrantOperation, CorrelationId
) on CorrelationId
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull
",1d,14d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/SuspiciousOAuthApp_OfflineAccess.yaml,2020-10-04,SuspiciousOAuthApp_OfflineAccess.yaml
39198934-62a0-4781-8416-a81265c03fd6,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1550,Use Alternate Authentication Material,SaaS,Detection,Azure Sentinel Community Github,Suspicious application consent similar to PwnAuth,"'This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the FireEye PwnAuth toolkit (https://github.com/fireeye/PwnAuth).
The default permissions/scope for the PwnAuth toolkit are user.read, offline_access, mail.readwrite, mail.send, and files.read.all.
Consent to applications with these permissions should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!
For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'
",AzureActiveDirectory,AuditLogs,"let detectionTime = 1d;
let joinLookback = 14d;
AuditLogs
| where TimeGenerated > ago(detectionTime)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Consent to application""
| where TargetResources has ""offline""
| extend AppDisplayName = TargetResources.[0].displayName
| extend AppClientId = tolower(TargetResources.[0].id)
| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv""] with (format=""csv"")))
| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue
| parse ConsentFull with * ""ConsentType: "" GrantConsentType "", Scope: "" GrantScope1 ""]"" *
| where ConsentFull contains ""user.read"" and ConsentFull contains ""offline_access"" and ConsentFull contains ""mail.readwrite"" and ConsentFull contains ""mail.send"" and ConsentFull contains ""files.read.all""
| where GrantConsentType != ""AllPrincipals"" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally
| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)
| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)
| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ ""User-Agent"", AdditionalDetails[0].value, """")
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId
| join kind = leftouter (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add service principal""
| extend AppClientId = tolower(TargetResources[0].id)
| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has ""AddressType"", TargetResources[0].modifiedProperties[1].newValue, """")
| distinct AppClientId, tostring(AppReplyURLs)
)
on AppClientId
| join kind = innerunique (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add OAuth2PermissionGrant"" or OperationName =~ ""Add delegated permission grant""
| extend GrantAuthentication = tostring(TargetResources[0].displayName)
| extend GrantOperation = OperationName
| project GrantAuthentication, GrantOperation, CorrelationId
) on CorrelationId
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull
",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/MaliciousOAuthApp_PwnAuth.yaml,2020-10-04,MaliciousOAuthApp_PwnAuth.yaml
f948a32f-226c-4116-bddd-d95e91d97eb9,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1550,Use Alternate Authentication Material,SaaS,Detection,Azure Sentinel Community Github,Suspicious application consent similar to O365 Attack Toolkit,"'This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the MDSec O365 Attack Toolkit (https://github.com/mdsecactivebreach/o365-attack-toolkit).
The default permissions/scope for the MDSec O365 Attack toolkit are contacts.read, user.read, mail.read, notes.read.all, mailboxsettings.readwrite, and files.readwrite.all.
Consent to applications with these permissions should be rare, especially as the knownApplications list is expanded, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!
For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'
",AzureActiveDirectory,AuditLogs,"let detectionTime = 1d;
let joinLookback = 14d;
AuditLogs
| where TimeGenerated > ago(detectionTime)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Consent to application""
| where TargetResources has ""mailboxsettings""
| extend AppDisplayName = TargetResources.[0].displayName
| extend AppClientId = tolower(TargetResources.[0].id)
| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv""] with (format=""csv"")))
| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue
| parse ConsentFull with * ""ConsentType: "" GrantConsentType "", Scope: "" GrantScope1 ""]"" *
| where ConsentFull contains ""contacts.read"" and ConsentFull contains ""user.read"" and ConsentFull contains ""mail.read"" and ConsentFull contains ""notes.read.all"" and ConsentFull contains ""mailboxsettings.readwrite"" and ConsentFull contains ""Files.ReadWrite.All""
| where GrantConsentType != ""AllPrincipals"" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally
| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)
| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)
| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ ""User-Agent"", AdditionalDetails[0].value, """")
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId
| join kind = leftouter (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add service principal""
| extend AppClientId = tolower(TargetResources[0].id)
| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has ""AddressType"", TargetResources[0].modifiedProperties[1].newValue, """")
| distinct AppClientId, tostring(AppReplyURLs)
)
on AppClientId
| join kind = innerunique (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add OAuth2PermissionGrant"" or OperationName =~ ""Add delegated permission grant""
| extend GrantAuthentication = tostring(TargetResources[0].displayName)
| extend GrantOperation = OperationName
| project GrantAuthentication, GrantOperation, CorrelationId
) on CorrelationId
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull
",1d,14d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/MaliciousOAuthApp_O365AttackToolkit.yaml,2020-10-04,MaliciousOAuthApp_O365AttackToolkit.yaml
83ba3057-9ea3-4759-bf6a-933f2e5bc7ee,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1136,Create Account,SaaS,Detection,Azure Sentinel Community Github,Rare application consent,"'This will alert when the ""Consent to application"" operation occurs by a user that has not done this operation before or rarely does this.
This could indicate that permissions to access the listed Azure App were provided to a malicious actor. 
Consent to application, Add service principal and Add OAuth2PermissionGrant should typically be rare events. 
This may help detect the Oauth2 attack that can be initiated by this publicly available tool - https://github.com/fireeye/PwnAuth
For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'
",AzureActiveDirectory,AuditLogs,"
let current = 1d;
let auditLookback = 7d;
// Setting threshold to 3 as a default, change as needed.  
// Any operation that has been initiated by a user or app more than 3 times in the past 7 days will be excluded
let threshold = 3;
// Gather initial data from lookback period, excluding current, adjust current to more than a single day if no results
let AuditTrail = AuditLogs | where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current)
// 2 other operations that can be part of malicious activity in this situation are 
// ""Add OAuth2PermissionGrant"" and ""Add service principal"", extend the filter below to capture these too
| where OperationName == ""Consent to application""
| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| summarize max(TimeGenerated), OperationCount = count() by OperationName, InitiatedBy, TargetResourceName
// only including operations by initiated by a user or app that is above the threshold so we produce only rare and has not occurred in last 7 days
| where OperationCount > threshold
;
// Gather current period of audit data
let RecentConsent = AuditLogs | where TimeGenerated >= ago(current)
| where OperationName == ""Consent to application""
| extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| parse TargetResources.[0].modifiedProperties with * ""ConsentType: "" ConsentType ""]"" *
| project TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType , CorrelationId, Type;
// Exclude previously seen audit activity for ""Consent to application"" that was seen in the lookback period
// First for rare InitiatedBy
let RareConsentBy = RecentConsent | join kind= leftanti AuditTrail on OperationName, InitiatedBy 
| extend Reason = ""Previously unseen user consenting"";
// Second for rare TargetResourceName
let RareConsentApp = RecentConsent | join kind= leftanti AuditTrail on OperationName, TargetResourceName
| extend Reason = ""Previously unseen app granted consent"";
RareConsentBy | union RareConsentApp
| summarize Reason = makeset(Reason) by TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, CorrelationId, Type
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress",1d,7d,gt,3.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/RareApplicationConsent.yaml,2020-10-04,RareApplicationConsent.yaml
ea107ccc-2b80-410e-96e1-be6607ce293b,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1136,Create Account,SaaS,Hunting Query,Azure Sentinel Community Github,Rare Audit activity initiated by User,"'Compares the current day to the last 14 days of audits to identify new audit activities by 
OperationName, InitiatedByUser, UserPrincipalName, PropertyName, newValue
This can be useful when attempting to track down malicious activity related to additions of 
new users, additions to groups, removal from groups by specific users.'
",AzureActiveDirectory,AuditLogs,"
let current = 1d;
let auditLookback = 14d;
let AuditTrail = AuditLogs 
| where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current) 
| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where isnotempty(InitiatedByUser)
| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| summarize count() by OperationName, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, PropertyName, newValue, TargetResourceName;
let AccountMods = AuditLogs 
| where TimeGenerated >= ago(current)
| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where isnotempty(InitiatedByUser)
| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| where PropertyName !in (""TargetId.UserType"", ""StsRefreshTokensValidFrom"", ""LastDirSyncTime"") and (PropertyName != ""Action Client Name"" and newValue != ""\""DirectorySync\"""") and (PropertyName != ""Included Updated Properties"" and newValue != ""\""LastDirSyncTime\"""")
| extend ModifiedProps = pack(""PropertyName"",PropertyName,""newValue"",newValue, ""Id"", Id, ""CorrelationId"", CorrelationId) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, Category, OperationName, PropertyName, newValue, TargetResourceName;
let RareAudits = AccountMods | join kind= leftanti (
   AuditTrail 
) on OperationName, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, PropertyName, newValue;
RareAudits 
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), make_set(Activity) by InitiatedByUser, InitiatedByIPAddress, OperationName, UserPrincipalName, TargetResourceName
| order by UserPrincipalName asc, StartTimeUtc asc
| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedByUser, HostCustomEntity = TargetResourceName, IPCustomEntity = InitiatedByIPAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/RareAuditActivityByUser.yaml,2020-10-04,RareAuditActivityByUser.yaml
5c799718-b361-4a91-9cb2-0c291e602707,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1136,Create Account,SaaS,Hunting Query,Azure Sentinel Community Github,Rare Audit activity initiated by App,"'Compares the current day to the last 14 days of audits to identify new audit activities by 
OperationName, InitiatedByApp, UserPrincipalName, PropertyName, newValue
This can be useful when attempting to track down malicious activity related to additions of new users,
additions to groups, removal from groups by Azure Apps and automated approvals.'
",AzureActiveDirectory,AuditLogs,"
let current = 1d;
let auditLookback = 14d;
let AuditTrail = AuditLogs 
| where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current) 
| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)
| where isnotempty(InitiatedByApp)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend IpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| where isnotempty(newValue) and newValue != ""\""\""""
| summarize  by OperationName, InitiatedByApp, UserPrincipalName, IpAddress, TargetResourceName, PropertyName, newValue;
let AccountMods = AuditLogs 
| where TimeGenerated >= ago(current)
| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)
| where isnotempty(InitiatedByApp)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend IpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| where isnotempty(newValue) and newValue != ""\""\""""
| where PropertyName != ""TargetId.UserType""
| extend ModifiedProps = pack(""PropertyName"",PropertyName,""newValue"",newValue, ""Id"", Id, ""CorrelationId"", CorrelationId) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByApp, UserPrincipalName, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue;
let RareAudits = AccountMods | join kind= leftanti (
   AuditTrail 
) on OperationName, InitiatedByApp, UserPrincipalName, PropertyName, newValue;
RareAudits
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc),Activity = make_set(Activity) by InitiatedByApp, OperationName, UserPrincipalName, IpAddress, TargetResourceName
| order by UserPrincipalName asc, StartTimeUtc asc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/RareAuditActivityByApp.yaml,2020-10-04,RareAuditActivityByApp.yaml
b09d6e57-c48b-491d-9c2b-ab73018e6534,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,SaaS,Hunting Query,Azure Sentinel Community Github,Consent to Application discovery,"'This query looks at the last 14 days for any ""Consent to application"" operation
occurs by a user or app. This could indicate that permissions to access the listed AzureApp
was provided to a malicious actor. Consent to appliction, Add service principal and 
Add OAuth2PermissionGrant events should be rare. If available, additional context is added 
from the AuditLogs based on CorrleationId from the same account that performed ""Consent to 
application"".
For further information on AuditLogs please see 
https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities
This may help detect the Oauth2 attack that can be initiated by this publicly available tool
https://github.com/fireeye/PwnAuth'
",AzureActiveDirectory,AuditLogs,"
let auditLookback = 14d;
// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 30 days will be exluded
let threshold = 3;
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | extend ModProps = TargetResources.[0].modifiedProperties
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
// Get just the InitiatedBy and CorrleationId so we can look at associated audit activity
// 2 other operations that can be part of malicious activity in this situation are 
// ""Add OAuth2PermissionGrant"" and ""Add service principal"", replace the below if you are interested in those as starting points for OperationName
let HistoricalConsent = auditLogEvents(auditLookback)  
| where OperationName == ""Consent to application""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() 
by Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 30 days
//| where OperationCount > threshold
;
let Correlate = HistoricalConsent 
| summarize by InitiatedBy, CorrelationId;
// 2 other operations that can be part of malicious activity in this situation are 
// ""Add OAuth2PermissionGrant"" and ""Add service principal"", replace the below if you changed the starting OperationName above
let allOtherEvents = auditLogEvents(auditLookback) 
| where OperationName != ""Consent to application"";
// Gather associated activity based on audit activity for ""Consent to application"" and InitiatedBy and CorrleationId
let CorrelatedEvents = Correlate 
| join allOtherEvents on InitiatedBy, CorrelationId
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) 
by Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
;
// Union the results
let Results = union isfuzzy=true HistoricalConsent,CorrelatedEvents;
// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)
Results
| extend newValue = split(newValue, "";"")
| extend PropertyUpdate = pack(PropertyName, newValue, ""Id"", Id)
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) 
by InitiatedBy, IpAddress, TargetResourceName, OperationName, CorrelationId
| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/ConsentToApplicationDiscovery.yaml,2020-10-04,ConsentToApplicationDiscovery.yaml
0454c8d8-d0a6-42a4-8d03-f5b4fdcbd173,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,SaaS,Hunting Query,Azure Sentinel Community Github,Anomalous AAD Account Creation,"'Adversaries may create a cloud account to maintain access to victim systems. With a sufficient level of access, such accounts may be used to establish secondary credentialed access that does not require persistent remote access tools to be deployed on the system. The query below generates an output of all the users performing user creation where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,AuditLogs,"
BehaviorAnalytics
| where ActionType == ""Add user""
| where ActivityInsights has ""True""
| join(
AuditLogs
) on $left.SourceRecordId == $right._ItemId
| mv-expand TargetResources
| extend Target =  iff(tostring(TargetResources.userPrincipalName) has ""#EXT#"",replace(""_"",""@"",tostring(split(TargetResources.userPrincipalName, ""#"")[0])),TargetResources.userPrincipalName),tostring(TargetResources.userPrincipalName)
| extend DisplayName = tostring(UsersInsights.AccountDisplayName),
UserPrincipalName = iff(UserPrincipalName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserPrincipalName),
UserName = iff(UserName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserName)
| sort by TimeGenerated desc	
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [""TargetUser""]=Target,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Account%20Creation.yaml,2020-10-04,Anomalous%20Account%20Creation.yaml
0a87a9f8-2832-466d-ba15-9f092c042ad2,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,Office 365,Hunting Query,Azure Sentinel Community Github,External user from a new organisation added,"'This query identifies external users added to Teams where the user's domain is not one 
previously seen in Teams data.
This query is works with the built-in Teams data connector only.'
",Office365,OfficeActivity,"
// If you have more than 14 days worth of Teams data change this value
let data_date = 14d;
// If you want to look at users further back than the last day change this value
let lookback_date = 1d;
let known_orgs = (
OfficeActivity 
| where TimeGenerated > ago(data_date)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation =~ ""MemberAdded"" or Operation =~ ""TeamsSessionStarted""
// Extract the correct UPN and parse our external organization domain
| extend UPN = iif(Operation == ""MemberAdded"", tostring(Members[0].UPN), UserId)
| extend Organization = tostring(split(split(UPN, ""_"")[1], ""#"")[0])
| where isnotempty(Organization)
| summarize by Organization);
OfficeActivity 
| where TimeGenerated > ago(lookback_date)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation =~ ""MemberAdded""
| extend UPN = tostring(parse_json(Members)[0].UPN)
| extend Organization = tostring(split(split(UPN, ""_"")[1], ""#"")[0])
| where isnotempty(Organization)
| where Organization !in (known_orgs)
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = TimeGenerated, AccountCustomEntity = UPN",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Teams/NewExternalOrg.yaml,2020-10-04,NewExternalOrg.yaml
2b96760d-5307-44f0-94bd-8cf0ec52b1fb,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,,Hunting Query,Azure Sentinel Community Github,New User created on SQL Server,"This hunting query identifies creation of a new user from SQL Server
This query is based on the SQLEvent KQL Parser function (link below) 
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// This query checks for new user account created on SQL Server using the SQLEvent() parser
//
SQLEvent
| where TimeGenerated >= ago(1d)
| where Statement has ""Create Login""
| parse Statement with ""CREATE LOGIN ["" TargetUser:string ""]"" *
| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-New_UserCreated.yaml,2020-10-04,SQL-New_UserCreated.yaml
6fce5baf-bfc2-4c56-a6b7-9c4733fc5a45,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,,Hunting Query,Azure Sentinel Community Github,External user from a new organisation added,"'This query identifies external users added to Teams where the user's domain is not one 
previously seen in Teams data.
This query requires you to have Teams data collected from the O365 Management Activity API
and the Teams parser function enabled.
More details: https://techcommunity.microsoft.com/t5/azure-sentinel/protecting-your-teams-with-azure-sentinel/ba-p/1265761'
",CustomConnector,CustomLogs_CL,"
// If you have more than 14 days worth of Teams data change this value
let data_date = 14d;
// If you want to look at users further back than the last day change this value
let lookback_data = 1d;
let known_orgs = (
TeamsData 
| where CreationTime > ago(data_date)
| where Operation =~ ""MemberAdded"" or Operation =~ ""TeamsSessionStarted""
// Extract the correct UPN and parse our external organization domain
| extend UPN = iif(Operation == ""MemberAdded"", tostring(parse_json(Members)[0].UPN), UserId)
| extend Organization = tostring(split(split(UPN, ""_"")[1], ""#"")[0])
| where isnotempty(Organization)
| summarize by Organization);
TeamsData 
| where CreationTime > ago(lookback_data)
| where Operation =~ ""MemberAdded""
| extend UPN = tostring(parse_json(Members)[0].UPN)
| extend Organization = tostring(split(split(UPN, ""_"")[1], ""#"")[0])
| where isnotempty(Organization)
| where Organization !in (known_orgs)
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = CreationTime, AccountCustomEntity = UPN",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/TeamsLogs/NewExternalOrg.yaml,2020-10-04,NewExternalOrg.yaml
e9cef368-6257-4dab-9a48-4793729c46a2,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,,Hunting Query,Azure Sentinel Community Github,External user added and removed in short timeframe,"'This hunting query identifies external user accounts that are added to a Team and then removed within
one hour.
This query requires you to have Teams data collected from the O365 Management Activity API
and the Teams parser function enabled.
More details: https://techcommunity.microsoft.com/t5/azure-sentinel/protecting-your-teams-with-azure-sentinel/ba-p/1265761'
",CustomConnector,CustomLogs_CL,"
// If you want to look at user added further than 7 days ago adjust this value
let time_ago = 7d;
// If you want to change the timeframe of how quickly accounts need to be added and removed change this value
let time_delta = 1h;
TeamsData 
| where CreationTime > ago(time_ago)
| where Operation =~ ""MemberAdded""
| extend UPN = tostring(parse_json(Members)[0].UPN)
| where UPN contains (""#EXT#"")
| project TimeAdded=CreationTime, Operation, UPN, UserWhoAdded = UserId, TeamName, TeamGuid = tostring(Details.TeamGuid)
| join (
TeamsData 
| where CreationTime > ago(time_ago)
| where Operation =~ ""MemberRemoved""
| extend UPN = tostring(parse_json(Members)[0].UPN)
| where UPN contains (""#EXT#"")
| project TimeDeleted=CreationTime, Operation, UPN, UserWhoDeleted = UserId, TeamName, TeamGuid = tostring(Details.TeamGuid)) on UPN, TeamGuid
| where TimeDeleted < (TimeAdded + time_delta)
| project TimeAdded, TimeDeleted, UPN, UserWhoAdded, UserWhoDeleted, TeamName, TeamGuid
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = TimeAdded, AccountCustomEntity = UPN
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/TeamsLogs/ExternalUserAddedRemoved.yaml,2020-10-04,ExternalUserAddedRemoved.yaml
b8508e24-47a6-4f8e-9066-3cc937197e7f,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,,Hunting Query,Azure Sentinel Community Github,GitHub Inactive or New Account Access or Usage,"'This hunting query identifies Accounts that are new or inactive and have accessed or used GitHub that may be a sign of compromise.'
",CustomConnector,CustomLogs_CL,"
let LearningPeriod = 7d;
let RunTime = 1h;
let StartTime = 1h;
let EndRunTime = StartTime - RunTime;
let EndLearningTime = StartTime + LearningPeriod;
let GitHubActorLogin = (GitHubAudit
| where Actor != """");
let GitHubUser = (GitHubAudit
| where ImpactedUser != """");
let GitHubNewActorLogin = (GitHubActorLogin
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))
| summarize makeset(Actor)
| extend Dummy = 1
| join kind=innerunique (
  GitHubActorLogin
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))
  | distinct Actor
  | extend Dummy = 1
) on Dummy
| project-away Dummy
| where set_Actor  !contains Actor);
let GitHubNewUser = ( GitHubUser
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))
| summarize makeset(ImpactedUser)
| extend Dummy = 1
| join kind=innerunique (
  GitHubUser
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))
  | distinct ImpactedUser
  | extend Dummy = 1
) on Dummy
| project-away Dummy
| where set_ImpactedUser !contains ImpactedUser);
union GitHubNewActorLogin, GitHubNewUser
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Inactive%20or%20New%20Account%20Usage.yaml,2020-10-04,Inactive%20or%20New%20Account%20Usage.yaml
b2c15736-b9eb-4dae-8b02-3016b6a45a32,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1098,Account Manipulation,SaaS,Detection,Azure Sentinel Community Github,Suspicious granting of permissions to an account,"'Identifies IPs from which users grant access to other users on azure resources and alerts when a previously unseen source IP address is used.'
",AzureActivity,AzureActivity,"
let starttime = 14d;
let endtime = 1d;
// The number of operations below which an IP address is considered an unusual source of role assignment operations
let alertOperationThreshold = 5;
let createRoleAssignmentActivity = AzureActivity
| where OperationName == ""Create role assignment"";
createRoleAssignmentActivity 
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| summarize count() by CallerIpAddress, Caller
| where count_ >= alertOperationThreshold
| join kind = rightanti ( 
createRoleAssignmentActivity
| where TimeGenerated > ago(endtime)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), 
OperationIds = makelist(OperationId), CorrelationId = makelist(CorrelationId), ActivityCountByCallerIPAddress = count()  
by ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup
) on CallerIpAddress, Caller
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/Granting_Permissions_To_Account_detection.yaml,2020-10-04,Granting_Permissions_To_Account_detection.yaml
65c78944-930b-4cae-bd79-c3664ae30ba7,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1098,Account Manipulation,AWS,Detection,Azure Sentinel Community Github,MFA disabled for a user,"'Multi-Factor Authentication (MFA) helps prevent credential compromise. This alert identifies when an attempt has been made to diable MFA for a user '
",AWS,AWSCloudTrail,"
let timeframe = 1d;
(union isfuzzy=true
(AuditLogs 
| where TimeGenerated >= ago(timeframe) 
| where OperationName =~ ""Disable Strong Authentication""
| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) 
| extend InitiatedByUser = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
 tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
| extend Targetprop = todynamic(TargetResources)
| extend TargetUser = tostring(Targetprop[0].userPrincipalName) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by User = TargetUser, InitiatedByUser , Operation = OperationName , CorrelationId, IPAddress, Category, Source = SourceSystem , AADTenantId, Type
),
(AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where EventName in~ (""DeactivateMFADevice"", ""DeleteVirtualMFADevice"") 
| extend InstanceProfileName = tostring(parse_json(RequestParameters).InstanceProfileName)
| extend TargetUser = tostring(parse_json(RequestParameters).userName)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by User = TargetUser, Source = EventSource , Operation = EventName , TenantorInstance_Detail = InstanceProfileName, IPAddress = SourceIpAddress
)
)
| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = IPAddress",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MFADisable.yaml,2020-10-04,MFADisable.yaml
62085097-d113-459f-9ea7-30216f2ee6af,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,Windows,Detection,Azure Sentinel Community Github,AD user created password not set within 24-48 hours,"'Identifies whenever a new account is created with a default password and password is not changed within 24-48 hours.
Simple version, can be more precise with Windowing, but not necessary if run as an alert on a daily basis.
Effectively, there is an event 4722 indicating a user enabled and no event 4723 indicating a password was changed within in that day or the next day.'
",SecurityEvents,SecurityEvent,"
let starttime = 2d;
let endtime = 1d;
SecurityEvent
// include yesterday and not today, so we can confirm a match occurs within the next day
| where TimeGenerated >= startofday(ago(starttime)) and TimeGenerated <= startofday(ago(endtime))  
// 4722: User Account Enabled
| where EventID == 4722 
// Removing Machine Accounts
| where TargetUserName !endswith ""$"" 
| join kind= leftanti (
  SecurityEvent
  //verify over the last 2 days
  | where TimeGenerated >= startofday(ago(starttime))
  // Attempt made to change password
  | where EventID == 4723
  // Removing Machine Accounts
  | where TargetUserName !endswith ""$""
) on TargetUserName, TargetDomainName
| project StartTimeUtc = TimeGenerated, EventID, Computer, TargetUserName, TargetDomainName, SubjectUserName
| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer
",1d,2d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/password_not_set.yaml,2020-10-04,password_not_set.yaml
6c360107-f3ee-4b91-9f43-f4cfd90441cf,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,Windows,Detection,Azure Sentinel Community Github,AD account with don't expire password - disabled,"'Identifies whenever a user account has the setting ""Password Never Expires"" in the user account properties selected.
This is indicated in Security event 4738 in the EventData item labeled UserAccountControl with an included value of %%2089 
%%2089 resolves to ""Don't Expire Password - Disabled"".'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4738
// 2089 value indicates the Don't Expire Password value has been set
| where UserAccountControl has ""%%2089"" 
| extend Value_2089 = iff(UserAccountControl has ""%%2089"",""'Don't Expire Password' - Disabled"", ""Not Changed"")
// 2050 indicates that the Password Not Required value is NOT set, this often shows up at the same time as a 2089 and is the recommended value.  This value may not be in the event. 
| extend Value_2050 = iff(UserAccountControl has ""%%2050"",""'Password Not Required' - Disabled"", ""Not Changed"")
// If value %%2082 is present in the 4738 event, this indicates the account has been configured to logon WITHOUT a password. Generally you should only see this value when an account is created and only in Event 4720: Account Creation Event.  
| extend Value_2082 = iff(UserAccountControl has ""%%2082"",""'Password Not Required' - Enabled"", ""Not Changed"")
| project StartTimeUtc = TimeGenerated, EventID, Computer, TargetUserName, TargetDomainName, AccountType, UserAccountControl, Value_2089, Value_2050, Value_2082
| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/password_never_expires.yaml,2020-10-04,password_never_expires.yaml
c7bfadd4-34a6-4fa5-82f8-3691a32261e8,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,AWS,Detection,Azure Sentinel Community Github,Changes to AWS Elastic Load Balancer security groups,"'Elastic Load Balancer distributes incoming traffic across multiple instances in multiple availability Zones. This increases the fault tolerance of your applications. 
 Unwanted changes to Elastic Load Balancer specific security groups could open your environment to attack and  hence needs monitoring.
 More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255 
 and https://aws.amazon.com/elasticloadbalancing/.'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
let EventNameList = dynamic([""ApplySecurityGroupsToLoadBalancer"", ""SetSecurityGroups""]);
AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where EventName in~ (EventNameList)
| extend User = iif(isnotempty(UserIdentityUserName), UserIdentityUserName, SessionIssuerUserName)
| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) 
by EventSource, EventName, UserIdentityType, User, SourceIpAddress, UserAgent, SessionMfaAuthenticated, AWSRegion,
AdditionalEventData, UserIdentityAccountId, UserIdentityPrincipalid, ResponseElements
| extend timestamp = StartTimeUtc, AccountCustomEntity = User , IPCustomEntity = SourceIpAddress",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_LoadBalancerSecGroupChange.yaml,2020-10-04,AWS_LoadBalancerSecGroupChange.yaml
826bb2f8-7894-4785-9a6b-a8a855d8366f,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1098,Account Manipulation,AWS,Detection,Azure Sentinel Community Github,"Full Admin policy created and then attached to Roles, Users or Groups","'Identity and Access Management (IAM) securely manages access to AWS services and resources. 
Identifies when a policy is created with Full Administrators Access (Allow-Action:*,Resource:*). 
This policy can be attached to role,user or group and may be used by an adversary to escalate a normal user privileges to an adminsitrative level.
AWS IAM Policy Grammar: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html
and AWS IAM API at https://docs.aws.amazon.com/IAM/latest/APIReference/API_Operations.html'
",AWS,AWSCloudTrail,"let EventNameList = dynamic([""AttachUserPolicy"",""AttachRolePolicy"",""AttachGroupPolicy""]);
let createPolicy = ""CreatePolicy"";
let timeframe = 1d;
let lookback = 14d;
// Creating Master table with all the events to use with materialize for better performance
let EventInfo = AWSCloudTrail
| where TimeGenerated >= ago(lookback)
| where EventName in (EventNameList) or EventName == createPolicy;
//Checking for Policy creation event with Full Admin Privileges since lookback period.
let FullAdminPolicyEvents =  materialize(  EventInfo
| where TimeGenerated >= ago(lookback)
| where EventName == createPolicy
| extend PolicyName = tostring(parse_json(RequestParameters).policyName)
| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement
| mvexpand Statement
| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource)
| mvexpand Action
| extend Action = tostring(Action)
| where Effect =~ ""Allow"" and Action == ""*"" and Resource == ""*""
| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, UserIdentityUserName
| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))
| project-rename StartTime = TimeGenerated  );
let PolicyAttach = materialize(  EventInfo
| where TimeGenerated >= ago(timeframe)
| where EventName in (EventNameList)
| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),""/"")[1])
| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, UserIdentityUserName = iff(isnotempty(UserIdentityUserName),   UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1])), PolicyName
| extend AttachEvent = pack(""StartTime"", StartTime, ""EndTime"", EndTime, ""EventName"", EventName, ""UserIdentityType"",   UserIdentityType, ""UserIdentityArn"", UserIdentityArn, ""SourceIpAddress"", SourceIpAddress, ""UserIdentityUserName"", UserIdentityUserName)
| project EventSource, PolicyName, AttachEvent, AttachEventCount
);
// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.
// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.
FullAdminPolicyEvents
| join kind=leftouter
(
    PolicyAttach
)
on PolicyName
| project-away PolicyName1
| extend timestamp = StartTime, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_FullAdminPolicyAttachedToRolesUsersGroups.yaml,2020-10-04,AWS_FullAdminPolicyAttachedToRolesUsersGroups.yaml
4f19d4e3-ec5f-4abc-9e61-819eb131758c,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,AWS,Detection,Azure Sentinel Community Github,Changes to AWS Security Group ingress and egress settings,"'A Security Group acts as a virtual firewall of an instance to control inbound and outbound traffic. 
 Hence, ingress and egress settings changes to AWS Security Group should be monitored as these can expose the enviornment to new attack vectors.
More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255.'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
let EventNameList = dynamic([ ""AuthorizeSecurityGroupEgress"", ""AuthorizeSecurityGroupIngress"", ""RevokeSecurityGroupEgress"", ""RevokeSecurityGroupIngress""]);
AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where EventName in~ (EventNameList)
| extend User = iif(isnotempty(UserIdentityUserName), UserIdentityUserName, SessionIssuerUserName)
| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) 
by EventSource, EventName, UserIdentityType, User, SourceIpAddress, UserAgent, SessionMfaAuthenticated, AWSRegion, 
AdditionalEventData, UserIdentityAccountId, UserIdentityPrincipalid, ResponseElements
| extend timestamp = StartTimeUtc, AccountCustomEntity = User , IPCustomEntity = SourceIpAddress
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_IngressEgressSecurityGroupChange.yaml,2020-10-04,AWS_IngressEgressSecurityGroupChange.yaml
8c2ef238-67a0-497d-b1dd-5c8a0f533e25,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,AWS,Detection,Azure Sentinel Community Github,Changes to internet facing AWS RDS Database instances,"'Amazon Relational Database Service (RDS) is scalable relational database in the cloud. 
If your organization have one or more AWS RDS Databases running, monitoring changes to especially internet facing AWS RDS (Relational Database Service) 
Once alerts triggered, validate if changes observed are authorized and adhere to change control policy. 
More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255
and RDS API Reference Docs: https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Operations.html'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
let EventNameList = dynamic([""AuthorizeDBSecurityGroupIngress"",""CreateDBSecurityGroup"",""DeleteDBSecurityGroup"",""RevokeDBSecurityGroupIngress""]);
AWSCloudTrail
| where TimeGenerated > ago(timeframe)
| where EventName in~ (EventNameList)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ChangeToRDSDatabase.yaml,2020-10-04,AWS_ChangeToRDSDatabase.yaml
df205daf-fcf3-4b95-a7fd-043b70f6c209,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1098,Account Manipulation,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps Pull Request Policy Bypassing,"'Looks for users bypassing Update Policies in repos'
",AzureMonitor,AzureDevOpsAuditing,"
let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where OperationName == 'Git.RefUpdatePoliciesBypassed'
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/AzDOPrPolicyBypassers.yaml,2020-10-04,AzDOPrPolicyBypassers.yaml
860cda84-765b-4273-af44-958b7cca85f7,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1098,Account Manipulation,SaaS,Hunting Query,Azure Sentinel Community Github,Granting permissions to account,"'Shows the most prevalent users who grant access to others on azure resources and for each account 
their common source ip address. If an operation is not from this IP address it may be worthy of investigation.'
",AzureActivity,AzureActivity,"
let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Create role assignment""
| where ActivityStatus == ""Succeeded"" 
| project Caller, CallerIpAddress
| evaluate basket()
| extend AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Granting_Permissions_to_Account.yaml,2020-10-04,Granting_Permissions_to_Account.yaml
5aa5083c-1de6-42bb-a128-2ec2aba1de39,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,SaaS,Hunting Query,Azure Sentinel Community Github,Anomalous Role Assignment,"'Adversaries may manipulate accounts to maintain access to victim systems. These actions include adding new accounts to high privilleged groups. Dragonfly 2.0, for example, added newly created accounts to the administrators group to maintain elevated access.  The query below generates an output of all high Blast Radius users performing Add member to priveleged role, or where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,AuditLogs,"
let critical = dynamic(['9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3','c4e39bd9-1100-46d3-8c65-fb160da0071f','158c047a-c907-4556-b7ef-446551a6b5f7','62e90394-69f5-4237-9190-012177145e10','d29b2b05-8046-44ba-8758-1e26182fcf32','729827e3-9c14-49f7-bb1b-9608f156bbb8','966707d0-3269-4727-9be2-8c3a10f19b9d','194ae4cb-b126-40b2-bd5b-6091b380977d','fe930be7-5e62-47db-91af-98c3a49a38b1']);
let high = dynamic(['cf1c38e5-3621-4004-a7cb-879624dced7c','7495fdc4-34c4-4d15-a289-98788ce399fd','aaf43236-0c0d-4d5f-883a-6955382ac081','3edaf663-341e-4475-9f94-5c398ef6c070','7698a772-787b-4ac8-901f-60d6b08affd2','b1be1c3e-b65d-4f19-8427-f6fa0d97feb9','9f06204d-73c1-4d4c-880a-6edb90606fd8','29232cdf-9323-42fd-ade2-1d097af3e4de','be2f45a1-457d-42af-a067-6ec1fa63bc45','7be44c8a-adaf-4e2a-84d6-ab2649e08a13','e8611ab8-c189-46e8-94e1-60213ab1f814']);
AuditLogs
| where OperationName == ""Add member to role""
| mv-expand TargetResources
| extend RoleId = tostring(TargetResources.modifiedProperties[0].newValue)
| extend RoleName = tostring(TargetResources.modifiedProperties[1].newValue)
| where RoleId in (critical,high)
| extend TargetId = tostring(TargetResources.id)
| extend Target = tostring(TargetResources.userPrincipalName)
| where isnotempty(RoleId) or isnotempty(RoleName)
| join kind=inner ( BehaviorAnalytics
) on $left._ItemId == $right.SourceRecordId
| where UsersInsights.BlasrRadius == ""High"" or ActivityInsights has ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [""TargetUser""]=Target,RoleName,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Role%20Assignment.yaml,2020-10-04,Anomalous%20Role%20Assignment.yaml
8741deeb-332e-4061-8873-5086040920e3,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,SaaS,Hunting Query,Azure Sentinel Community Github,Anomalous AAD Account Manipulation,"'Adversaries may manipulate accounts to maintain access to victim systems. These actions include adding new accounts to high privilleged groups. Dragonfly 2.0, for example, added newly created accounts to the administrators group to maintain elevated access. The query below generates an output of all high Blast Radius users performing ""Update user"" (name change) to priveleged role, or where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,AuditLogs,"
//Critical Roles: can impersonate  any user or app, can update passwords for users or service principals (if the role can let a user update passwords for privileged users, if an attacker compromises this user then attacker can update passwords for privileged users hence gaining more privileges so users with this role are equally critical)
//High Roles: Administrators that can manage all aspects or permissions of important products but can’t update credentials and impersonate another user/app
let critical = dynamic(['9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3','c4e39bd9-1100-46d3-8c65-fb160da0071f','158c047a-c907-4556-b7ef-446551a6b5f7','62e90394-69f5-4237-9190-012177145e10','d29b2b05-8046-44ba-8758-1e26182fcf32','729827e3-9c14-49f7-bb1b-9608f156bbb8','966707d0-3269-4727-9be2-8c3a10f19b9d','194ae4cb-b126-40b2-bd5b-6091b380977d','fe930be7-5e62-47db-91af-98c3a49a38b1']);
let high = dynamic(['cf1c38e5-3621-4004-a7cb-879624dced7c','7495fdc4-34c4-4d15-a289-98788ce399fd','aaf43236-0c0d-4d5f-883a-6955382ac081','3edaf663-341e-4475-9f94-5c398ef6c070','7698a772-787b-4ac8-901f-60d6b08affd2','b1be1c3e-b65d-4f19-8427-f6fa0d97feb9','9f06204d-73c1-4d4c-880a-6edb90606fd8','29232cdf-9323-42fd-ade2-1d097af3e4de','be2f45a1-457d-42af-a067-6ec1fa63bc45','7be44c8a-adaf-4e2a-84d6-ab2649e08a13','e8611ab8-c189-46e8-94e1-60213ab1f814']);
AuditLogs
| where OperationName == ""Update user""
| mv-expand AdditionalDetails
| mv-expand TargetResources
| where AdditionalDetails.key == ""UserPrincipalName""
| mv-expand TargetResources
| extend RoleId = tostring(TargetResources.modifiedProperties[0].newValue)
| extend RoleName = tostring(TargetResources.modifiedProperties[1].newValue)
| where RoleId in (critical,high)
| where isnotempty(RoleId) or isnotempty(RoleName)
| extend TargetId = tostring(TargetResources.id)
| extend Target =  iff(tostring(TargetResources.userPrincipalName) has ""#EXT#"",replace(""_"",""@"",tostring(split(TargetResources.userPrincipalName, ""#"")[0])),TargetResources.userPrincipalName),tostring(TargetResources.userPrincipalName)
| join kind=inner ( BehaviorAnalytics
) on $left._ItemId == $right.SourceRecordId
| where UsersInsights.BlastRadius == ""High"" or ActivityInsights has ""True""
|  extend UserPrincipalName = iff(UserPrincipalName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserPrincipalName),
UserName = iff(UserName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserName) 
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [""TargetUser""]=Target,RoleName,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20AAD%20Account%20Manipulation.yaml,2020-10-04,Anomalous%20AAD%20Account%20Manipulation.yaml
0db42a94-e7c8-4bf1-99a7-1a2fb4158212,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1098,Account Manipulation,AWS,Hunting Query,Azure Sentinel Community Github,Privileged role attached to Instance,"'Identity and Access Management (IAM) securely manages access to AWS services and resources. 
Identifies when a Privileged role is attached to an existing instance or new instance at deployment. This instance may be used by an adversary to escalate a normal user privileges to an adminsitrative level.
and AWS API AddRoleToInstanceProfile at https://docs.aws.amazon.com/IAM/latest/APIReference/API_AddRoleToInstanceProfile.html'
",AWS,AWSCloudTrail,"
let EventNameList = dynamic([""AttachUserPolicy"",""AttachRolePolicy"",""AttachGroupPolicy""]);
let PolicyArnList = dynamic([""arn:aws:iam::aws:policy/AdministratorAccess"",""arn:aws:iam::aws:policy/DatabaseAdministrator"",""arn:aws:iam::aws:policy/NetworkAdministrator"",""arn:aws:iam::aws:policy/SystemAdministrator"",""arn:aws:iam::aws:policy/AmazonS3FullAccess""]);
let timeframe = 1d;
let lookback = 14d;
//Creating a temp table of events creating privileged role or users which can later be correlated with suspicious operations.
let PrivilegedRoleorUsers = AWSCloudTrail
| where TimeGenerated >= ago(lookback) 
| where EventName in (EventNameList)
| extend PolicyArn = tostring(parse_json(RequestParameters).policyArn), RoleName = tostring(parse_json(RequestParameters).roleName)
| where PolicyArn in (PolicyArnList)
| distinct PolicyArn, UserIdentityType, UserIdentityUserName,RoleName;
// Joining the list of identities having Privileged roles with the API call AddRoleToInstanceProfile to indentify the instances which may be used by adversaries as pivot point for privilege escalation.
PrivilegedRoleorUsers
| join (
AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where EventName in (""AddRoleToInstanceProfile"") 
| extend InstanceProfileName = tostring(parse_json(RequestParameters).InstanceProfileName), RoleName = tostring(parse_json(RequestParameters).roleName)
| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventSource, EventName, UserIdentityType , UserIdentityArn , UserIdentityUserName, SourceIpAddress, RoleName
) on RoleName 
| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIpAddress, AccountCustomEntity = RoleName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_PrivilegedRoleAttachedToInstance.yaml,2020-10-04,AWS_PrivilegedRoleAttachedToInstance.yaml
e1a91db8-f2b3-4531-bff6-da133d4f4f1a,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1098,Account Manipulation,AWS,Hunting Query,Azure Sentinel Community Github,IAM Privilege Escalation by Instance Profile attachment,"'An instance profile is a container for an IAM role that you can use to pass role information to an EC2 instance when the instance start.
Identifies when existing role is removed and new/existing high privileged role is added to instance profile. 
Any instance with this instance profile attached is able to perform privileged operations.
AWS Instance Profile: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2_instance-profiles.html
and CloudGoat - IAM PrivilegeEscalation by Attachment: https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/scenarios/iam_privesc_by_attachment'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
// Creating separate table for RemoveRoleToInstanceProfile
let RemoveRole=AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where  EventName in~ (""RemoveRoleFromInstanceProfile"") and isempty(ErrorMessage)
| extend RoleRemoved = tostring(parse_json(RequestParameters).roleName), InstanceProfileName = tostring(parse_json(RequestParameters).instanceProfileName), TimeRemoved=TimeGenerated
| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))
| summarize RoleRemovedCount= dcount(TimeRemoved) by TimeRemoved, EventName, EventTypeName, UserIdentityArn, UserIdentityUserName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
SourceIpAddress, AWSRegion, EventSource, RoleRemoved, InstanceProfileName;
// Creating separate table for AddRoleToInstanceProfile
let AddRole=AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where  EventName in~ (""AddRoleToInstanceProfile"") and isempty(ErrorMessage)
| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))
| extend RoleAdded = tostring(parse_json(RequestParameters).roleName), InstanceProfileName = tostring(parse_json(RequestParameters).instanceProfileName), TimeAdded=TimeGenerated
| summarize RoleAddedCount= dcount(TimeAdded) by TimeAdded, EventName, EventTypeName, UserIdentityArn, UserIdentityUserName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
SourceIpAddress, AWSRegion, EventSource, RoleAdded, InstanceProfileName;
//Joining both operations from the same source IP, user and instance profile name
RemoveRole
| join kind= inner (
   AddRole 
) on AWSRegion,SourceIpAddress, InstanceProfileName, UserIdentityUserName
| where TimeAdded  > TimeRemoved // Checking if RoleAdd operation was performed after removal
| summarize TotalCount=count() by TimeAdded, TimeRemoved, RoleAdded, RoleRemoved, UserIdentityUserName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,
SourceIpAddress, AWSRegion, EventSource, RoleRemovedCount, RoleAddedCount
| extend timestamp = iff(TimeAdded > TimeRemoved,TimeAdded, TimeRemoved), IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_IAM_PrivilegeEscalationbyAttachment.yaml,2020-10-04,AWS_IAM_PrivilegeEscalationbyAttachment.yaml
4d8de9e6-263e-4845-8618-cd23a4f58b70,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,,Detection,Azure Sentinel Community Github,Azure DevOps Pull Request Policy Bypassing - Historic Allowlist,"'This detection builds a Allowlist of historic PR policy bypasses and compares to recent history, flagging a non manually allowlisted, non historic pull request bypass.'
",CustomConnector,CustomLogs_CL,"
let starttime = 14d;
let endtime = 3h;
// Add full UPN (user@domain.com) to Authorized Bypassers to ignore policy bypasses by certain authorized users
let AuthorizedBypassers = dynamic(['foo@baz.com', 'test@foo.com']);
let historicBypassers = AzureDevOpsAuditing
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| where OperationName == 'Git.RefUpdatePoliciesBypassed'
| distinct ActorUPN;
AzureDevOpsAuditing
| where TimeGenerated >= ago(endtime)
| where OperationName == 'Git.RefUpdatePoliciesBypassed'
| where ActorUPN !in (historicBypassers) and ActorUPN !in (AuthorizedBypassers)
| parse ScopeDisplayName with OrganizationName '(Organization)'
| project TimeGenerated, ActorUPN, IpAddress, UserAgent, OrganizationName, ProjectName, RepoName = Data.RepoName, AlertDetails = Details, Branch = Data.Name, 
  BypassReason = Data.BypassReason, PRLink = strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_git/', Data.RepoName, '/pullrequest/', Data.PullRequestId)
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress",3h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOHistoricPrPolicyBypassing.yaml,2020-10-04,AzDOHistoricPrPolicyBypassing.yaml
89e6adbd-612c-4fbe-bc3d-32f81baf3b6c,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,,Detection,Azure Sentinel Community Github,Azure DevOps Administrator Group Monitoring,"'This detection monitors for additions to project or project collection administration groups in an Azure DevOps Organization.'
",CustomConnector,CustomLogs_CL,"
let timeframe = 4h;
// Change to true to monitor for Project Administrator adds to *any* project
let MonitorAllProjects = false;
// If MonitorAllProjects is false, trigger only on Project Administrator add for the following projects
let ProjectsToMonitor = dynamic(['<project_X>','<project_Y>']);
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where Area == ""Group"" and OperationName == ""Group.UpdateGroupMembership.Add""
| where Details has 'Administrators'
| where Details has ""was added as a member of group"" and (Details endswith '\\Project Administrators' or Details endswith '\\Project Collection Administrators')
| parse Details with AddedIdentity ' was added as a member of group [' EntityName ']\\' GroupName
| extend Level = iif(GroupName == 'Project Collection Administrators', 'Organization', 'Project'), AddedIdentityId = Data.MemberId
| extend Severity = iif(Level == 'Organization', 'High', 'Medium'), AlertDetails = strcat('At ', TimeGenerated, ' UTC ', ActorUPN, '/', ActorDisplayName, ' added ', AddedIdentity, ' to the ', EntityName, ' ', Level)
| where MonitorAllProjects == true or EntityName in (ProjectsToMonitor) or Level == 'Organization'
| project TimeGenerated, Severity, Adder = ActorUPN, AddedIdentity, AddedIdentityId, AlertDetails, Level, EntityName, GroupName, ActorAuthType = AuthenticationMechanism, 
  ActorIpAddress = IpAddress, ActorUserAgent = UserAgent, RawDetails = Details
| extend timestamp = TimeGenerated, AccountCustomEntity = Adder, IPCustomEntity = ActorIpAddress",4h,4h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOAdminGroupAdditions.yaml,2020-10-04,AzDOAdminGroupAdditions.yaml
8e267e91-6bda-4b3c-bf68-9f5cbdd103a3,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,,Detection,Azure Sentinel Community Github,External User Access Enabled,"'This alerts when the account setting is changed to allow either external domain access or anonymous access to meetings.'
",CustomConnector,CustomLogs_CL,"
let timeframe = 1d;
ZoomLogs 
| where TimeGenerated >= ago(timeframe)
| where Event =~ ""account.settings_updated"" 
| extend EnforceLogin = columnifexists(""payload_object_settings_schedule_meeting_enfore_login_b"", """") 
| extend EnforceLoginDomain = columnifexists(""payload_object_settings_schedule_meeting_enfore_login_b"", """") 
| extend GuestAlerts = columnifexists(""payload_object_settings_in_meeting_alert_guest_join_b"", """") 
| where EnforceLogin == 'false' or EnforceLoginDomain == 'false' or GuestAlerts == 'false' 
| extend SettingChanged = case(EnforceLogin == 'false' and EnforceLoginDomain == 'false' and GuestAlerts == 'false', ""All settings changed"", 
                            EnforceLogin == 'false' and EnforceLoginDomain == 'false', ""Enforced Logons and Restricted Domains Changed"", 
                            EnforceLoginDomain == 'false' and GuestAlerts == 'false', ""Enforced Domains Changed"", 
                            EnforceLoginDomain == 'false', ""Enfored Domains Changed"", 
                            GuestAlerts == 'false', ""Guest Join Alerts Changed"", 
                            EnforceLogin == 'false', ""Enforced Logins Changed"", 
                            ""No Changes"")
| extend timestamp = TimeGenerated, AccountCustomEntity = User
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/ExternalUserAccess.yaml,2020-10-04,ExternalUserAccess.yaml
29752996-e85d-4905-a0e1-a7dcdfcda283,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1098,Account Manipulation,,Hunting Query,Azure Sentinel Community Github,New domain added to Whitelist,"'This hunting query identifies new domains added to the domain login whitelist in Zoom.'
",CustomConnector,CustomLogs_CL,"
let hunt_time = 14d; 
ZoomLogs 
| where TimeGenerated >= ago(hunt_time)
| where Event =~ ""account.settings_updated""
| extend NewDomains = columnifexists(""payload_object_enforce_logon_domains"", """")
| where isnotempty(NewDomains)
| project TimeGenerated, Event, User, NewDomains
| extend timestamp = TimeGenerated, AccountCustomEntity = User",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/NewDomainAccess.yaml,2020-10-04,NewDomainAccess.yaml
4d94d4a9-dc96-410a-8dea-4d4d4584188b,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,SaaS,Detection,Azure Sentinel Community Github,User added to Azure Active Directory Privileged Groups,"'This will alert when a user is added to any of the Privileged Groups.
For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.
For Administrator role permissions in Azure Active Directory please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles'
",AzureActiveDirectory,AuditLogs,"let timeframe = 1h;
let OperationList = dynamic([""Add member to role"",""Add member to role in PIM requested (permanent)""]);
let PrivilegedGroups = dynamic([""UserAccountAdmins"",""PrivilegedRoleAdmins"",""TenantAdmins""]);
AuditLogs
| where TimeGenerated >= ago(timeframe)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""RoleManagement""
| where OperationName in~ (OperationList)
| mv-expand TargetResources
| extend modifiedProperties = parse_json(TargetResources).modifiedProperties
| mv-expand modifiedProperties
| extend DisplayName = tostring(parse_json(modifiedProperties).displayName), GroupName =  trim(@'""',tostring(parse_json(modifiedProperties).newValue))
| extend AppId = tostring(parse_json(parse_json(InitiatedBy).app).appId), InitiatedByDisplayName = tostring(parse_json(parse_json(InitiatedBy).app).displayName), ServicePrincipalId = tostring(parse_json(parse_json(InitiatedBy).app).servicePrincipalId), ServicePrincipalName = tostring(parse_json(parse_json(InitiatedBy).app).servicePrincipalName)
| where DisplayName =~ ""Role.WellKnownObjectName""
| where GroupName in~ (PrivilegedGroups)
// If you want to still alert for operations from PIM, remove below filtering for MS-PIM.
| where InitiatedByDisplayName != ""MS-PIM""
| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, AppId, InitiatedByDisplayName, ServicePrincipalId, ServicePrincipalName, DisplayName, GroupName
| extend timestamp = TimeGenerated, AccountCustomEntity = ServicePrincipalName",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/UseraddedtoPrivilgedGroups.yaml,2020-10-04,UseraddedtoPrivilgedGroups.yaml
0b9ae89d-8cad-461c-808f-0494f70ad5c4,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,Office 365,Detection,Azure Sentinel Community Github,Multiple Password Reset by user,"'This query will determine multiple password resets by user across multiple data sources. 
Account manipulation including password reset may aid adversaries in maintaining access to credentials 
and certain permission levels within an environment.'
",Office365,OfficeActivity,"
let timeframe = 1d;
let PerUserThreshold = 5;
let TotalThreshold = 100;
let action = dynamic([""change"", ""changed"", ""reset""]);
let pWord = dynamic([""password"", ""credentials""]);
let PasswordResetMultiDataSource =
(union isfuzzy=true
(//Password reset events
//4723: An attempt was made to change an account's password
//4724: An attempt was made to reset an accounts password
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID in (""4723"",""4724"")
| project TimeGenerated, Computer, AccountType, Account, Type),
(//Azure Active Directory Password reset events
AuditLogs
| where TimeGenerated >= ago(timeframe)
| where OperationName has_any (pWord) and OperationName has_any (action)
| extend AccountType = tostring(TargetResources[0].type), Account = tostring(TargetResources[0].userPrincipalName), 
TargetResourceName = tolower(tostring(TargetResources[0].displayName))
| project TimeGenerated, AccountType, Account, Computer = TargetResourceName, Type),
(//OfficeActive ActiveDirectory Password reset events
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where OfficeWorkload == ""AzureActiveDirectory"" 
| where (ExtendedProperties has_any (pWord) or ModifiedProperties has_any (pWord)) and (ExtendedProperties has_any (action) or ModifiedProperties has_any (action))
| extend AccountType = UserType, Account = OfficeObjectId 
| project TimeGenerated, AccountType, Account, Type, Computer = """"),
(// Unix syslog password reset events
Syslog
| where TimeGenerated >= ago(timeframe)
| where Facility in (""auth"",""authpriv"")
| where SyslogMessage has_any (pWord) and SyslogMessage has_any (action)
| extend AccountType = iif(SyslogMessage contains ""root"", ""Root"", ""Non-Root"")
| parse SyslogMessage with * ""password changed for"" Account
| project TimeGenerated, AccountType, Account, Computer = HostName, Type),
(SigninLogs
| where TimeGenerated >= ago(timeframe)
| where OperationName =~ ""Sign-in activity"" and ResultType has_any (""50125"", ""50133"")
| project TimeGenerated, AccountType = AppDisplayName, Computer = IPAddress, Account = UserPrincipalName, Type
)
);
let pwrmd = PasswordResetMultiDataSource
| project TimeGenerated, Computer, AccountType, Account, Type;
(union isfuzzy=true  
(pwrmd
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computer = makeset(Computer), AccountType = makeset(AccountType), Total=count() by Account, Type
| where Total > PerUserThreshold
| extend ResetPivot = ""PerUserReset""),  
(pwrmd
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computer = makeset(Computer), Account = tostring(makeset(Account)), AccountType = makeset(AccountType), Total=count() by Type
| where Total > TotalThreshold
| extend ResetPivot = ""TotalUserReset"")
)
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = tostring(Computer)
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MultiplePasswordresetsbyUser.yaml,2020-10-04,MultiplePasswordresetsbyUser.yaml
157c0cfc-d76d-463b-8755-c781608cdc1a,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Detection,Azure Sentinel Community Github,Cisco - firewall block but success logon to Azure AD,"'Correlate IPs blocked by a Cisco firewall appliance with successful Azure Active Directory signins. 
Because the IP was blocked by the firewall, that same IP logging on successfully to AAD is potentially suspect
and could indicate credential compromise for the user account.'
",AzureActiveDirectory,SigninLogs,"
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.';
let endtime = 1d;
CommonSecurityLog
| where TimeGenerated >= ago(endtime) 
| where DeviceVendor =~ ""Cisco""
| where DeviceAction =~ ""denied""
| extend SourceIPType = iff(SourceIP matches regex PrivateIPregex,""private"" ,""public"" )
| where SourceIPType == ""public""
| summarize count() by SourceIP
| join (
    // Successful signins from IPs blocked by the firewall solution are suspect
    // Include fully successful sign-ins, but also ones that failed only at MFA stage
    // as that supposes the password was sucessfully guessed.
  SigninLogs
  | where ResultType in (""0"", ""50074"", ""50076"") 
) on $left.SourceIP == $right.IPAddress
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, AccountCustomEntity = UserPrincipalName
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SigninFirewallCorrelation.yaml,2020-10-04,SigninFirewallCorrelation.yaml
8ee967a2-a645-4832-85f4-72b635bcb3a6,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,Linux,Detection,Azure Sentinel Community Github,Failed AzureAD logons but success logon to host,"'Identifies a list of IP addresses with a minimum number (default of 5) of failed logon attempts to Azure Active Directory.
Uses that list to identify any successful remote logons to hosts from these IPs within the same timeframe.'
",Syslog,Syslog,"
let timeframe = 1d;
//Adjust this threshold to fit the environment
let signin_threshold = 5;
//Make a list of all IPs with failed signins to AAD above our threshold
let suspicious_signins =
SigninLogs
| where TimeGenerated >= ago(timeframe)
| where ResultType !in (""0"", ""50125"", ""50140"")
| where IPAddress != ""127.0.0.1""
| summarize count() by IPAddress
| where count_ > signin_threshold
| summarize make_list(IPAddress);
//See if any of these IPs have sucessfully logged into *nix hosts
let linux_logons =
Syslog
| where TimeGenerated >= ago(timeframe)
| where Facility contains ""auth"" and ProcessName != ""sudo""
| where SyslogMessage has ""Accepted""
| extend SourceIP = extract(""(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))"",1,SyslogMessage)
| where SourceIP in (suspicious_signins)
| extend Reason = ""Multiple failed AAD logins from IP address""
| project TimeGenerated, Computer, HostIP, IpAddress = SourceIP, SyslogMessage, Facility, ProcessName, Reason;
//See if any of these IPs have sucessfully logged into Windows hosts
let win_logons =
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4624
| where LogonType in (10, 7, 3)
| where IpAddress != ""-""
| where IpAddress in (suspicious_signins)
| extend Reason = ""Multiple failed AAD logins from IP address""
| project TimeGenerated, Account, AccountType, Computer, Activity, EventID, LogonProcessName, IpAddress, LogonTypeName, TargetUserSid, Reason;
union isfuzzy=true linux_logons,win_logons
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, IPCustomEntity = IpAddress, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AADHostLoginCorrelation.yaml,2020-10-04,AADHostLoginCorrelation.yaml
1ce5e766-26ab-4616-b7c8-3b33ae321e80,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,Linux,Detection,Azure Sentinel Community Github,Failed host logons but success logon to AzureAD,"'Identifies a list of IP addresses with a minimum number(default of 5) of failed logon attempts to remote hosts.
Uses that list to identify any successful logons to Azure Active Directory from these IPs within the same timeframe.'
",Syslog,Syslog,"
let timeframe = 1d;
//Adjust this threshold to fit environment
let signin_threshold = 5; 
//Make a list of IPs with failed Windows host logins above threshold
let win_fails = 
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4625
| where LogonType in (10, 7, 3)
| where IpAddress != ""-""
| summarize count() by IpAddress
| where count_ > signin_threshold
| summarize make_list(IpAddress);
//Make a list of IPs with failed *nix host logins above threshold
let nix_fails = 
Syslog
| where TimeGenerated > ago(timeframe)
| where Facility contains 'auth' and ProcessName != 'sudo'
| extend SourceIP = extract(""(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))"",1,SyslogMessage)
| where SourceIP != """" and SourceIP != ""127.0.0.1""
| summarize count() by SourceIP
| where count_ > signin_threshold
| summarize make_list(SourceIP);
//See if any of the IPs with failed host logins hve had a sucessful Azure AD login
SigninLogs
| where TimeGenerated > ago(timeframe)
| where ResultType !in (""0"", ""50125"", ""50140"")
| where IPAddress in (win_fails) or IPAddress in (nix_fails)
| extend Reason=  ""Multiple failed host logins from IP address with successful Azure AD login""
| extend timstamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/HostAADCorrelation.yaml,2020-10-04,HostAADCorrelation.yaml
643c2025-9604-47c5-833f-7b4b9378a1f5,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,AWS,Detection,Azure Sentinel Community Github,Failed AzureAD logons but success logon to AWS Console,"'Identifies a list of IP addresses with a minimum number(defualt of 5) of failed logon attempts to Azure Active Directory.
Uses that list to identify any successful AWS Console logons from these IPs within the same timeframe.'
",AWS,AWSCloudTrail,"
//Adjust this threshold to fit your environment
let signin_threshold = 5; 
//Make a list of IPs with AAD signin failures above our threshold
let Suspicious_signins = 
SigninLogs
| where TimeGenerated >= ago(1d)
| where ResultType !in (""0"", ""50125"", ""50140"")
| where IPAddress != ""127.0.0.1""
| summarize count() by IPAddress
| where count_ >  signin_threshold
| summarize make_list(IPAddress);
//See if any of those IPs have sucessfully logged into the AWS console
AWSCloudTrail
| where TimeGenerated > ago(1d)
| where EventName =~ ""ConsoleLogin""
| extend LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin) 
| where LoginResult =~ ""Success""
| where SourceIpAddress in (Suspicious_signins)
| extend Reason = ""Multiple failed AAD logins from IP address""
| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed)
| extend User = iif(isempty(UserIdentityUserName), UserIdentityType, UserIdentityUserName) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by Reason, LoginResult, EventTypeName, UserIdentityType, User, AWSRegion, SourceIpAddress, UserAgent, MFAUsed
| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = SourceIpAddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AADAWSConsoleCorrelation.yaml,2020-10-04,AADAWSConsoleCorrelation.yaml
ba144bf8-75b8-406f-9420-ed74397f9479,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,GCP,Detection,Azure Sentinel Community Github,IP with multiple failed Azure AD logins successfully logs in to Palo Alto VPN,"This query creates a list of IP addresses with a number failed login attempts to AAD 
above a set threshold.  It then looks for any successful Palo Alto VPN logins from any
of these IPs within the same timeframe.
",PaloAltoNetworks,CommonSecurityLog,"let timeframe = 1d;
//Set a threshold of failed AAD signins from an IP address within 1 day above which we want to deem those logins suspicious.
let signin_threshold = 5; 
//Make a list of IPs with AAD signin failures above our threshold.
let suspicious_signins = 
    SigninLogs
    | where TimeGenerated >= ago(timeframe)
    //Looking for logon failure results
    | where ResultType !in (""0"", ""50125"", ""50140"")
    //Exclude localhost addresses to reduce the chance of FPs
    | where IPAddress != ""127.0.0.1""
    | summarize count() by IPAddress
    | where count_ >  signin_threshold
    | summarize make_list(IPAddress);
//See if any of those IPs have sucessfully logged into PA VPNs during the same timeperiod
CommonSecurityLog
    | where TimeGenerated > ago(timeframe)
    //Select only PA VPN sucessful logons
    | where DeviceVendor == ""Palo Alto Networks"" and DeviceEventClassID == ""globalprotect""
    | where Message has ""GlobalProtect gateway user authentication succeeded""
    //Parse out the logon source IP from the Message field to match on
    | extend SourceIP = extract(""Login from: ([^,]+)"", 1, Message) 
    | where SourceIP in (suspicious_signins)
    | extend Reason = ""Multiple failed AAD logins from SourceIP""
    //Parse out other useful information from Message field
    | extend User = extract(""User name: ([^,]+)"", 1, Message) 
    | extend ClientOS = extract(""Client OS version: ([^,\""]+)"", 1, Message)
    | extend Location = extract(""Source region: ([^,]{2})"",1, Message)
    | project TimeGenerated, Reason, SourceIP, User, ClientOS, Location, Message, DeviceName, ReceiptTime, DeviceVendor, DeviceEventClassID, Computer, FileName
    | extend AccountCustomEntity = User, IPCustomEntity = SourceIP, timestamp = TimeGenerated, HostCustomEntity = DeviceName 
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AAD_PAVPN_Correlation.yaml,2020-10-04,AAD_PAVPN_Correlation.yaml
910124df-913c-47e3-a7cd-29e1643fa55e,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,AWS,Detection,Azure Sentinel Community Github,Failed AWS Console logons but success logon to AzureAD,"'Identifies a list of IP addresses with a minimum numbe(default of 5) of failed logon attempts to AWS Console.
Uses that list to identify any successful Azure Active Directory logons from these IPs within the same timeframe.'
",AWS,AWSCloudTrail,"
//Adjust this threshold to fit environment
let  signin_threshold = 5; 
//Make a list of IPs with failed AWS console logins
let aws_fails = AWSCloudTrail
| where TimeGenerated >= ago(1d)
| where EventName == ""ConsoleLogin""
| extend LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin) 
| where LoginResult == ""Success""
| where SourceIpAddress != ""127.0.0.1""
| summarize count() by SourceIpAddress
| where count_ >  signin_threshold
| summarize make_list(SourceIpAddress);
//See if any of those IPs have sucessfully logged into Azure AD.
SigninLogs
| where TimeGenerated >= ago(1d)
| where ResultType !in (""0"", ""50125"", ""50140"")
| where IPAddress in (aws_fails) 
| extend Reason = ""Multiple failed AWS Console logins from IP address""
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AWSConsoleAADCorrelation.yaml,2020-10-04,AWSConsoleAADCorrelation.yaml
4915c713-ab38-432e-800b-8e2d46933de6,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Linux,Detection,Azure Sentinel Community Github,New internet-exposed SSH endpoints,"'Looks for SSH endpoints with a history of sign-ins only from private IP addresses are accessed from a public IP address.'
",Syslog,Syslog,"
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.'; 
let avgthreshold = 0;
let probabilityLimit = 0.01;
let startime = 7d;
let ssh_logins = Syslog
| where TimeGenerated >= ago(startime)
| where Facility contains ""auth"" and ProcessName =~ ""sshd""
| where SyslogMessage has ""Accepted""
| extend SourceIP = extract(""(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))"",1,SyslogMessage) 
| where isnotempty(SourceIP)
| extend ipType = iff(SourceIP matches regex PrivateIPregex,""private"" ,""public"");
ssh_logins 
| summarize privatecount=countif(ipType==""private""), publiccount=countif(ipType==""public"") by HostName, HostIP, bin(EventTime, 1d)
| summarize 
publicIPLoginHistory  = make_list(pack('IPCount', publiccount,  'logon_time', EventTime)),
privateIPLoginHistory = make_list(pack('IPCount', privatecount, 'logon_time', EventTime)) by HostName, HostIP
| mv-apply publicIPLoginHistory = publicIPLoginHistory on
(
    order by todatetime(publicIPLoginHistory['logon_time']) asc
    | summarize publicIPLoginCountList=make_list(toint(publicIPLoginHistory['IPCount'])), publicAverage=avg(toint(publicIPLoginHistory['IPCount'])), publicStd=stdev(toint(publicIPLoginHistory['IPCount'])), maxPublicLoginCount=max(toint(publicIPLoginHistory['IPCount']))
)
| mv-apply privateIPLoginHistory = privateIPLoginHistory on
(
    order by todatetime(privateIPLoginHistory['logon_time']) asc
    | summarize privateIPLoginCountList=make_list(toint(privateIPLoginHistory['IPCount'])), privateAverage=avg(toint(privateIPLoginHistory['IPCount'])), privateStd=stdev(toint(privateIPLoginHistory['IPCount']))
)
// Some logins from private IPs
| where privateAverage > avgthreshold
// There is a non-zero number of logins from public IPs
| where publicAverage > avgthreshold
// Approximate probability of seeing login from a public IP is < 1%
| extend probabilityPublic = publicAverage / (privateAverage + publicAverage)
| where probabilityPublic < probabilityLimit
// Today has the highest number of logins from public IPs that we've seen in the last week
| extend publicLoginCountToday = publicIPLoginCountList[-1]
| where publicLoginCountToday >= maxPublicLoginCount
| extend HostCustomEntity = HostName
// Optionally retrieve the original raw data for those logins that we've identified as potentially suspect
// | join kind=rightsemi (
//   ssh_logins
//  | where ipType == ""public""
//  ) on HostName
",1d,7d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/ssh_NewlyInternetExposed.yaml,2020-10-04,ssh_NewlyInternetExposed.yaml
a35f2c18-1b97-458f-ad26-e033af18eb99,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Detection,Azure Sentinel Community Github,User account added to built in domain local or global group,"'Identifies when a user account has been added to a privileged built in domain local group or global group 
such as the Enterprise Admins, Cert Publishers or DnsAdmins. Be sure to verify this is an expected addition.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$"";
SecurityEvent 
| where TimeGenerated > ago(timeframe)
// When MemberName contains '-' this indicates addition of a group to a group
| where AccountType == ""User"" and MemberName != ""-""
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group
| where EventID in (4728, 4732, 4756)   
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| extend SimpleMemberName = tostring(split(tostring(split(MemberName, "","")[0]),""CN="")[1])
| project StartTimeUtc = TimeGenerated, EventID, Activity, Computer, SimpleMemberName, MemberName, MemberSid, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid
| extend timestamp = StartTimeUtc, AccountCustomEntity = SimpleMemberName, HostCustomEntity = Computer
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountAddedToPrivlegeGroup_1h.yaml,2020-10-04,UserAccountAddedToPrivlegeGroup_1h.yaml
7efc75ce-e2a4-400f-a8b1-283d3b0f2c60,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Detection,Azure Sentinel Community Github,Account added and removed from privileged groups,"'Identifies accounts that are added to privileged group and then quickly removed, which could be a sign of compromise.' 
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$"";
let AC_Add = 
SecurityEvent
| where TimeGenerated >= ago(timeframe)
// Event ID related to member addition.
| where EventID in (4728, 4732,4756) 
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID  
| parse EventData with * '""MemberName"">' AccountAdded "",OU"" * 
| where isnotempty(AccountAdded)
| extend GroupAddedTo = TargetUserName, AddingAccount = Account 
| extend  AccountAdded_GroupAddedTo_AddingAccount = strcat(AccountAdded, ""||"", GroupAddedTo, ""||"", AddingAccount )
| project AccountAdded_GroupAddedTo_AddingAccount, AccountAddedTime = TimeGenerated;
let AC_Remove = 
SecurityEvent
| where TimeGenerated >= ago(timeframe)
// Event IDs related to member removal.
| where EventID in (4729,4733,4757)
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID 
| parse EventData with * '""MemberName"">' AccountRemoved "",OU"" * 
| where isnotempty(AccountRemoved)
| extend GroupRemovedFrom = TargetUserName, RemovingAccount = Account
| extend AccountRemoved_GroupRemovedFrom_RemovingAccount = strcat(AccountRemoved, ""||"", GroupRemovedFrom, ""||"", RemovingAccount)
| project AccountRemoved_GroupRemovedFrom_RemovingAccount, AccountRemovedTime = TimeGenerated, Computer, RemovedAccountId = tolower(AccountRemoved), 
RemovedByUser = SubjectUserName, RemovedByUserLogonId = SubjectLogonId,  GroupRemovedFrom = TargetUserName, TargetDomainName; 
AC_Add 
| join kind= inner AC_Remove on $left.AccountAdded_GroupAddedTo_AddingAccount == $right.AccountRemoved_GroupRemovedFrom_RemovingAccount 
| extend DurationinSecondAfter_Removed = datetime_diff ('second', AccountRemovedTime, AccountAddedTime)
| where DurationinSecondAfter_Removed > 0
| project-away AccountRemoved_GroupRemovedFrom_RemovingAccount
| extend timestamp = AccountAddedTime, AccountCustomEntity = RemovedAccountId, HostCustomEntity = Computer
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountAdd-Removed.yaml,2020-10-04,UserAccountAdd-Removed.yaml
3d023f64-8225-41a2-9570-2bd7c2c4535e,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Detection,Azure Sentinel Community Github,User account enabled and disabled within 10 mins,"'Identifies when a user account is enabled and then disabled within 10 minutes. This can be an indication of compromise and
an adversary attempting to hide in the noise.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let spanoftime = 10m;
let threshold = 0;
SecurityEvent 
| where TimeGenerated > ago(2*timeframe) 
// A user account was enabled
| where EventID == 4722
| where AccountType =~ ""User""
| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid 
| join kind= inner (
  SecurityEvent
  | where TimeGenerated > ago(timeframe) 
  // A user account was disabled 
  | where EventID == 4725
| where AccountType == ""User""
| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid 
) on Computer, TargetUserName
| where deletionTime - creationTime < spanoftime
| extend TimeDelta = deletionTime - creationTime
| where tolong(TimeDelta) >= threshold
| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, 
deletionTime, DeleteEventID, AccountUsedToDelete
| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountEnabledDisabled_10m.yaml,2020-10-04,UserAccountEnabledDisabled_10m.yaml
a7564d76-ec6b-4519-a66b-fcc80c42332b,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Detection,Azure Sentinel Community Github,Group added to built in domain local or global group,"'Identifies when a recently created Group was added to a privileged built in domain local group or global group such as the 
Enterprise Admins, Cert Publishers or DnsAdmins.  Be sure to verify this is an expected addition.
References: For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1h;
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$"";
let GroupAddition = SecurityEvent 
| where TimeGenerated > ago(timeframe)
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group  
| where EventID in (""4728"", ""4732"", ""4756"") 
| where AccountType =~ ""User"" and MemberName == ""-""
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, 
GroupAddTargetUserName = TargetUserName, GroupAddTargetDomainName = TargetDomainName, GroupAddTargetSid = TargetSid,  
GroupAddSubjectUserName = SubjectUserName, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid;
let GroupCreated = SecurityEvent
| where TimeGenerated > ago(timeframe)
// 4727 - A security-enabled global group was created
// 4731 - A security-enabled local group was created
// 4754 - A security-enabled universal group was created
| where EventID in (""4727"", ""4731"", ""4754"")
| where AccountType =~ ""User""
| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, 
GroupCreateTargetUserName = TargetUserName, GroupCreateTargetDomainName = TargetDomainName, GroupCreateSubjectUserName = SubjectUserName, 
GroupCreateSubjectDomainName = SubjectDomainName, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid;
GroupCreated
| join (
GroupAddition
) on GroupSid 
| extend timestamp = GroupCreateTime, AccountCustomEntity = GroupCreateSubjectUserName, HostCustomEntity = GroupCreateComputer
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/GroupCreatedAddedToPrivlegeGroup_1h.yaml,2020-10-04,GroupCreatedAddedToPrivlegeGroup_1h.yaml
4b93c5af-d20b-4236-b696-a28b8c51407f,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Detection,Azure Sentinel Community Github,User account created and deleted within 10 mins,"'Identifies when a user account is created and then deleted within 10 minutes. This can be an indication of compromise and
an adversary attempting to hide in the noise.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let spanoftime = 10m;
let threshold = 0;
SecurityEvent 
| where TimeGenerated > ago(2*timeframe) 
// A user account was created
| where EventID == 4720
| where AccountType =~ ""User""
| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid 
| join kind= inner (
  SecurityEvent
  | where TimeGenerated > ago(timeframe) 
  // A user account was deleted 
  | where EventID == 4726
| where AccountType == ""User""
| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid 
) on Computer, TargetUserName
| where deletionTime - creationTime < spanoftime
| extend TimeDelta = deletionTime - creationTime
| where tolong(TimeDelta) >= threshold
| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, 
deletionTime, DeleteEventID, AccountUsedToDelete
| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountCreatedDeleted_10m.yaml,2020-10-04,UserAccountCreatedDeleted_10m.yaml
aa1eff90-29d4-49dc-a3ea-b65199f516db,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Detection,Azure Sentinel Community Github,New user created and added to the built-in administrators group,"'Identifies when a user account was created and then added to the builtin Administrators group in the same day.
This should be monitored closely and all additions reviewed.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
SecurityEvent
| where TimeGenerated > ago(timeframe) 
| where EventID == 4720
| where AccountType == ""User""
| project CreatedUserTime = TimeGenerated, CreatedUserEventID = EventID, CreatedUserActivity = Activity, Computer = toupper(Computer), 
CreatedUser = tolower(TargetUserName), Domain = toupper(TargetDomainName), CreatedUserSid = TargetSid, AccountUsedToCreateUser = SubjectUserName
|join (
SecurityEvent 
| where TimeGenerated > ago(timeframe) 
| where AccountType == ""User""
// 4732 - A member was added to a security-enabled local group
| where EventID == 4732
//TargetSid is the builin Admins group: S-1-5-32-544
| where TargetSid == ""S-1-5-32-544""
| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, Computer = toupper(Computer), GroupName = TargetUserName, 
Domain = toupper(TargetDomainName), GroupSid = TargetSid, UserAdded = SubjectUserName, UserAddedSid = SubjectUserSid, CreatedUser = tolower(SubjectUserName), 
CreatedUserSid = MemberSid
)
on CreatedUserSid
//Create User first, then the add to the group.
| project Computer, CreatedUserTime, CreatedUserEventID, CreatedUserActivity, CreatedUser, CreatedUserSid, Domain, GroupAddTime, GroupAddEventID, 
GroupAddActivity, AccountUsedToCreateUser, GroupName, GroupSid, UserAdded, UserAddedSid 
| extend timestamp = CreatedUserTime, AccountCustomEntity = CreatedUser, HostCustomEntity = Computer
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserCreatedAddedToBuiltinAdmins_1d.yaml,2020-10-04,UserCreatedAddedToBuiltinAdmins_1d.yaml
7cb8f77d-c52f-4e46-b82f-3cf2e106224a,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Detection,Azure Sentinel Community Github,Anomalous sign-in location by user account and authenticating application,"'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
Directory application and picks out the most anomalous change in location profile for a user within an 
individual application. An alert is generated for recent sign-ins that have location counts that are anomalous
over last day but also over the last 7-day and 14-day periods.'
",AzureActiveDirectory,SigninLogs,"
let lookBack_long = 14d;
let lookBack_med = 7d;
let lookBack = 1d;
SigninLogs
| where TimeGenerated >= startofday(ago(lookBack_long))
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_long)),now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| where Slope > 0.3
| top 50 by Slope desc
| join kind = leftsemi (
SigninLogs
| where TimeGenerated >= startofday(ago(lookBack_med))
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_med)) ,now(), 1d) 
by UserPrincipalName, AppDisplayName 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
| top 50 by Slope desc
| where Slope > 0.3
) on UserPrincipalName, AppDisplayName
| join kind = leftsemi (
SigninLogs
| where TimeGenerated >= startofday(ago(lookBack))
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack)) ,now(), 1d) 
by UserPrincipalName, AppDisplayName 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
| top 50 by Slope desc
// Higher threshold requirement on last day anomaly
| where Slope > 5
) on UserPrincipalName, AppDisplayName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName
",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/AnomalousUserAppSigninLocationIncrease-detection.yaml,2020-10-04,AnomalousUserAppSigninLocationIncrease-detection.yaml
500c103a-0319-4d56-8e99-3cec8d860757,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1078,Valid Accounts,Azure AD,Detection,Azure Sentinel Community Github,Sign-ins from IPs that attempt sign-ins to disabled accounts,"'Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
50057 - User account is disabled. The account has been disabled by an administrator.'
",AzureActiveDirectory,SigninLogs,"
let lookBack = 1d;
SigninLogs 
| where TimeGenerated >= ago(lookBack)
| where ResultType == ""50057"" 
| where ResultDescription == ""User account is disabled. The account has been disabled by an administrator."" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), disabledAccountLoginAttempts = count(), 
disabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = makeset(UserPrincipalName), 
applicationSet = makeset(AppDisplayName) by IPAddress
| order by disabledAccountLoginAttempts desc
| join kind= leftouter (
    // Consider these IPs suspicious - and alert any related  successful sign-ins
    SigninLogs
    | where TimeGenerated >= ago(lookBack)
    | where ResultType == 0
    | summarize successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = makeset(UserPrincipalName, 15) by IPAddress
    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe
    | where successfulAccountSigninCount < 100
) on IPAddress  
// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account
| where successfulAccountSigninCount != 0
| project StartTimeUtc, EndTimeUtc, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, 
successfulAccountSigninCount, successfulAccountSigninSet
| order by disabledAccountLoginAttempts
| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/SigninAttemptsByIPviaDisabledAccounts.yaml,2020-10-04,SigninAttemptsByIPviaDisabledAccounts.yaml
75ea5c39-93e5-489b-b1e1-68fa6c9d2d04,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Detection,Azure Sentinel Community Github,Attempts to sign in to disabled accounts,"'Identifies failed attempts to sign in to disabled accounts across multiple Azure Applications.
Default threshold for Azure Applications attempted to sign in to is 3.
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
50057 - User account is disabled. The account has been disabled by an administrator.'
",AzureActiveDirectory,SigninLogs,"
let timeframe = 1d;
let threshold = 3;
SigninLogs
| where TimeGenerated >= ago(timeframe)
| where ResultType == ""50057""
| where ResultDescription =~ ""User account is disabled. The account has been disabled by an administrator.""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count(), applicationCount = dcount(AppDisplayName), 
applicationSet = makeset(AppDisplayName) by UserPrincipalName, IPAddress
| where applicationCount >= threshold
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress 
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/DisabledAccountSigninsAcrossManyApplications.yaml,2020-10-04,DisabledAccountSigninsAcrossManyApplications.yaml
3af9285d-bb98-4a35-ad29-5ea39ba0c628,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1078,Valid Accounts,Azure AD,Detection,Azure Sentinel Community Github,Attempt to bypass conditional access rule in Azure AD,"'Identifies an attempt to Bypass conditional access rule(s) in Azure Active Directory.
The ConditionalAccessStatus column value details if there was an attempt to bypass Conditional Access
or if the Conditional access rule was not satisfied (ConditionalAccessStatus == 1).
References: 
https://docs.microsoft.com/azure/active-directory/conditional-access/overview
https://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins
https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
ConditionalAccessStatus == 0 // Success
ConditionalAccessStatus == 1 // Failure
ConditionalAccessStatus == 2 // Not Applied
ConditionalAccessStatus == 3 // unknown'
",AzureActiveDirectory,SigninLogs,"
let timeRange = ago(1d);
let threshold = 1;
SigninLogs
| where TimeGenerated >= timeRange
| where ConditionalAccessStatus == 1 or ConditionalAccessStatus =~ ""failure""
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser 
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName)
| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName)
| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName)
| extend Status = strcat(StatusCode, "": "", ResultDescription) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Status = makelist(Status), StatusDetails = makelist(StatusDetails), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress) , CorrelationIds = makelist(CorrelationId) by UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), Location, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name
| where IPAddressCount > threshold and StatusDetails !has ""MFA successfully completed""
| mvexpand IPAddresses, Status, StatusDetails, CorrelationIds
| extend Status = strcat(Status, "" "", StatusDetails)
| summarize IPAddresses = makeset(IPAddresses), Status = makeset(Status), CorrelationIds = makeset(CorrelationIds) by StartTimeUtc, EndTimeUtc, UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), Location, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name, IPAddressCount
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = tostring(IPAddresses)
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/BypassCondAccessRule.yaml,2020-10-04,BypassCondAccessRule.yaml
02ef8d7e-fc3a-4d86-a457-650fa571d8d2,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Detection,Azure Sentinel Community Github,Successful logon from IP and failure from a different IP,"'Identifies when a user account successfully logs onto an Azure App from one IP and within 10 mins failed to logon to the same App via a different IP.
This may indicate a malicious attempt at password guessing based on knowledge of the users account.'
",AzureActiveDirectory,SigninLogs,"
let timeFrame = 1d;
let logonDiff = 10m;
SigninLogs 
| where TimeGenerated >= ago(timeFrame) 
| where ResultType == ""0"" 
| where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"")
| project SuccessLogonTime = TimeGenerated, UserPrincipalName, SuccessIPAddress = IPAddress, AppDisplayName, SuccessIPBlock = strcat(split(IPAddress, ""."")[0], ""."", split(IPAddress, ""."")[1])
| join kind= inner (
    SigninLogs 
    | where TimeGenerated >= ago(timeFrame) 
    | where ResultType !in (""0"", ""50140"") 
    | where ResultDescription !~ ""Other""  
    | where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"")
    | project FailedLogonTime = TimeGenerated, UserPrincipalName, FailedIPAddress = IPAddress, AppDisplayName, ResultType, ResultDescription
) on UserPrincipalName, AppDisplayName 
| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and FailedIPAddress !startswith SuccessIPBlock
| summarize FailedLogonTime = max(FailedLogonTime), SuccessLogonTime = max(SuccessLogonTime) by UserPrincipalName, SuccessIPAddress, AppDisplayName, FailedIPAddress, ResultType, ResultDescription 
| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SuccessIPAddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/SuccessThenFail_DiffIP_SameUserandApp.yaml,2020-10-04,SuccessThenFail_DiffIP_SameUserandApp.yaml
7b907bf7-77d4-41d0-a208-5643ff75bf9a,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1078,Valid Accounts,Office 365,Detection,Azure Sentinel Community Github,Malicious Inbox Rule,"'Often times after the initial compromise the attackers create inbox rules to delete emails that contain certain keywords. 
 This is done so as to limit ability to warn compromised users that they've been compromised. Below is a sample query that tries to detect this.
Reference: https://www.reddit.com/r/sysadmin/comments/7kyp0a/recent_phishing_attempts_my_experience_and_what/'
",Office365,OfficeActivity,"
let timeframe = 1d;
let Keywords = dynamic([""helpdesk"", "" alert"", "" suspicious"", ""fake"", ""malicious"", ""phishing"", ""spam"", ""do not click"", ""do not open"", ""hijacked"", ""Fatal""]);
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where Operation =~ ""New-InboxRule""
| where Parameters has ""Deleted Items"" or Parameters has ""Junk Email"" 
| extend Events=todynamic(Parameters)
| parse Events  with * ""SubjectContainsWords"" SubjectContainsWords '}'*
| parse Events  with * ""BodyContainsWords"" BodyContainsWords '}'*
| parse Events  with * ""SubjectOrBodyContainsWords"" SubjectOrBodyContainsWords '}'*
| where SubjectContainsWords has_any (Keywords)
 or BodyContainsWords has_any (Keywords)
 or SubjectOrBodyContainsWords has_any (Keywords)
| extend ClientIPAddress = case( ClientIP has ""."", tostring(split(ClientIP,"":"")[0]), ClientIP has ""["", tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))), ClientIP )
| extend Keyword = iff(isnotempty(SubjectContainsWords), SubjectContainsWords, (iff(isnotempty(BodyContainsWords),BodyContainsWords,SubjectOrBodyContainsWords )))
| extend RuleDetail = case(OfficeObjectId contains '/' , tostring(split(OfficeObjectId, '/')[-1]) , tostring(split(OfficeObjectId, '\\')[-1]))
| summarize count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by  Operation, UserId, ClientIPAddress, ResultStatus, Keyword, OriginatingServer, OfficeObjectId, RuleDetail
| extend timestamp = StartTimeUtc,  IPCustomEntity = ClientIPAddress, AccountCustomEntity = UserId , HostCustomEntity =  OriginatingServer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Malicious_Inbox_Rule.yaml,2020-10-04,Malicious_Inbox_Rule.yaml
d25b1998-a592-4bc5-8a3a-92b39eedb1bc,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,AWS,Detection,Azure Sentinel Community Github,Login to AWS Management Console without MFA,"'Multi-Factor Authentication (MFA) helps you to prevent credential compromise. This alert identifies logins to the AWS Management Console without MFA.
You can limit this detection to trigger for adminsitrative accounts if you do not have MFA enabled on all accounts.
This is done by looking at the eventName ConsoleLogin and if the AdditionalEventData field indicates MFA was NOT used 
and the ResponseElements field indicates NOT a Failure. Thereby indicating that a non-MFA login was successful.'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
AWSCloudTrail
| where TimeGenerated > ago(timeframe)
| where EventName =~ ""ConsoleLogin"" 
| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed), LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin)
| where MFAUsed !~ ""Yes"" and LoginResult !~ ""Failure""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, LoginResult, MFAUsed, UserIdentityAccountId,  UserIdentityPrincipalid, UserAgent, 
UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ConsoleLogonWithoutMFA.yaml,2020-10-04,AWS_ConsoleLogonWithoutMFA.yaml
65360bb0-8986-4ade-a89d-af3cf44d28aa,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1078,Valid Accounts,AWS,Detection,Azure Sentinel Community Github,Changes to Amazon VPC settings,"'Amazon Virtual Private Cloud (Amazon VPC) lets you provision a logically isolated section of the AWS Cloud where you can launch AWS resources
in a virtual network that you define.
This identifies changes to Amazon VPC (Virtual Private Cloud) settings such as new ACL entries,routes, routetable or Gateways.
More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255 
and AWS VPC API Docs: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/OperationList-query-vpc.html'
",AWS,AWSCloudTrail,"
let timeframe = 1d;
let EventNameList = dynamic([""CreateNetworkAclEntry"",""CreateRoute"",""CreateRouteTable"",""CreateInternetGateway"",""CreateNatGateway""]);
AWSCloudTrail
| where TimeGenerated > ago(timeframe)
| where EventName in~ (EventNameList)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ChangeToVPC.yaml,2020-10-04,AWS_ChangeToVPC.yaml
2954d424-f786-4677-9ffc-c24c44c6e7d5,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,SaaS,Detection,Azure Sentinel Community Github,User Login from Different Countries within 3 hours,"'This query searches for successful user logins to the Okta Console from different countries within 3 hours'
",OktaSSO,Okta_CL,"
let timeframe = ago(3h);
let threshold = 2;
Okta_CL
| where published_t >= timeframe
| where eventType_s =~ ""user.session.start""
| where outcome_result_s =~ ""SUCCESS""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumOfCountries = dcount(client_geographicalContext_country_s) by actor_alternateId_s
| where NumOfCountries >= threshold
| extend timestamp = StartTime, AccountCustomEntity = actor_alternateId_s
",1h,1h,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OktaSSO/LoginfromUsersfromDifferentCountrieswithin3hours.yaml,2020-10-04,LoginfromUsersfromDifferentCountrieswithin3hours.yaml
2b6a3882-d601-4298-983b-880f6dc7acdb,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,SaaS,Hunting Query,Azure Sentinel Community Github,User Granted Access and Grants others Access,"'Identifies when a new user is granted access and starts granting access to other users.  This can help you identify rogue or malicious user behavior.'
",AzureActivity,AzureActivity,"let auditLookback = 14d;
let opName = dynamic([""Add user"", ""Invite external user""]);
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | where OperationName in~ (operation)
    | extend ModProps = iff(TargetResources.[0].modifiedProperties != ""[]"", TargetResources.[0].modifiedProperties, todynamic(""NoValues""))
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend InitiatedBy = replace(""_"",""@"",tostring(split(InitiatedByFull, ""#"")[0]))
    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetResourceName = case(
    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,
    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith ""upn:"", tolower(tostring(TargetResources.[0].displayName)),
    tolower(tostring(TargetResources.[0].displayName))
    )
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, "","")[0], "" "")[1]), TargetUserName ) 
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
// Assigning time for First TargetUserName that was added
let FirstAdd = auditLogEvents(auditLookback, opName)  
| project FirstAddTimeUtc = TimeGenerated, Type, FirstInitiatedBy = InitiatedBy, IpAddress, FirstTargetUserName = TargetUserName, FirstTargetResourceName = TargetResourceName, 
FirstOperationName = OperationName, FirstPropertyName = PropertyName, FirstnewValue = newValue, FirstCorrelationId = CorrelationId, FirstId = Id;
// Assigning time for second TargetUserName that was added, which will allow us to see if a first TargetUserName added in is the Initiated by on the second in the later join
let SecondAdd = auditLogEvents(auditLookback, opName)  
| project SecondAddTimeUtc = TimeGenerated, Type, SecondInitiatedBy = InitiatedBy, IpAddress, SecondTargetUserName = TargetUserName, SecondTargetResourceName = TargetResourceName, 
SecondOperationName = OperationName, SecondPropertyName = PropertyName, SecondnewValue = newValue, SecondCorrelationId = CorrelationId, SecondId = Id;
//  Joining the FirstAdd with SecondAdd where the FirstAdd TargetUserName value matches the SecondAdd InitiatedBy.  This shows the new user adding a user.
let NewUserAddsUser = FirstAdd | join SecondAdd on $left.FirstTargetUserName == $right.SecondInitiatedBy
// we only want items where the FirstAddTimeUtc is before the SecondAddTimeUtc
| where FirstAddTimeUtc < SecondAddTimeUtc
;
// Build out some of the properties for context
NewUserAddsUser
| extend FirstnewValue = split(FirstnewValue, "";""), SecondnewValue = split(SecondnewValue, "";"")
| extend PropertyUpdate = pack(FirstPropertyName, FirstnewValue, SecondPropertyName, SecondnewValue, ""FirstCorrelationId"", FirstCorrelationId, ""FirstId"", FirstId, ""SecondCorrelationId"", SecondCorrelationId, ""SecondId"", SecondId)
| summarize PropertyUpdateSet = make_bag(PropertyUpdate) by FirstAddTimeUtc, FirstInitiatedBy, FirstTargetUserName, SecondAddTimeUtc, SecondInitiatedBy, SecondTargetUserName, 
IpAddress, FirstTargetResourceName, SecondTargetResourceName, FirstOperationName, SecondOperationName
| extend timestamp = FirstAddTimeUtc, AccountCustomEntity = FirstInitiatedBy, HostCustomEntity = FirstTargetResourceName, IPCustomEntity = IpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/UserGrantedAccess_GrantsOthersAccess.yaml,2020-10-04,UserGrantedAccess_GrantsOthersAccess.yaml
562900b1-39c4-4baf-a050-9cad1641db35,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,Failed Login Attempt by Expired account,"'This query looks at Account Logon events found through Windows Event Id's as well as SigninLogs to discover 
login attempts by accounts that have expired.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
(union isfuzzy=true
(SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4625
//4625: An account failed to log on
| where AccountType == 'User' 
| where SubStatus == '0xc0000193' 
| extend Reason = 
case
( SubStatus == '0xc0000193', 'Windows EventID (4625) - Account has expired', ""Unknown"")
| project Computer, Account,  Reason , TimeGenerated
),
(
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4769
//4769: A Kerberos service ticket was requested ( Kerberos Auth)
| parse EventData with * 'Status"">' Status ""<"" *
| parse EventData with * 'TargetUserName"">' TargetUserName ""<"" *
| where Status == '0x12'
| where TargetUserName !has ""$"" and isnotempty(TargetUserName)
| extend Reason = 
case(
Status == '0x12', 'Windows EventID (4769) - Account disabled, expired, locked out',
'Unknown'), Account = TargetUserName 
| project Computer, Account, Reason , TimeGenerated
),
(
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4776 
// 4776: The domain controller attempted to validate the credentials for an account ( NTLM Auth)
| where Status == ""0xc0000193""
| extend Reason = 
case(
ErrorCode == '0xc0000193', 'Windows EventID (4776) - Account has expired',
'Unknown'), Account = TargetAccount 
| parse EventData with * 'Workstation"">' Workstation ""<"" *
| extend Workstation = trim_start(@""[\\]*"", Workstation)
| extend Computer = iff(isnotempty(Workstation), Workstation, Computer ) 
| project Computer, Account, Reason , TimeGenerated
) ,
(
SigninLogs
| where TimeGenerated >= ago(timeframe) 
| where ResultType == ""50057"" 
| extend Reason = 
case(
ResultType == '50057', 'SigninLogs( Result Code- 50057) - User account is disabled. The account has been disabled by an administrator.',
'Unknown'), Account = UserPrincipalName 
| project Computer, Account, Reason , TimeGenerated
) )
| summarize StartTimeUtc = min(TimeGenerated), EndTImeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, Reason
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer
| order by EventCount desc 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/LogonwithExpiredAccount.yaml,2020-10-04,LogonwithExpiredAccount.yaml
bac44fe4-c0bc-4e90-aa48-2e346fda803f,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Tracking Password Changes,"'Identifies when a password change or reset occurs across multiple host and cloud based sources. 
Account manipulation including password changes and resets may aid adversaries in maintaining access to credentials 
and certain permission levels within an environment.'
",AzureActiveDirectory,SigninLogs,"
let timeframe = 7d;
let action = dynamic([""change "", ""changed "", ""reset ""]);
let pWord = dynamic([""password "", ""credentials ""]);
(union isfuzzy=true
  (SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID in (4723,4724)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(Activity), ActionCount = count() by Resource = Computer, OperationName = strcat(""TargetAccount: "", TargetUserName), UserId = Account, Type
),
(AuditLogs
| where TimeGenerated >= ago(timeframe)
| where OperationName has_any (pWord) and OperationName has_any (action)
| extend InitiatedBy = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName) 
| extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName) 
| where ResultDescription != ""None"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(ResultDescription), CorrelationIds = makeset(CorrelationId), ActionCount = count() by OperationName = strcat(Category, "" - "", OperationName, "" - "", Result), Resource, UserId = TargetUserPrincipalName, Type
| extend ResultDescriptions = tostring(ResultDescriptions)
),
(OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where (ExtendedProperties has_any (pWord) or ModifiedProperties has_any (pWord)) and (ExtendedProperties has_any (action) or ModifiedProperties has_any (action))
| extend ResultDescriptions = case(
OfficeWorkload =~ ""AzureActiveDirectory"", tostring(ExtendedProperties),
OfficeWorkload has_any (""Exchange"",""OneDrive""), OfficeObjectId,
RecordType) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(ResultDescriptions), ActionCount = count() by Resource = OfficeWorkload, OperationName = strcat(Operation, "" - "", ResultStatus), IPAddress = ClientIP, UserId, Type
),
(Syslog
| where TimeGenerated >= ago(timeframe)
| where SyslogMessage has_any (pWord) and SyslogMessage has_any (action)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(SyslogMessage), ActionCount = count() by Resource = HostName, OperationName = Facility , IPAddress = HostIP, ProcessName, Type
),
(SigninLogs
| where TimeGenerated >= ago(timeframe)
| where OperationName =~ ""Sign-in activity"" and ResultType has_any (""50125"", ""50133"")
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(ResultDescription), CorrelationIds = makeset(CorrelationId), ActionCount = count() by Resource, OperationName = strcat(OperationName, "" - "", ResultType), IPAddress, UserId = UserPrincipalName, Type
)
)
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = IPAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/TrackingPasswordChanges.yaml,2020-10-04,TrackingPasswordChanges.yaml
2e20ec77-8d50-4959-a70d-79c341ee2c37,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous Login to Devices,"'Adversaries may steal the credentials of a specific user or service account using Credential Access techniques or capture credentials earlier in their reconnaissance process through social engineering for means of gaining Initial Access. APT33, for example, has used valid accounts for initial access and privilege escalation. The query below generates an output of all administator users performing an interactive logon (4624:2) where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,BehaviorAnalytics,"
BehaviorAnalytics
| where UsersInsights.IsDormantAccount == true
| where DevicesInsights.IsLocalAdmin == true
| where ActivityType == ""LogOn""
| where ActionType == ""InteractiveLogon""
| where ActivityInsights contains ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Login%20to%20Devices.yaml,2020-10-04,Anomalous%20Login%20to%20Devices.yaml
eeea7fb9-21cf-4023-91dc-3f55d7548d14,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Anomalous Geo Location Logon,"'Adversaries may steal the credentials of a specific user or service account using Credential Access techniques or capture credentials earlier in their reconnaissance process through social engineering for means of gaining Initial Access. APT33, for example, has used valid accounts for initial access. The query below generates an output of successful Sign-in performed by a user from a new geo location he has never connected from before, and none of his peers as well.'
",BehaviorAnalytics,SigninLogs,"
BehaviorAnalytics
| where ActionType == ""Sign-in""
| where ActivityInsights.FirstTimeConnectionFromCountryObservedInTenant == True and ActivityInsights.CountryUncommonlyConnectedFromAmongPeers == True
    | join (
SigninLogs
) on $left.SourceRecordId == $right._ItemId
| extend UserPrincipalName = iff(UserPrincipalName contains ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserPrincipalName),
UserName = iff(UserName contains ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserName)
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,[""Evidence""]=ActivityInsights, ResourceDisplayName,AppDisplayName ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Geo%20Location%20Logon.yaml,2020-10-04,Anomalous%20Geo%20Location%20Logon.yaml
bb3bb9da-9598-4d1f-af78-7cc2fd413b0b,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Anomalous Sign-in Activity,"'Adversaries may steal the credentials of a specific user or service account using Credential Access techniques or capture credentials earlier in their reconnaissance process through social engineering for means of gaining Persistence. Umbreon, for example, creates valid users to provide access to the system.
The query below generates an output of successful Sign-in with one or more of the following indications:
- performed by new or recently dormant accounts
- where one or more features of the activitiy deviates from the user, his peers or the tenant profile
- performed by a user with Risk indicaiton from AAD'
",BehaviorAnalytics,SigninLogs,"
BehaviorAnalytics
| where ActionType == ""Sign-in""
| where UsersInsights.IsNewAccount == True or UsersInsights.IsDormantAccount == True or ActivityInsights has ""True""
| join (
SigninLogs | where Status.errorCode == 0 or Status.errorCode == 0 and RiskDetail != ""none""
) on $left.SourceRecordId == $right._ItemId
| extend UserPrincipalName = iff(UserPrincipalName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserPrincipalName),
UserName = iff(UserName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserName)
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,[""Evidence""]=ActivityInsights, ResourceDisplayName,AppDisplayName,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Sign-in%20Activity.yaml,2020-10-04,Anomalous%20Sign-in%20Activity.yaml
42ae9690-89ce-4063-9a90-465badad5395,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,User created by unauthorized user,"'User account created by an unauthorized user, pass in a list'
",SecurityEvents,SecurityEvent,"
// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain
let List = datatable(AuthorizedUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN""];
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4720
| where AccountType == ""User""
| join kind= leftanti (
    List
    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)
) on SubjectUserName, SubjectDomainName
| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserCreatedByUnauthorizedUser.yaml,2020-10-04,UserCreatedByUnauthorizedUser.yaml
6135a90e-ba30-4f36-9b6a-3a350050704b,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,Long lookback User Account Created and Deleted within 10mins,"'User account created and then deleted within 10 minutes across last 14 days'
",SecurityEvents,SecurityEvent,"
// TimeFrame is the number of lookback days, default is last 14 days
let timeframe = 14d;
// TimeDelta is the difference between when the account was created and when it was deleted, default is set to 10min or less
let timedelta = 10m;
SecurityEvent 
| where TimeGenerated > ago(timeframe) 
// A user account was created
| where EventID == ""4720""
| where AccountType == ""User""
| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid 
| join kind= inner (
   SecurityEvent
   | where TimeGenerated > ago(timeframe) 
   // A user account was deleted 
   | where EventID == ""4726"" 
| where AccountType == ""User""
| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid 
) on Computer, TargetUserName
| where deletionTime - creationTime < timedelta
| extend TimeDelta = deletionTime - creationTime
| where tolong(TimeDelta) >= 0
| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, 
deletionTime, DeleteEventID, AccountUsedToDelete
| extend timestamp = creationTime, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserAccountCreatedDeleted.yaml,2020-10-04,UserAccountCreatedDeleted.yaml
8d69a665-074a-443b-aae6-5dd9bdd5cfb1,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,User Account added to Built in Domain Local or Global Group,"'User account was added to a privileged built in domain local group or global group such as the Enterprise Adminis, Cert Publishers or DnsAdmins
Be sure to verify this is an expected addition.'
",SecurityEvents,SecurityEvent,"
let timeframe = 10d;
// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$"";
SecurityEvent 
| where TimeGenerated > ago(timeframe) 
| where AccountType == ""User""
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group
| where EventID in (""4728"", ""4732"", ""4756"")   
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| project StartTimeUtc = TimeGenerated, EventID, Activity, Computer, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid 
| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserAccountAddedToPrivlegeGroup.yaml,2020-10-04,UserAccountAddedToPrivlegeGroup.yaml
e7bfbc3f-98c7-4aaa-a64c-de9c058b86b2,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,Suspicious Windows Login outside normal hours,"Looking for suspiciopus interactive logon events which are outside normal logon hours for the user. Current day logon events are comapred with last 14 days activity 
and filtered for events which are above or below of historical logon hour range seen for the user.
",SecurityEvents,SecurityEvent,"let v_StartTime = 14d;
let v_EndTime = 2d;
let lookback = 1d;
let AllLogonEvents = materialize(
SecurityEvent
| where TimeGenerated  between (ago(v_StartTime)..ago(v_EndTime))
| where EventID in (4624, 4625)
| where LogonTypeName in~ ('2 - Interactive','10 - RemoteInteractive')
| where AccountType =~ 'User'
| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)
| extend DayofWeek = case(
DayNumberofWeek == ""00:00:00"", ""Sunday"", 
DayNumberofWeek == ""1.00:00:00"", ""Monday"", 
DayNumberofWeek == ""2.00:00:00"", ""Tuesday"", 
DayNumberofWeek == ""3.00:00:00"", ""Wednesday"", 
DayNumberofWeek == ""4.00:00:00"", ""Thursday"", 
DayNumberofWeek == ""5.00:00:00"", ""Friday"", 
DayNumberofWeek == ""6.00:00:00"", ""Saturday"",""InvalidTimeStamp"")
// map the most common ntstatus codes
| extend StatusDesc = case(
Status =~ ""0x80090302"", ""SEC_E_UNSUPPORTED_FUNCTION"",
Status =~ ""0x80090308"", ""SEC_E_INVALID_TOKEN"",
Status =~ ""0x8009030E"", ""SEC_E_NO_CREDENTIALS"",
Status =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
Status =~ ""0xC0000017"", ""STATUS_NO_MEMORY"",
Status =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
Status =~ ""0xC0000034"", ""STATUS_OBJECT_NAME_NOT_FOUND"",
Status =~ ""0xC000005E"", ""STATUS_NO_LOGON_SERVERS"",
Status =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
Status =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
Status =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
Status =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
Status =~ ""0xC00000FE"", ""STATUS_NO_SUCH_PACKAGE"",
Status =~ ""0xC000009A"", ""STATUS_INSUFFICIENT_RESOURCES"",
Status =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
Status =~ ""0xC0000106"", ""STATUS_NAME_TOO_LONG"",
Status =~ ""0xC000010B"", ""STATUS_INVALID_LOGON_TYPE"",
Status =~ ""0xC000015B"", ""STATUS_LOGON_TYPE_NOT_GRANTED"",
Status =~ ""0xC000018B"", ""STATUS_NO_TRUST_SAM_ACCOUNT"",
Status =~ ""0xC0000224"", ""STATUS_PASSWORD_MUST_CHANGE"",
Status =~ ""0xC0000234"", ""STATUS_ACCOUNT_LOCKED_OUT"",
Status =~ ""0xC00002EE"", ""STATUS_UNFINISHED_CONTEXT_DELETED"",
EventID == 4624, ""Success"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| extend SubStatusDesc = case(
SubStatus =~ ""0x80090325"", ""SEC_E_UNTRUSTED_ROOT"",
SubStatus =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
SubStatus =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
SubStatus =~ ""0xC0000064"", ""STATUS_NO_SUCH_USER"",
SubStatus =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
SubStatus =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
SubStatus =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
SubStatus =~ ""0xC000006F"", ""STATUS_INVALID_LOGON_HOURS"",
SubStatus =~ ""0xC0000070"", ""STATUS_INVALID_WORKSTATION"",
SubStatus =~ ""0xC0000071"", ""STATUS_PASSWORD_EXPIRED"",
SubStatus =~ ""0xC0000072"", ""STATUS_ACCOUNT_DISABLED"",
SubStatus =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
SubStatus =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
SubStatus =~ ""0xC0000133"", ""STATUS_TIME_DIFFERENCE_AT_DC"",
SubStatus =~ ""0xC000018D"", ""STATUS_TRUSTED_RELATIONSHIP_FAILURE"",
SubStatus =~ ""0xC0000193"", ""STATUS_ACCOUNT_EXPIRED"",
SubStatus =~ ""0xC0000380"", ""STATUS_SMARTCARD_WRONG_PIN"",
SubStatus =~ ""0xC0000381"", ""STATUS_SMARTCARD_CARD_BLOCKED"",
SubStatus =~ ""0xC0000382"", ""STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED"",
SubStatus =~ ""0xC0000383"", ""STATUS_SMARTCARD_NO_CARD"",
SubStatus =~ ""0xC0000384"", ""STATUS_SMARTCARD_NO_KEY_CONTAINER"",
SubStatus =~ ""0xC0000385"", ""STATUS_SMARTCARD_NO_CERTIFICATE"",
SubStatus =~ ""0xC0000386"", ""STATUS_SMARTCARD_NO_KEYSET"",
SubStatus =~ ""0xC0000387"", ""STATUS_SMARTCARD_IO_ERROR"",
SubStatus =~ ""0xC0000388"", ""STATUS_DOWNGRADE_DETECTED"",
SubStatus =~ ""0xC0000389"", ""STATUS_SMARTCARD_CERT_REVOKED"",
EventID == 4624, ""Success"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| project StartTime = TimeGenerated, DayofWeek, HourOfLogin, EventID, Activity, IpAddress, WorkstationName, Computer, TargetUserName, TargetDomainName, ProcessName, SubjectUserName, PrivilegeList, LogonTypeName, StatusDesc, SubStatusDesc
);
AllLogonEvents
| where TargetDomainName !in (""Window Manager"",""Font Driver Host"")
| summarize max(HourOfLogin), min(HourOfLogin), historical_DayofWeek=make_set(DayofWeek) by TargetUserName
| join kind= inner
(
    AllLogonEvents
    | where StartTime > ago(lookback)
)
on TargetUserName
// Filtering for logon events based on range of max and min of historical logon hour values seen
| where HourOfLogin > max_HourOfLogin or HourOfLogin < min_HourOfLogin
// Also populating additional column showing historical days of week when logon was seen
| extend historical_DayofWeek = tostring(historical_DayofWeek)
| summarize Total= count(), max(HourOfLogin), min(HourOfLogin), current_DayofWeek =make_set(DayofWeek), StartTime=max(StartTime), EndTime = min(StartTime), SourceIP = make_set(IpAddress), SourceHost = make_set(WorkstationName), SubjectUserName = make_set(SubjectUserName), HostLoggedOn = make_set(Computer) by EventID, Activity, TargetDomainName, TargetUserName , ProcessName , LogonTypeName, StatusDesc, SubStatusDesc, historical_DayofWeek
| extend historical_DayofWeek = todynamic(historical_DayofWeek) 
| extend timestamp = StartTime, AccountCustomEntity = TargetUserName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Suspicious_Windows_Login_outside_normal_hours.yaml,2020-10-04,Suspicious_Windows_Login_outside_normal_hours.yaml
d57f675c-ad6c-44d0-95fb-3bf707e70155,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,User account added or removed from a security group by an unauthorized user,"'User account added or removed from a security group by an unauthorized user, pass in a list'
",SecurityEvents,SecurityEvent,"
// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain
let List = datatable(AuthorizedUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN""];
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID in (4728, 4729, 4732, 4733, 4746, 4747, 4751, 4752, 4756, 4757, 4761, 4762)
| join kind= leftanti (
    List
    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)
) on SubjectUserName, SubjectDomainName
| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserAdd_RemToGroupByUnauthorizedUser.yaml,2020-10-04,UserAdd_RemToGroupByUnauthorizedUser.yaml
cb47a115-2616-4d56-890d-b28c14bc83e4,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Windows,Hunting Query,Azure Sentinel Community Github,Group added to Built in Domain Local or Global Group,"'A Group created in the last 7 days was added to a privileged built in domain local group or global group such as the 
Enterprise Admins, Cert Publishers or DnsAdmins.  Be sure to verify this is an expected addition'
",SecurityEvents,SecurityEvent,"
let timeframe = 7d;
// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
// The SIDs for DnsAdmins and DnsUpdateProxy can be different than *-1102 and -*1103. Check these SIDs in your domain before running the query 
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$"";
let GroupAddition = SecurityEvent 
| where TimeGenerated > ago(timeframe)
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group  
| where EventID in (""4728"", ""4732"", ""4756"") 
| where AccountType == ""User"" and MemberName == ""-""
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, 
GroupAddTargetUserName = TargetUserName, GroupAddTargetDomainName = TargetDomainName, GroupAddTargetSid = TargetSid,  
GroupAddSubjectUserName = SubjectUserName, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid, Account, Computer
| extend AccountCustomEntity = Account, HostCustomEntity = Computer;
let GroupCreated = SecurityEvent
| where TimeGenerated > ago(timeframe)
// 4727 - A security-enabled global group was created
// 4731 - A security-enabled local group was created
// 4754 - A security-enabled universal group was created
| where EventID in (""4727"", ""4731"", ""4754"")
| where AccountType == ""User""
| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, 
GroupCreateTargetUserName = TargetUserName, GroupCreateTargetDomainName = TargetDomainName, GroupCreateSubjectUserName = SubjectUserName, 
GroupCreateSubjectDomainName = SubjectDomainName, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid, Account, Computer;
GroupCreated
| join (
GroupAddition
) on GroupSid
| extend timestamp = GroupCreateTime, AccountCustomEntity = Account, HostCustomEntity = Computer
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/GroupAddedToPrivlegeGroup.yaml,2020-10-04,GroupAddedToPrivlegeGroup.yaml
8159c663-6724-41b8-9ae8-b328aa8d0c4c,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Anomalous sign-in location by user account and authenticating application,"'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
Directory application and picks out the most anomalous change in location profile for a user within an 
individual application. The intent is to hunt for user account compromise, possibly via a specific application
vector.'
",AzureActiveDirectory,SigninLogs,"
let timeRange=ago(14d);
SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| where TimeGenerated >= timeRange
| extend  locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName, UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeRange,now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare, Slope, Variance, RVariance, Interception, LineFit) = series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc
| extend AccountCustomEntity = UserPrincipalName 
| render timechart
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AnomalousUserAppSigninLocationIncrease.yaml,2020-10-04,AnomalousUserAppSigninLocationIncrease.yaml
847c2652-547d-4d5f-9b71-d2f8d81eac62,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Inactive or new account signins,"'Query for accounts seen signing in for the first time - these could be associated
with stale/inactive accounts that ought to have been deleted but weren't - and have 
subseuqently been compromised. 
Results for user accounts created in the last 7 days are filtered out'
",AzureActiveDirectory,SigninLogs,"
//Inactive accounts that sign in - first-time logins for accounts created in last 7 days are filtered out
let starttime = 14d;
let midtime = 7d;
let endtime = 1d;
SigninLogs
| where TimeGenerated >= ago(endtime)
// successful sign-in
| where ResultType == 0
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), loginCountToday=count() by UserPrincipalName, Identity
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated < ago(endtime)
   | where TimeGenerated >= ago(starttime)
   | where ResultType == 0
   | summarize by UserPrincipalName, Identity
) on UserPrincipalName 
| join kind= leftanti (
   // filter out newly created user accounts
   AuditLogs
   | where TimeGenerated >= ago(midtime)
   | where OperationName == ""Add user"" 
   // Normalize to lower case in order to match against equivalent UPN in Signin logs
   | extend NewUserPrincipalName = tolower(extractjson(""$.userPrincipalName"", tostring(TargetResources[0]), typeof(string)))
) on $left.UserPrincipalName == $right.NewUserPrincipalName 
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml,2020-10-04,InactiveAccounts.yaml
7f6e8f14-62fa-4ce6-a490-c07f1d9888ba,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Anomalous sign-in location by user account and authenticating application - with sign-in details,"'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
Directory application and picks out the most anomalous change in location profile for a user within an 
individual application. The intent is to hunt for user account compromise, possibly via a specific application
vector.
This variation of the query joins the results back onto the original sign-in data to allow review of the 
location set with each identified user in tabular form.'
",AzureActiveDirectory,SigninLogs,"
let timeRange = ago(14d);
SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| where TimeGenerated >= timeRange
| extend  locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeRange,now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc  
// Extract the set of locations for each top user:
| join kind=inner (SigninLogs
| where TimeGenerated >= timeRange
| extend  locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"")
| summarize locationList = makeset(locationString), threeDayWindowLocationCount=dcount(locationString) by AppDisplayName, UserPrincipalName, 
timerange=bin(TimeGenerated, 3d)) on AppDisplayName, UserPrincipalName
| order by UserPrincipalName, timerange asc
| project timerange, AppDisplayName , UserPrincipalName, threeDayWindowLocationCount, locationList 
| order by AppDisplayName, UserPrincipalName, timerange asc
| extend timestamp = timerange, AccountCustomEntity = UserPrincipalName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AnomalousUserAppSigninLocationIncreaseDetail.yaml,2020-10-04,AnomalousUserAppSigninLocationIncreaseDetail.yaml
cf83633e-5dfd-4887-993b-c910452439da,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Failed attempt to access Azure Portal,"'Access attempts to Azure Portal from an unauthorized user.  Either invalid password or the user account does not exist.'
",AzureActiveDirectory,SigninLogs,"
let timeRange=ago(7d);
SigninLogs
| where TimeGenerated >= timeRange
| where AppDisplayName contains ""Azure Portal""
// 50126 - Invalid username or password, or invalid on-premises username or password.
// 50020? - The user doesn't exist in the tenant.
| where ResultType in ( ""50126"" , ""50020"")
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), IPAddresses = makeset(IPAddress), DistinctIPCount = dcount(IPAddress), 
makeset(OS), makeset(Browser), makeset(City), AttemptCount = count() 
by UserDisplayName, UserPrincipalName, AppDisplayName, ResultType, ResultDescription, StatusCode, StatusDetails, Location, State
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName
| sort by AttemptCount
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UnauthUser_AzurePortal.yaml,2020-10-04,UnauthUser_AzurePortal.yaml
b00f127c-46fa-40bd-9ab6-b266974d29cc,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Attempts to sign in to disabled accounts by account name,"'Failed attempts to sign in to disabled accounts summarized by account name'
",AzureActiveDirectory,SigninLogs,"
let timeRange = 14d;
SigninLogs 
| where TimeGenerated >= ago(timeRange)
| where ResultType == ""50057"" 
| where ResultDescription == ""User account is disabled. The account has been disabled by an administrator."" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by AppDisplayName, UserPrincipalName
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName
| order by count_ desc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/DisabledAccountSigninAttempts.yaml,2020-10-04,DisabledAccountSigninAttempts.yaml
41fa6e2d-afe9-4398-9356-cec3a927e44e,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Azure Active Directory signins from new locations,"'New Azure Active Directory signin locations today versus historical Azure Active Directory signin data
In the case of password spraying or brute force attacks one might see authentication attempts for many 
accounts from a new location'
",AzureActiveDirectory,SigninLogs,"
let starttime = 14d;
let endtime = 1d;
let countThreshold = 1;
SigninLogs
| where TimeGenerated >= ago(endtime)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), perIdentityAuthCount = count() 
by Identity, locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", 
tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""]))
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), distinctAccountCount = count(), identityList=makeset(Identity) by locationString
| extend identityList = iff(distinctAccountCount<10, identityList, ""multiple (>10)"")
| join kind= anti (
SigninLogs
  | where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)
  | project locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", 
  tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""]))
  | summarize priorCount = count() by locationString
) 
on locationString
// select threshold above which #new accounts from a new location is deemed suspicious
| where distinctAccountCount > countThreshold
| extend timestamp = StartTimeUtc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/new_locations_azuread_signin.yaml,2020-10-04,new_locations_azuread_signin.yaml
73ac88c0-f073-4b23-8ac4-9f40ea11308d,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Anomalous Azure Active Directory apps based on authentication location,"'This query over Azure AD sign-in activity highlights Azure AD apps with 
an unusually high ratio of distinct geolocations versus total number of authentications'
",AzureActiveDirectory,SigninLogs,"
let timeRange=ago(14d);
let azureSignIns = 
SigninLogs
| where TimeGenerated >= timeRange
| where SourceSystem == ""Azure AD""
| where OperationName == ""Sign-in activity""
| project TimeGenerated, OperationName, AppDisplayName , Identity, UserId, UserPrincipalName, Location, LocationDetails, 
ClientAppUsed, DeviceDetail, ConditionalAccessPolicies;
azureSignIns
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""]))
| summarize rawSigninCount = count(), countByAccount = dcount(UserId), locationCount = dcount(locationString) by AppDisplayName
// tail - pick a threshold to rule out the very-high volume Azure AD apps
| where rawSigninCount < 1000
// more locations than accounts
| where locationCount>countByAccount
// almost as many / more locations than sign-ins!
| where 1.0*rawSigninCount / locationCount > 0.8 
| order by rawSigninCount  desc
| join kind = leftouter (
   azureSignIns 
) on AppDisplayName 
| project AppDisplayName, TimeGenerated , Identity, rawSigninCount, countByAccount, locationCount,  
locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", 
tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""])), UserPrincipalName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName 
| order by AppDisplayName, TimeGenerated desc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/anomalous_app_azuread_signin.yaml,2020-10-04,anomalous_app_azuread_signin.yaml
b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Login attempts using Legacy Auth,"'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the 
environment. Because conditional access policies are not evaluated when legacy authentication is used, 
legacy authentication can be used to circumvent all Azure Conditional Access policies.'
",AzureActiveDirectory,SigninLogs,"
let endtime = 1d;
let starttime = 7d;
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(starttime)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,""Unknown"" ,ClientAppUsed)
| extend isLegacyAuth = case(
ClientAppUsed contains ""Browser"", ""No"", 
ClientAppUsed contains ""Mobile Apps and Desktop clients"", ""No"", 
ClientAppUsed contains ""Exchange ActiveSync"", ""No"", 
ClientAppUsed contains ""Other clients"", ""Yes"", 
""Unknown"")
| where isLegacyAuth==""Yes"";
legacyAuthentications 
| where TimeGenerated >= ago(endtime)
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications 
   | where TimeGenerated between(ago(starttime) .. ago(endtime))
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), AttemptCount = count() 
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last 
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml,2020-10-04,LegacyAuthAttempt.yaml
75fd68a2-9ed4-4a1c-8bd7-18efe4c99081,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Login attempt by Blocked MFA user,"'An account could be blocked if there are too many failed authentication attempts in a row. This hunting query identifies if a MFA user account that is set to blocked tries to login to Azure AD.'
",AzureActiveDirectory,SigninLogs,"let timeRange = 1d;
let lookBack = 7d;
let isGUID = ""[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}"";
let MFABlocked = SigninLogs
| where TimeGenerated >= ago(timeRange)
| where ResultType != ""0"" 
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), Status = strcat(ResultType, "": "", ResultDescription)
| where StatusDetails =~ ""MFA denied; user is blocked""
| extend Unresolved = iff(Identity matches regex isGUID, true, false);
// Lookup up resolved identities from last 7 days
let identityLookup = SigninLogs
| where TimeGenerated >= ago(lookBack)
| where not(Identity matches regex isGUID)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// Join resolved names to unresolved list from MFABlocked signins
let unresolvedNames = MFABlocked | where Unresolved == true | join kind= inner (
 identityLookup 
) on UserId
| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName
| project-away lu_UserDisplayName, lu_UserPrincipalName;
// Join Signins that had resolved names with list of unresolved that now have a resolved name
let u_MFABlocked = MFABlocked | where Unresolved == false | union unresolvedNames;
u_MFABlocked 
| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), 
  AttemptCount = count() by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation , CorrelationId 
| mvexpand TimeGenerated, IPAddresses, Status
| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)
| project-away IPAddresses
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status,  IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/MFAUserBlocked.yaml,2020-10-04,MFAUserBlocked.yaml
0cd51b2e-d3b2-4001-8e3f-5cbb604f69b2,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,Azure AD,Hunting Query,Azure Sentinel Community Github,Attempts to sign in to disabled accounts by IP address,"'Failed attempts to sign in to disabled accounts summarized by the IP address from from the sign-in attempts originate'
",AzureActiveDirectory,SigninLogs,"
let timeRange = 14d;
SigninLogs 
| where TimeGenerated >= ago(timeRange)
| where ResultType == ""50057"" 
| where ResultDescription == ""User account is disabled. The account has been disabled by an administrator."" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), numberAccountsTargeted = dcount(UserPrincipalName), 
numberApplicationsTargeted = dcount(AppDisplayName), accountSet = makeset(UserPrincipalName), applicationSet=makeset(AppDisplayName), 
numberLoginAttempts = count() by IPAddress
| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress
| order by numberLoginAttempts desc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/DisabledAccountSigninAttemptsByIP.yaml,2020-10-04,DisabledAccountSigninAttemptsByIP.yaml
70078743-eb45-4e44-b7e4-c8f904e6c441,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,Office 365,Hunting Query,Azure Sentinel Community Github,User made Owner of multiple teams,"'This hunting query identifies users who have been made Owner of multiple Teams.
 This query is works with the built-in Teams data connector only.'
",Office365,OfficeActivity,"
// Adjust this value to change how many teams a user is made owner of before detecting
let max_owner_count = 3;
// Change this value to adjust how larger timeframe the query is run over.
let time_window = 1d;
let high_owner_count = (OfficeActivity
| where TimeGenerated > ago(time_window)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation =~ ""MemberRoleChanged""
| extend Member = tostring(Members[0].UPN) 
| extend NewRole = toint(Members[0].Role) 
| where NewRole == 2
| summarize dcount(TeamName) by Member
| where dcount_TeamName > max_owner_count
| project Member);
OfficeActivity
| where TimeGenerated > ago(time_window)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation =~ ""MemberRoleChanged""
| extend Member = tostring(Members[0].UPN) 
| extend NewRole = toint(Members[0].Role) 
| where NewRole == 2
| where Member in (high_owner_count)
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = TimeGenerated, AccountCustomEntity = Member
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Teams/MultiTeamOwner.yaml,2020-10-04,MultiTeamOwner.yaml
363ea6d1-b30d-4a44-b56a-63c3c8a99621,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,User added to SQL Server SecurityAdmin Group,"This hunting query identifies user added in the SecurityAdmin group of SQL Server
This query is based on the SQLEvent KQL Parser function (link below)
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// This query tracks user added into SecurityAdmingroup
SQLEvent
| where TimeGenerated >= ago(1d)
| where Statement has ""Alter Server role"" and Statement has ""add member""
| parse Statement with * ""ADD MEMBER ["" TargetUser:string ""]"" *
| where ObjectName has ""securityadmin""
| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement 
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserAdded_to_SecurityAdmin.yaml,2020-10-04,SQL-UserAdded_to_SecurityAdmin.yaml
80a420b3-6a97-4b8f-9d86-4b43ee522fb2,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,User Role altered on SQL Server,"This hunting query identifies user role altered on SQL Server
This query is based on the SQLEvent KQL Parser function (link below) 
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// This query looking for Alter role commands and extracts username which was altered and target objectName
SQLEvent
| where TimeGenerated >= ago(1d)
| where Statement contains ""Alter role"" and Statement has ""add member""
| parse Statement with * ""ADD MEMBER ["" TargetUser:string ""]"" *
| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserRoleChanged.yaml,2020-10-04,SQL-UserRoleChanged.yaml
5b6ee21d-da53-46eb-827c-eab2a9ba3d2f,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1078,Valid Accounts,AWS,Hunting Query,Azure Sentinel Community Github,Suspicious credential token access of valid IAM Roles,"'Adversaries may generate temporary credentials of existing privileged IAM roles to access AWS resources that were not previously accessible to perform malicious actions. The credentials may be generated by trusted IAM user or via AWS Cloud Instance Metadata API.
This query will look for AWS STS API Assume Role operations for RoleArn (Role Amazon Resource Names) which was not historically seen.
You can also limit the query to only sensitive IAM Roles which needs to be monitored.
Read more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash 
AWS API AssumeRole at https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html and AWS Instance Metadata API at https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html '
",AWS,AWSCloudTrail,"
let starttime = 14d;
let midtime = 2d;
let endtime = 1d;
// Generating historical table of AssumeRole operations for IAM Roles to be compared with last 24 hour
AWSCloudTrail
| where TimeGenerated >= ago(endtime)
| where EventName == ""AssumeRole"" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)
| project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn
// Doing Leftanti join to find new AssumeRole operation for IAM role which was not seen historically generated from previous table.
| join kind= leftanti
(
  AWSCloudTrail
  | where TimeGenerated  between (ago(starttime)..ago(midtime))
  | where EventName == ""AssumeRole"" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)
  | project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn
) on RoleArn, UserIdentityInvokedBy
| summarize EventCount = count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by RoleArn, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy, SourceIpAddress
| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIpAddress, AccountCustomEntity = tostring(split(RoleArn, ""/"")[1])",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_SuspiciousCredentialTokenAccessOfValid_IAM_Roles.yaml,2020-10-04,AWS_SuspiciousCredentialTokenAccessOfValid_IAM_Roles.yaml
58fc0170-0877-4ea8-a9ff-d805e361cfae,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,,Detection,Azure Sentinel Community Github,User joining Zoom meeting from suspicious timezone,"'The alert shows users that join a Zoom meeting from a time zone other than the one the meeting was created in.
You can also whitelist known good time zones in the tz_whitelist value using the tz database name format https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'
",CustomConnector,CustomLogs_CL,"
let schedule_lookback = 14d; 
let join_lookback = 1d; 
// If you want to whitelist specific timezones include them in a list here
let tz_whitelist = dynamic([]);
let meetings = ( 
ZoomLogs 
| where TimeGenerated >= ago(schedule_lookback) 
| where Event =~ ""meeting.created"" 
| extend MeetingId = tostring(parse_json(MeetingEvents).MeetingId)  
| extend SchedTimezone = tostring(parse_json(MeetingEvents).Timezone)); 
ZoomLogs 
| where TimeGenerated >=W ago(join_lookback) 
| where Event =~ ""meeting.participant_joined"" 
| extend JoinedTimeZone = tostring(parse_json(MeetingEvents).Timezone) 
| extend MeetingName = tostring(parse_json(MeetingEvents).MeetingName) 
| extend MeetingId = tostring(parse_json(MeetingEvents).MeetingId) 
| where JoinedTimeZone !in (tz_whitelist)
| join (meetings) on MeetingId 
| where SchedTimezone != JoinedTimeZone 
| project TimeGenerated, MeetingName, JoiningUser=payload_object_participant_user_name_s, JoinedTimeZone, SchedTimezone, MeetingScheduler=User1 
| extend timestamp = TimeGenerated, AccountCustomEntity = JoiningUser",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/JoiningMeetingFromAnotherTimeZone.yaml,2020-10-04,JoiningMeetingFromAnotherTimeZone.yaml
f041e01d-840d-43da-95c8-4188f6cef546,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,,Detection,Azure Sentinel Community Github,GitHub Activites from a New Country,"'Detect activities from a location that was not recently or was never visited by the user or by any user in your organization.'
",CustomConnector,CustomLogs_CL,"let LearningPeriod = 7d;
let RunTime = 1h;
let StartTime = 1h;
let EndRunTime = StartTime - RunTime;
let EndLearningTime = StartTime + LearningPeriod;
let GitHubCountryCodeLogs = (GitHubAudit
| where Country != """");
  GitHubCountryCodeLogs
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))
| summarize makeset(Country) by Actor
| join kind=innerunique (
  GitHubCountryCodeLogs
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))
  | distinct Country, Actor 
) on Actor 
| where set_Country !contains Country
| extend AccountCustomEntity = Actor , timestamp = TimeGenerated",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/GitHub%20Activities%20from%20Infrequent%20Country.yaml,2020-10-04,GitHub%20Activities%20from%20Infrequent%20Country.yaml
558f15dd-3171-4b11-bf24-31c0610a20e0,2020-10-04 07:11:15.6720053,mitre-attack,PrivilegeEscalation,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,User made Owner of multiple teams,"'This hunting query identifies users who have been made Owner of multiple Teams.
This query requires you to have Teams data collected from the O365 Management Activity API
and the Teams parser function enabled.
More details: https://techcommunity.microsoft.com/t5/azure-sentinel/protecting-your-teams-with-azure-sentinel/ba-p/1265761'
",CustomConnector,CustomLogs_CL,"
// Adjust this value to change how many teams a user is made owner of before detecting
let max_owner_count = 3;
// Change this value to adjust how larger timeframe the query is run over.
let time_window = 1d;
let high_owner_count = (TeamsData
| where CreationTime > ago(time_window)
| where Operation =~ ""MemberRoleChanged""
| extend Member = tostring(parse_json(Members)[0].UPN) 
| extend NewRole = toint(parse_json(Members)[0].Role) 
| where NewRole == 2
| summarize dcount(TeamName) by Member
| where dcount_TeamName > max_owner_count
| project Member);
TeamsData
| where CreationTime > ago(time_window)
| where Operation =~ ""MemberRoleChanged""
| extend Member = tostring(parse_json(Members)[0].UPN) 
| extend NewRole = toint(parse_json(Members)[0].Role) 
| where NewRole == 2
| where Member in (high_owner_count)
| extend TeamGuid = tostring(Details.TeamGuid)
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = CreationTime, AccountCustomEntity = Member
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/TeamsLogs/MultiTeamOwner.yaml,2020-10-04,MultiTeamOwner.yaml
5ca3868b-9245-4573-894c-55a935736018,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,New time zone observed,"'This hunting query identifies users joining a meeting from a time zone that a user has not been observed from in the last 30 days.'
",CustomConnector,CustomLogs_CL,"
let hunt_time = 1d;
let lookback_time = 14d;
let previous_tz = (
  ZoomLogs
  | where TimeGenerated >= ago(lookback_time)
  | where Event =~ ""meeting.participant_joined""
  | extend TimeZone = columnifexists('payload_object_timezone_s', """")
  | summarize by TimeZone
);
ZoomLogs 
| where TimeGenerated >= ago(hunt_time)
| where Event =~ ""meeting.participant_joined""
| extend TimeZone = columnifexists('payload_object_timezone_s', """")
| where isnotempty(TimeZone) and TimeZone in (previous_tz)
| extend timestamp = TimeGenerated, AccountCustomEntity = User",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/NewTZ.yaml,2020-10-04,NewTZ.yaml
e119c365-9213-45a1-bbd7-8faf6d103d30,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,User denied multiple registration events successfully registering,"'This hunting query identifies users that have attempted to register for multiple webinars or recordings and has been denied by the organizer but have also successfully register for at least one event. The number of events a user needs to be rejected from to be included in this query is adjusted with the threshold variable.'
",CustomConnector,CustomLogs_CL,"
let hunt_time = 14d; 
let threshold = 2; 
let failed_users = (
ZoomLogs 
| where TimeGenerated >= ago(hunt_time) 
| where Event =~ ""webinar.registration_denied"" or Event =~ ""recording.registration_denied"" 
| extend RegisteringUser = columnifexists('payload_object_registrant_email_s', payload_object_registrant_email_s)
| extend ItemId = columnifexists('tostring(parse_json(WebinarEvents).WebinarId)',payload_object_uuid_s)
| summarize dcount(ItemId) by RegisteringUser
| where dcount_ItemId > threshold
| project RegisteringUser);
ZoomLogs 
| where TimeGenerated >= ago(hunt_time) 
| where Event =~ ""webinar.registration_approved"" or Event =~ ""recording.registration_approved"" 
| extend RegisteringUser = columnifexists('payload_object_registrant_email_s', columnifexists('payload_object_registrant_email_s', """")) 
| extend ItemId = columnifexists('tostring(parse_json(WebinarEvents).WebinarId)',columnifexists('payload_object_uuid_s', """"))
| extend EventName = columnifexists('tostring(parse_json(WebinarEvents).WebinarName)',columnifexists('payload_object_topic_s', """"))
| extend EventHost = columnifexists('payload_object_host_id',"""")
| extend EventStart = columnifexists('tostring(parse_json(WebinarEvents).Start)',columnifexists('payload_object_start_time_s' ,""""))
| where RegisteringUser !in (failed_users)
| project TimeGenerated, RegisteringUser, EventName, ItemId, EventHost, EventStart
| extend timestamp = TimeGenerated, AccountCustomEntity = RegisteringUser",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/MultipleRegistrationDenies.yaml,2020-10-04,MultipleRegistrationDenies.yaml
9fb57e58-3ed8-4b89-afcf-c8e786508b1c,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Detection,Azure Sentinel Community Github,Suspicious Resource deployment,"'Identifies when a rare Resource and ResourceGroup deployment occurs by a previously unseen Caller.'
",AzureActivity,AzureActivity,"
let szOperationNames = dynamic([""Create or Update Virtual Machine"", ""Create Deployment""]);
let starttime = 14d;
let endtime = 1d;
let RareCaller = AzureActivity
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| where OperationName in~ (szOperationNames)
| project ResourceGroup, Caller, OperationName, CallerIpAddress
| join kind=rightantisemi (
AzureActivity
| where TimeGenerated > ago(endtime)
| where OperationName in~ (szOperationNames)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityStatus = makeset(ActivityStatus), OperationIds = makeset(OperationId), CallerIpAddress = makeset(CallerIpAddress) 
by ResourceId, Caller, OperationName, Resource, ResourceGroup
) on Caller, ResourceGroup 
| mvexpand CallerIpAddress
| where isnotempty(CallerIpAddress);
let Counts = RareCaller | summarize ActivityCountByCaller = count() by Caller;
RareCaller | join kind= inner (Counts) on Caller | project-away Caller1
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = tostring(CallerIpAddress)
| sort by ActivityCountByCaller desc nulls last 
",1d,14d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/NewResourceGroupsDeployedTo.yaml,2020-10-04,NewResourceGroupsDeployedTo.yaml
361dd1e3-1c11-491e-82a3-bb2e44ac36ba,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Detection,Azure Sentinel Community Github,Suspicious number of resource creation or deployment activities,"'Indicates when an anomalous number of VM creations or deployment activities occur in Azure via the AzureActivity log.
The anomaly detection identifies activities that have occured both since the start of the day 1 day ago and the start of the day 7 days ago.
The start of the day is considered 12am UTC time.'
",AzureActivity,AzureActivity,"
let szOperationNames = dynamic([""Create or Update Virtual Machine"", ""Create Deployment""]);
let starttime = 7d;
let endtime = 1d;
AzureActivity
| where TimeGenerated between (startofday(ago(starttime)) .. startofday(ago(endtime)))
| where OperationName in~ (szOperationNames)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), 
OperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) 
by ResourceId, Caller, OperationName, Resource, ResourceGroup
| mvexpand CallerIpAddress
| where isnotempty(CallerIpAddress)
| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(7d)), now(), 1d) 
by Caller, tostring(ActivityTimeStamp), tostring(ActivityStatus), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationName, Resource, ResourceGroup
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
| where Slope > 0.2
| join kind=leftsemi (
// Last day's activity is anomalous
AzureActivity
| where TimeGenerated >= startofday(ago(endtime))
| where OperationName in~ (szOperationNames)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), 
OperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) 
by ResourceId, Caller, OperationName, Resource, ResourceGroup
| mvexpand CallerIpAddress
| where isnotempty(CallerIpAddress)
| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(1d)), now(), 1d) 
by Caller, tostring(ActivityTimeStamp), tostring(ActivityStatus), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationName, Resource, ResourceGroup
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
| where Slope > 0.2    
) on Caller, CallerIpAddress        
| mvexpand todynamic(ActivityTimeStamp), todynamic(ActivityStatus), todynamic(OperationIds), todynamic(CorrelationId)
| extend timestamp = ActivityTimeStamp, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",1d,7d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/Creating_Anomalous_Number_Of_Resources_detection.yaml,2020-10-04,Creating_Anomalous_Number_Of_Resources_detection.yaml
0da142a4-b3ad-4bb6-b01d-03b572743fe9,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1078,Valid Accounts,SaaS,Hunting Query,Azure Sentinel Community Github,User Granted Access and associated audit activity,"'Identifies when a new user is granted access and any subsequent audit related activity.  This can help you identify rogue or malicious user behavior.'
",AzureActivity,AuditLogs,"let auditLookback = 14d;
let opName = dynamic([""Add user"", ""Invite external user""]);
// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 14 days will be excluded
let threshold = 3;
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | extend ModProps = iff(TargetResources.[0].modifiedProperties != ""[]"", TargetResources.[0].modifiedProperties, todynamic(""NoValues""))
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend InitiatedBy = replace(""_"",""@"",tostring(split(InitiatedByFull, ""#"")[0]))
    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetResourceName = case(
    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,
    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith ""upn:"", tolower(tostring(TargetResources.[0].displayName)),
    tolower(tostring(TargetResources.[0].displayName))
    )
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, "","")[0], "" "")[1]), TargetUserName ) 
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
let HistoricalAdd = auditLogEvents(auditLookback)
| where OperationName in~ (opName)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() 
by Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 14 days
| where OperationCount > threshold
;
// Get list of new added users to correlate with all other events
let Correlate = HistoricalAdd 
| summarize by InitiatedBy, TargetUserName, CorrelationId;
// Get all other events related to list of newly added users
let allOtherEvents = auditLogEvents(auditLookback);
// Join the new added user list to get the list of associated events
let CorrelatedEvents = Correlate 
| join allOtherEvents on InitiatedBy, TargetUserName
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) 
by Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
;
// Union the results so we can see when the user was added and any associated events that occurred during the same time.
let Results = union isfuzzy=true HistoricalAdd,CorrelatedEvents;
// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)
Results
| extend newValue = split(newValue, "";"")
| extend PropertyUpdate = pack(PropertyName, newValue, ""Id"", Id)
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) 
by InitiatedBy, IpAddress, TargetUserName, TargetResourceName, OperationName, CorrelationId
| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/UserGrantedAccess_AllAuditActivity.yaml,2020-10-04,UserGrantedAccess_AllAuditActivity.yaml
a09e6368-065b-4f1e-a4ce-b1b3a64b493b,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Hunting Query,Azure Sentinel Community Github,Creation of an anomalous number of resources,"'Looks for anomalous number of resources creation or deployment activities in azure activity log.
It is best to run this query on a look back period which is at least 7 days.'
",AzureActivity,AzureActivity,"
let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Create or Update Virtual Machine"" or OperationName == ""Create Deployment"" 
| where ActivityStatus == ""Succeeded"" 
| make-series dcount(ResourceId)  default=0 on EventSubmissionTimestamp in range(ago(7d), now(), 1d) by Caller
| extend AccountCustomEntity = Caller
| render timechart 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Creating_Anomalous_Number_Of_Resources.yaml,2020-10-04,Creating_Anomalous_Number_Of_Resources.yaml
5a1f9655-c893-4091-8dc0-7f11d7676506,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Hunting Query,Azure Sentinel Community Github,Azure Virtual Network Subnets Administrative Operations,"'Identifies set of Azure Virtual Network Subnets administrative operational detection queries for hunting activites'
",AzureActivity,AzureActivity,"
let timeframe = 1d;
let opValues = dynamic([""Microsoft.Network/virtualNetworks/subnets/write""]);
// Creating Virtual Network Subnets
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue == ""Created""
| sort by TimeGenerated desc
| extend AccountCustomEntity = Caller
| extend IPCustomEntity = CallerIpAddress
",,,,,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureVirtualNetworkSubnets_AdministrativeOperationset.yaml,2020-10-04,AzureVirtualNetworkSubnets_AdministrativeOperationset.yaml
0278e3b8-9899-45c5-8928-700cd80d2d80,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Hunting Query,Azure Sentinel Community Github,Common deployed resources,"'This query looks for common deployed resources (resource name and resource groups) and can be used
in combination with other signals that show suspicious deployment to evaluate if the resource is one
that is commonly being deployed/created or unique.' 
",AzureActivity,AzureActivity,"
let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Create or Update Virtual Machine"" or OperationName == ""Create Deployment"" 
| where ActivityStatus == ""Succeeded"" 
| project Resource, ResourceGroup 
| evaluate basket()
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Common_Deployed_Resources.yaml,2020-10-04,Common_Deployed_Resources.yaml
ef7ef44e-6129-4d8e-94fe-b5530415d8e5,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Hunting Query,Azure Sentinel Community Github,Azure Sentinel Analytics Rules Administrative Operations,"'Identifies set of Azure Sentinel Analytics Rules administrative operational detection queries for hunting activites'
",AzureActivity,AzureActivity,"
let timeframe = 1d;
let opValues = dynamic([""Microsoft.SecurityInsights/alertRules/write"", ""Microsoft.SecurityInsights/alertRules/delete""]);
// Azure Sentinel Analytics - Rule Create / Update / Delete
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend AccountCustomEntity = Caller
| extend IPCustomEntity = CallerIpAddress
",,,,,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnalyticsRulesAdministrativeOperations.yaml,2020-10-04,AnalyticsRulesAdministrativeOperations.yaml
17201aa8-0916-4078-a020-7ea3a9262889,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Hunting Query,Azure Sentinel Community Github,Azure Sentinel Connectors Administrative Operations,"'Identifies set of Azure Sentinel Data Connectors administrative operational detection queries for hunting activites'
",AzureActivity,AzureActivity,"
let timeframe = 1d;
let opValues = dynamic([""Microsoft.SecurityInsights/dataConnectors/write"", ""Microsoft.SecurityInsights/dataConnectors/delete""]);
// Azure Sentinel Data Connectors Update / Delete
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend AccountCustomEntity = Caller
| extend IPCustomEntity = CallerIpAddress
",,,,,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureSentinelConnectors_AdministrativeOperations.yaml,2020-10-04,AzureSentinelConnectors_AdministrativeOperations.yaml
e94d6756-981c-4f02-9a81-d006d80c8b41,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,SaaS,Hunting Query,Azure Sentinel Community Github,Azure Network Security Group NSG Administrative Operations,"'Identifies set of Azure NSG administrative operational detection queries for hunting activites'
",AzureActivity,AzureActivity,"
let timeframe = 1d;
let opValues = dynamic([""Microsoft.Network/networkSecurityGroups/write"", ""Microsoft.Network/networkSecurityGroups/delete""]);
// Azure NSG Create / Update / Delete
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend AccountCustomEntity = Caller
| extend IPCustomEntity = CallerIpAddress
",,,,,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureNSG_AdministrativeOperations.yaml,2020-10-04,AzureNSG_AdministrativeOperations.yaml
8d5996b2-7d4c-4dcf-bb0d-0d7fdf0e2c75,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,Azure,Hunting Query,Azure Sentinel Community Github,Azure Resources assigned Public IP Addresses,"'Identifies when public IP addresses are assigned to Azure Resources.  Additionally, shows connections to those resources.
Resources: 
https://docs.microsoft.com/azure/azure-monitor/insights/azure-networking-analytics
https://docs.microsoft.com/azure/network-watcher/traffic-analytics-schema'
",AzureNetworkWatcher,AzureNetworkAnalytics_CL,"
let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
// We look for any Operation that modified and then was accepted or succeeded where a publicipaddress component is referenced
| where OperationName has_any (""Create"", ""Update"", ""Delete"")// Virtual Machine"" or OperationName == ""Create Deployment"" 
| where ActivityStatus has_any (""Succeeded"", ""Accepted"")
| where Properties contains ""publicipaddress""
//| extend frontendIPConfigurations = Properties.responseBody.properties.frontendIPConfigurations
// parsing the publicIPAddress from Properties. It is only available if the allocation method is Static.
| parse Properties with * ""publicIPAddress\\"" PublicIPAddressParse
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
| extend scope_ = tostring(parse_json(Authorization).scope) 
| project TimeGenerated, OperationName, publicIPAllocationMethod_ , publicIPAddressVersion_, scope_ , Caller, CallerIpAddress, ActivityStatus, Resource 
// Join in the AzureNetworkAnalytics so that we can determine if any connections were made via the public ip address and get the currently assigned ip address when allocation method is Dynamic
| join kind= inner (
union isfuzzy=true
(AzureNetworkAnalytics_CL
| where TimeGenerated >= ago(timeframe) 
// Controlling for Schema Version and later parsing - This is Version 2 and Public IPs only
| where isnotempty(FASchemaVersion_s) and isnotempty(DestPublicIPs_s)
| extend SchemaVersion = FASchemaVersion_s
| extend PublicIPs = tostring(split(DestPublicIPs_s,""|"")[0])
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(FlowStartTime_t), LastProcessedTimeUtc = max(FlowEndTime_t), 
Regions = makeset(Region_s), AzureRegions = makeset(AzureRegion_s), VMs = makeset(VM_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), DestPort = makeset(DestPort_d), SrcIP = makeset(SrcIP_s), 
ActivityCount = count() by NSGRule_s, NSGList_s, SubNet = Subnet1_s, FlowDirection_s, Subscription = Subscription1_g, Tags_s, SchemaVersion
//NSGList_s contains the subscription ID, remove that as we already have a field for this and now it will match what we get for SchemaVersion 1
| extend NSG = case(isnotempty(NSGList_s), strcat(split(NSGList_s, ""/"")[-2],""/"",split(NSGList_s, ""/"")[-1]), ""NotAvailable"")
// Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
| extend NSG_Name = tostring(split(NSG, ""/"")[-1])
),
(
AzureNetworkAnalytics_CL
| where TimeGenerated >= ago(timeframe) 
// Controlling for Schema Version and later parsing - This is Version 1
| where isempty(FASchemaVersion_s)
// Controlling for public IPs only
| where isnotempty(PublicFrontendIPs_s) or isnotempty(PublicIPAddresses_s)
| where PublicFrontendIPs_s != ""null"" or PublicIPAddresses_s != ""null""
| extend SchemaVersion = SchemaVersion_s
// The Public IP can be indicated in one of 2 locations, assigning here for easy union results
| extend PublicIPs = case(isnotempty(PublicFrontendIPs_s), PublicFrontendIPs_s,
PublicIPAddresses_s) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(TimeProcessed_t), LastProcessedTimeUtc = max(TimeProcessed_t), 
Regions = makeset(Region_s), AzureRegions = makeset(DiscoveryRegion_s), VMs = makeset(VirtualMachine_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), 
SrcIP = makeset(PrivateIPAddresses_s), Name = makeset(Name_s), DestPort = makeset(DestinationPortRange_s),
ActivityCount = count() by NSG = NSG_s, SubNet = Subnetwork_s, Subscription = Subscription_g, Tags_s, SchemaVersion
// Some events don't have an NSG listed, populating so it is clear it is not available in the datatype
| extend NSG = case(isnotempty(NSG), NSG, ""NotAvailable"")
// Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
| extend NSG_Name = tostring(split(NSG, ""/"")[-1])
)
| project StartTimeUtc, EndTimeUtc, FirstProcessedTimeUTC, LastProcessedTimeUtc, PublicIPs, NSG, NSG_Name, SrcIP, DestPort, SubNet, Name, VMs, MACAddresses, ActivityCount, Regions, AzureRegions, Subscription, Tags_s, SchemaVersion
) on $left.Resource == $right.NSG_Name
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AzureResourceAssignedPublicIP.yaml,2020-10-04,AzureResourceAssignedPublicIP.yaml
b6baa3bb-a231-4e50-8ad1-4e28a958a0d3,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1078,Valid Accounts,SaaS,Hunting Query,Azure Sentinel Community Github,User Granted Access and created resources,"'Identifies when a new user is granted access and starts creating resources in Azure.  This can help you identify rogue or malicious user behavior.'
",AzureActivity,AzureActivity,"
let auditLookback = 14d;
let opName = dynamic([""Add user"", ""Invite external user""]);
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | where OperationName in~ (operation)
    | extend ModProps = iff(TargetResources.[0].modifiedProperties != ""[]"", TargetResources.[0].modifiedProperties, todynamic(""NoValues""))
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend InitiatedBy = replace(""_"",""@"",tostring(split(InitiatedByFull, ""#"")[0]))
    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetResourceName = case(
    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,
    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith ""upn:"", tolower(tostring(TargetResources.[0].displayName)),
    tolower(tostring(TargetResources.[0].displayName))
    )
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, "","")[0], "" "")[1]), TargetUserName ) 
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
let UserAdd = auditLogEvents(auditLookback, opName) 
| project Action = ""User Added"", TimeGenerated, Type, InitiatedBy_Caller = InitiatedBy, IpAddress, TargetUserName = tolower(TargetUserName), OperationName, PropertyName_ResourceId = PropertyName, Value = newValue;
// Get the simple list of creatd users so we can use later to get just the associated resource creation events
let SimpleUserList = UserAdd | project TimeGenerated, TargetUserName;
let ResourceCreation = AzureActivity
| where TimeGenerated >= ago(auditLookback)
// We look for any Operation that created and then succeeded where ActivityStatus has a value so that we can provide context
| where OperationName has ""Create""
| where ActivityStatus has ""Succeeded""
| project Action = ""Resource Created"", ResourceCreationTimeGenerated = TimeGenerated, Type, InitiatedBy_Caller = tolower(Caller), IpAddress = CallerIpAddress, OperationName, Value = OperationNameValue, PropertyName_ResourceId = ResourceId;
// Get just the Resources added by the new user
let ResourceMatch = SimpleUserList | join kind= innerunique (
   ResourceCreation
) on $left.TargetUserName == $right.InitiatedBy_Caller
// where the resource creation is after (greater than) the user addition
| where TimeGenerated < ResourceCreationTimeGenerated
| project-away TimeGenerated 
| project-rename TimeGenerated = ResourceCreationTimeGenerated
;
let SimpleResourceMatch = ResourceMatch | project InitiatedBy_Caller;
// Get only resource add, remove, change by the new user
let UserAddWithResource = SimpleResourceMatch | join kind= rightsemi (
   UserAdd 
) on $left.InitiatedBy_Caller == $right.TargetUserName;
// union the user addition events and resource addition events and provide common column names, additionally pack the value, property and resource info to reduce result set.
UserAddWithResource 
| union isfuzzy=true ResourceMatch
| extend PropertySet = pack(""Value"", Value, ""PropertyName_ResourceId"", PropertyName_ResourceId) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(PropertySet)  by Action, Type, TargetUserName, InitiatedBy_Caller, IpAddress, OperationName
| order by StartTimeUtc asc 
| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, IPCustomEntity = IpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UserGrantedAccess_CreatesResources.yaml,2020-10-04,UserGrantedAccess_CreatesResources.yaml
ac25d05d-362d-4a8d-b4e7-58c0edd2379c,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous Resource Creation and related Network Activity,"'Indicates when an anomalous number of resources are created successfully in Azure via the AzureActivity log.
This is then joined with the AzureNetworkAnalytics_CL data to identify any network related activity for the created resource.
The anomaly detection identifies activities that have occured both since the start of the day 1 day ago and the start of the day 7 days ago.
The start of the day is considered 12am UTC time.
Resource creation could indicated malicious or spurious use of your Azure Resource allocation.  Resources can be abused in relation to digital 
currency mining, command and control, exfiltration, distributed attacks and propagation of malware, among others. Verify that this resource creation
is expected.
Resources: 
https://docs.microsoft.com/azure/azure-monitor/insights/azure-networking-analytics
https://docs.microsoft.com/azure/network-watcher/traffic-analytics-schema'
",AzureNetworkWatcher,AzureNetworkAnalytics_CL,"
let starttime = 7d;
let endtime = 1d;
let Activity = AzureActivity
| where TimeGenerated >= startofday(ago(starttime))
// We look for any Operation that created and then succeeded where ActivitySubStatus has a value so that we can provide context
| where OperationName has ""Create""
| where ActivityStatus has ""Succeeded""
| make-series dResourceCount=dcount(ResourceId) default=0 on EventSubmissionTimestamp in range(startofday(ago(7d)), now(), 1d) by Caller, Resource, OperationName
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
// Comment slope reference below to see all returns
| where Slope > 0.2
| join kind=leftsemi (
// Last day's activity is anomalous
AzureActivity
| where TimeGenerated >= startofday(ago(endtime))
// We look for any Operation that created and then succeeded where ActivitySubStatus has a value so that we can provide context
| where OperationName has ""Create""
| where ActivityStatus has ""Succeeded""
| make-series dResourceCount=dcount(ResourceId) default=0 on EventSubmissionTimestamp in range(startofday(ago(1d)), now(), 1d) by Caller, Resource, OperationName
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
// Comment slope reference below to see all returns
| where Slope > 0.2
) on Caller, Resource, OperationName
// Expanding the fields that were grouped so we can match on a time window when we join the details later
| mvexpand EventSubmissionTimestamp, dResourceCount
// Making sure the fields are the right type or the join fails
| extend todatetime(EventSubmissionTimestamp), tostring(dResourceCount)
| join kind= inner (
  AzureActivity
  | where TimeGenerated >= ago(endtime)
  // We look for any Operation that created and then succeeded where ActivitySubStatus has a value so that we can provide context
  | where OperationName has ""Create""
  | where ActivityStatus has ""Succeeded"" and isnotempty(ActivitySubstatus) 
  | summarize by EventSubmissionTimestamp = bin(EventSubmissionTimestamp, 1d), Caller, CallerIpAddress, OperationName, OperationNameValue, ActivityStatusValue, Resource, ResourceGroup, ResourceId, SubscriptionId
) on EventSubmissionTimestamp, Caller, Resource, OperationName;
let NetworkAnalytics = 
  union isfuzzy=true
  (AzureNetworkAnalytics_CL
  | where TimeGenerated >= ago(endtime) 
  // Controlling for Schema Version and later parsing - This is Version 2 and Public IPs only
  | where (isnotempty(FASchemaVersion_s) and isnotempty(DestPublicIPs_s))
  | extend SchemaVersion = FASchemaVersion_s
  | extend PublicIPs = tostring(split(DestPublicIPs_s,""|"")[0])
  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(FlowStartTime_t), LastProcessedTimeUtc = max(FlowEndTime_t), 
  Regions = makeset(Region_s), AzureRegions = makeset(AzureRegion_s), VMs = makeset(VM_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), DestPort = makeset(DestPort_d), SrcIP = makeset(SrcIP_s), 
  ActivityCount = count() by NSGRule_s, NSGList_s, SubNet = Subnet1_s, FlowDirection_s, Subscription = Subscription1_g, Tags_s, SchemaVersion
  //NSGList_s contains the subscription ID, remove that as we already have a field for this and now it will match what we get for SchemaVersion 1
  | extend NSG = case(isnotempty(NSGList_s), strcat(split(NSGList_s, ""/"")[-2],""/"",split(NSGList_s, ""/"")[-1]), ""NotAvailable"")
  // Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
  | extend NSG_Name = tostring(split(NSG, ""/"")[-1])
  ),
  (
  AzureNetworkAnalytics_CL
  | where TimeGenerated >= ago(endtime) 
  // Controlling for Schema Version and later parsing - This is Version 1
  | where isempty(FASchemaVersion_s)
  // Controlling for public IPs only
  | where isnotempty(PublicFrontendIPs_s) or isnotempty(PublicIPAddresses_s)
  | where PublicFrontendIPs_s != ""null"" or PublicIPAddresses_s != ""null""
  | extend SchemaVersion = SchemaVersion_s
  // The Public IP can be indicated in one of 2 locations, assigning here for easy union results
  | extend PublicIPs = case(isnotempty(PublicFrontendIPs_s), PublicFrontendIPs_s,
  PublicIPAddresses_s) 
  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(TimeProcessed_t), LastProcessedTimeUtc = max(TimeProcessed_t),  
  Regions = makeset(Region_s), AzureRegions = makeset(DiscoveryRegion_s), VMs = makeset(VirtualMachine_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), 
  SrcIP = makeset(PrivateIPAddresses_s), Name = makeset(Name_s), DestPort = makeset(DestinationPortRange_s),
  ActivityCount = count() by NSG = NSG_s, SubNet = Subnetwork_s, Subscription = Subscription_g, Tags_s, SchemaVersion
  // Some events don't have an NSG listed, populating so it is clear it is not available in th datatype
  | extend NSG = case(isnotempty(NSG), NSG, ""NotAvailable"")
  // Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
  | extend NSG_Name = tostring(split(NSG, ""/"")[-1])
  )
  | project StartTimeUtc, EndTimeUtc, FirstProcessedTimeUTC, LastProcessedTimeUtc, PublicIPs, NSG, NSG_Name, SrcIP, DestPort, SubNet, Name, VMs, MACAddresses, ActivityCount, Regions, AzureRegions, Subscription, Tags_s, SchemaVersion
  ;
  Activity | join kind= leftouter (NetworkAnalytics
  ) on $left.Resource == $right.NSG_Name
  | extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AzureResourceCreationWithNetworkActivity.yaml,2020-10-04,AzureResourceCreationWithNetworkActivity.yaml
5dd79877-8066-4ce4-ae03-eedd8ebf04f8,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,User removed from SQL Server Roles,"This hunting query identifies user removed from a SQL Server Role.
This query is based on the SQLEvent KQL Parser function (link below) 
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// This query checks for user removed from a ServerRole
SQLEvent
| where TimeGenerated >= ago(1d)
| where Statement has ""Alter Server role"" and Statement has ""drop member""
| parse Statement with * ""DROP MEMBER ["" TargetUser:string ""]"" *
| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement 
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserRemovedFromServerRole.yaml,2020-10-04,SQL-UserRemovedFromServerRole.yaml
f35b879c-c836-4502-94f2-c76b7f06f02d,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,User removed from SQL Server SecurityAdmin Group,"This hunting query identifies user removed from the SecurityAdmin group of SQL Server
This query is based on the SQLEvent KQL Parser function (link below) 
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// This query checks for user removed from SecurityAdmin Role
SQLEvent
| where TimeGenerated >= ago(1d)
| where Statement has ""Alter Server role"" and Statement has ""drop member""
| parse Statement with * ""DROP MEMBER ["" TargetUser:string ""]"" *
| where ObjectName has ""securityadmin""
| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement 
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserRemovedFromSecurityAdmin.yaml,2020-10-04,SQL-UserRemovedFromSecurityAdmin.yaml
7b8fa5f5-4f5b-4698-a4cf-720bbb215bea,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1078,Valid Accounts,,Hunting Query,Azure Sentinel Community Github,SQL User deleted from Database,"This hunting query identifies deletion of user from SQL Database
This query is based on the SQLEvent KQL Parser function (link below)
SQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever
Detailed blog post on Monitoring SQL Server with Azure Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960
",AzureMonitor(WindowsEventLogs),Event,"
// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.
// The underlying table where the data exists is the Event table.
// This query checks for user removed from a database by parsing the statement field at the query time.
//
SQLEvent
| where TimeGenerated >= ago(1d)
| where Statement has ""Alter role"" and Statement has ""drop member""
| parse Statement with * ""DROP MEMBER ["" TargetUser:string ""]"" *
| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement
| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserDeletedFromDatabase.yaml,2020-10-04,SQL-UserDeletedFromDatabase.yaml
5efb0cfd-063d-417a-803b-562eae5b0301,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,,Detection,Azure Sentinel Community Github,Azure DevOps Service Conection Addition/Abuse - Historic Allowlist,"'This detection builds a allowlist of historic service connection use by Builds and Releases and compares to recent history, flagging growth of service connection use in non manually allowlisted, non historically allowlisted Build/Release runs.
This is to determine if someone is hijacking a build/release and adding many service connections in order to abuse or dump credentials from service connections.'
",CustomConnector,CustomLogs_CL,"
let starttime = 14d;
let endtime = 6h;
// Ignore Build/Releases with less/equal this number
let ServiceConnectionThreshold = 3;
// New Connections need to exhibit execution of more ""new"" connections than this number.
let NewConnectionThreshold = 1;
// List of Builds/Releases to ignore in your space
let BypassDefIds = datatable(DefId:string, Type:string, ProjectName:string)
[
//""103"", ""Release"", ""ProjectA"",
//""42"", ""Release"", ""ProjectB"",
//""122"", ""Build"", ""ProjectB""
];
let HistoricDefs = AzureDevOpsAuditing
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| where OperationName == ""Library.ServiceConnectionExecuted"" 
| extend DefId = tostring(Data.DefinitionId), Type = tostring(Data.PlanType), ConnectionId = tostring(Data.ConnectionId)
| summarize HistoricCount = dcount(tostring(ConnectionId)), ConnectionNames = make_set(tostring(Data.ConnectionName)) 
  by DefId = tostring(DefId), Type = tostring(Type), ProjectId, ProjectName, ActorUPN;
AzureDevOpsAuditing
| where TimeGenerated >= ago(endtime)
| where OperationName == ""Library.ServiceConnectionExecuted"" 
| extend DefId = tostring(Data.DefinitionId), Type = tostring(Data.PlanType), ConnectionId = tostring(Data.ConnectionId)
| parse ScopeDisplayName with OrganizationName ' (Organization)'
| summarize CurrentCount = dcount(tostring(ConnectionId)), ConnectionNames = make_set(tostring(Data.ConnectionName)), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) 
  by OrganizationName, DefId = tostring(DefId), Type = tostring(Type), ProjectId, ProjectName, ActorUPN
| where CurrentCount > ServiceConnectionThreshold
| join (HistoricDefs) on ProjectId, DefId, Type, ActorUPN
| join kind=anti BypassDefIds on $left.DefId==$right.DefId and $left.Type == $right.Type and $left.ProjectName == $right.ProjectName
| extend link = iff(
Type == ""Build"", strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_build?definitionId=', DefId),
strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_release?_a=releases&view=mine&definitionId=', DefId))
| where CurrentCount >= HistoricCount + NewConnectionThreshold
| project StartTime, OrganizationName, ProjectName, DefId, link, RecentDistinctServiceConnections = CurrentCount, HistoricDistinctServiceConnections = HistoricCount, 
  RecentConnections = ConnectionNames, HistoricConnections = ConnectionNames1, ActorUPN
| extend timestamp = StartTime, AccountCustomEntity = ActorUPN",6h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOHistoricServiceConnectionAdds.yaml,2020-10-04,AzDOHistoricServiceConnectionAdds.yaml
d564ff12-8f53-41b8-8649-44f76b37b99f,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1496,Resource Hijacking,,Detection,Azure Sentinel Community Github,Azure DevOps Service Conection Abuse,"'Flags builds/releases that use a large number of service connections if they aren't manually allowlisted.
This is to determine if someone is hijacking a build/release and adding many service connections in order to abuse 
or dump credentials from service connections.'
",CustomConnector,CustomLogs_CL,"
let timeframe = 14d;
// How many greater than Service Connections you want to view per build/release
let ServiceConnectionThreshold = 4;
let BypassDefIds = datatable(DefId:string, Type:string, ProjectName:string)
[
//""103"", ""Release"", ""ProjectA"",
//""42"", ""Release"", ""ProjectB"",
//""122"", ""Build"", ""ProjectB""
];
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Library.ServiceConnectionExecuted"" 
| extend DefId = tostring(Data.DefinitionId), Type = tostring(Data.PlanType), ConnectionId = tostring(Data.ConnectionId)
| parse ScopeDisplayName with OrganizationName ' (Organization)'
| summarize CurrentCount = dcount(tostring(ConnectionId)), ConnectionNames = make_set(tostring(Data.ConnectionName)), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) 
  by OrganizationName, tostring(DefId), tostring(Type), ProjectId, ProjectName
| where CurrentCount > ServiceConnectionThreshold
| join kind=anti BypassDefIds on $left.DefId==$right.DefId and $left.Type == $right.Type and $left.ProjectName == $right.ProjectName
| extend link = iif(
  Type == ""Build"", strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_build?definitionId=', DefId),
  strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_release?_a=releases&view=mine&definitionId=', DefId))
| extend timestamp = StartTime",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOServiceConnectionUsage.yaml,2020-10-04,AzDOServiceConnectionUsage.yaml
ac891683-53c3-4f86-86b4-c361708e2b2b,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1528,Steal Application Access Token,,Detection,Azure Sentinel Community Github,Azure DevOps Personal Access Token (PAT) misuse,"'This Alert detects whenever a PAT is used in ways that PATs are not normally used.  May require Allowlisting and baselining.
Reference - https://docs.microsoft.com/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&tabs=preview-page
Use this query for baselining:
AzureDevOpsAuditing
| distinct OperationName'
",CustomConnector,CustomLogs_CL,"
let timeframe = 3d;
// Allowlisted UPNs should likely stay empty
let AllowlistedUpns = datatable(UPN:string)['foo@bar.com', 'test@foo.com'];
// Operation Name parts that will alert
let HasAnyBlocklist = datatable(OperationNamePart:string)['Security.','Project.','AuditLog.','Extension.'];
// Distinct Operation Names that will flag
let HasExactBlocklist = datatable(OperationName:string)['Group.UpdateGroupMembership.Add','Library.ServiceConnectionExecuted','Pipelines.PipelineModified',
'Release.ReleasePipelineModified', 'Git.RefUpdatePoliciesBypassed'];
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where AuthenticationMechanism startswith ""PAT"" and (OperationName has_any (HasAnyBlocklist) or OperationName in (HasExactBlocklist))
  and ActorUPN !in (AllowlistedUpns)
| project TimeGenerated, AuthenticationMechanism, ProjectName, ActorUPN, ActorDisplayName, IpAddress, UserAgent, OperationName, Details, Data
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress",1h,3h,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOPatSessionMisuse.yaml,2020-10-04,AzDOPatSessionMisuse.yaml
9736e5f1-7b6e-4bfb-a708-e53ff1d182c3,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1578,Modify Cloud Compute Infrastructure,SaaS,Detection,Azure Sentinel Community Github,Creation of expensive computes in Azure,"'Identifies the creation of large size/expensive VMs (GPU or with large no of virtual CPUs) in Azure.
Adversary may create new or update existing virtual machines sizes to evade defenses 
or use it for cryptomining purposes.
For Windows/Linux Vm Sizes - https://docs.microsoft.com/azure/virtual-machines/windows/sizes 
Azure VM Naming Conventions - https://docs.microsoft.com/azure/virtual-machines/vm-naming-conventions'
",AzureActivity,AzureActivity,"let timeframe = 1d;
let tokens = dynamic([""416"",""208"",""128"",""120"",""96"",""80"",""72"",""64"",""48"",""44"",""40"",""g5"",""gs5"",""g4"",""gs4"",""nc12"",""nc24"",""nv12""]);
let operationList = dynamic([""Create or Update Virtual Machine"", ""Create Deployment""]);
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName in (operationList)
| where ActivityStatus == ""Accepted"" 
| where isnotempty(Properties)
| extend vmSize = tolower(tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).hardwareProfile)).vmSize))
| where isnotempty(vmSize)
| where vmSize has_any (tokens) 
| extend ComputerName = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).osProfile)).computerName)
| extend clientIpAddress = tostring(parse_json(HTTPRequest).clientIpAddress)
| project TimeGenerated, OperationName, ActivityStatus, Caller, CallerIpAddress, ComputerName, vmSize
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",1d,1d,gt,1.0,,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/Creation_of_Expensive_Computes_in%20_Azure.yaml,2020-10-04,Creation_of_Expensive_Computes_in%20_Azure.yaml
23de46ea-c425-4a77-b456-511ae4855d69,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1003,OS Credential Dumping,SaaS,Detection,Azure Sentinel Community Github,Rare subscription-level operations in Azure,"'This query looks for a few sensitive subscription-level events based on Azure Activity Logs. 
 For example this monitors for the operation name 'Create or Update Snapshot' which is used for creating backups but could be misused by attackers 
 to dump hashes or extract sensitive information from the disk.'
",AzureActivity,AzureActivity,"
let starttime = 14d;
let endtime = 1d;
// The number of operations below which an IP address is considered an unusual source of role assignment operations
let alertOperationThreshold = 5;
let SensitiveOperationList = dynamic(
[""List keys"", ""List Storage Account Keys"", ""Register Subscription"", ""Create or Update Snapshot"", ""Create or Update Network Security Group""]);
let SensitiveActivity = AzureActivity
| where OperationName in~ (SensitiveOperationList)
| where ActivityStatus =~ ""Succeeded"";
SensitiveActivity
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| summarize count() by CallerIpAddress, Caller
| where count_ >= alertOperationThreshold
| join kind = rightanti ( 
SensitiveActivity
| where TimeGenerated >= ago(endtime)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), 
OperationIds = makelist(OperationId), CorrelationIds = makelist(CorrelationId), Resources = makelist(Resource), ResourceGroups = makelist(ResourceGroup), ResourceIds = makelist(ResourceId), ActivityCountByCallerIPAddress = count()  
by CallerIpAddress, Caller, OperationName
) on CallerIpAddress, Caller
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress
",1d,14d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/RareOperations.yaml,2020-10-04,RareOperations.yaml
24f8c234-d1ff-40ec-8b73-96b17a3a9c1c,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1003,OS Credential Dumping,Azure,Detection,Azure Sentinel Community Github,Mass secret retrieval from Azure Key Vault,"'Identifies mass secret retrieval from Azure Key Vault observed by a single user. 
Mass secret retrival crossing a certain threshold is an indication of credential dump operations or mis-configured applications. 
You can tweak the EventCountThreshold based on average count seen in your environment 
and also filter any known sources (IP/Account) and useragent combinations based on historical analysis to further reduce noise'
",AzureMonitor(Keyvault),AzureDiagnostics,"
let timeframe =1d;
let EventCountThreshold = 25;
let OperationList = dynamic(
[""SecretGet"", ""KeyGet"", ""VaultGet""]);
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success""
| where OperationName in (OperationList) 
| summarize count() by identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, OperationName
| where count_ > EventCountThreshold  
| join (
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""NoResultType"")
| extend requestUri_s = columnifexists(""requestUri_s"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| extend id_s = columnifexists(""id_s"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None""), clientInfo_s = columnifexists(""clientInfo_s"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where id_s !~ ""None"" and isnotempty(id_s)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where clientInfo_s !~ ""None"" and isnotempty(clientInfo_s)
| where requestUri_s !~ ""None"" and isnotempty(requestUri_s)
| where OperationName in~ (OperationList)   
) on identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g 
| summarize EventCount=sum(count_), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s
| extend timestamp = EndTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDiagnostics/KeyvaultMassSecretRetrieval.yaml,2020-10-04,KeyvaultMassSecretRetrieval.yaml
0914adab-90b5-47a3-a79f-7cdcac843aa7,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1003,OS Credential Dumping,Azure,Detection,Azure Sentinel Community Github,Azure Key Vault access TimeSeries anomaly,"'Indentifies a sudden increase in count of Azure Key Vault secret or vault access operations by CallerIPAddress. The query leverages a built-in KQL anomaly detection algorithm 
to find large deviations from baseline Azure Key Vault access patterns. Any sudden increase in the count of Azure Key Vault accesses can be an 
indication of adversary dumping credentials via automated methods. If you are seeing any noise, try filtering known source(IP/Account) and user-agent combinations.
TimeSeries Reference Blog: https://techcommunity.microsoft.com/t5/azure-sentinel/looking-for-unknown-anomalies-what-is-normal-time-series/ba-p/555052'
",AzureMonitor(Keyvault),AzureDiagnostics,"
let starttime = 14d;
let timeframe = 1d;
let scorethreshold = 3;
let baselinethreshold = 5;
let OperationList = dynamic(
[""SecretGet"", ""KeyGet"", ""VaultGet""]);
let TimeSeriesData = AzureDiagnostics
| where TimeGenerated between (startofday(ago(starttime))..startofday(now()))
| extend ResultType = columnifexists(""ResultType"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success""
| where OperationName in (OperationList) 
| project TimeGenerated, OperationName, Resource, CallerIPAddress 
| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Resource;
//Filter anomolies against TimeSeriesData
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')
| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend AnomalyHour = TimeGenerated
| where baseline > baselinethreshold // Filtering low count events per baselinethreshold
| project Resource, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;
// Filter the alerts since specified timeframe
TimeSeriesAlerts
| where TimeGenerated > ago(timeframe)
// Join against base logs since specified timeframe to retrive records associated with the hour of anomoly
| join (
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""NoResultType"")
| extend requestUri_s = columnifexists(""requestUri_s"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| extend id_s = columnifexists(""id_s"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None""), clientInfo_s = columnifexists(""clientInfo_s"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where id_s !~ ""None"" and isnotempty(id_s)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where clientInfo_s !~ ""None"" and isnotempty(clientInfo_s)
| where requestUri_s !~ ""None"" and isnotempty(requestUri_s)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success""
| where OperationName in (OperationList)  
| summarize PerOperationCount=count(), LatestAnomalyTime = arg_max(TimeGenerated,*) by bin(TimeGenerated,1h), Resource, OperationName, id_s, CallerIPAddress, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, requestUri_s, clientInfo_s     
) on Resource, TimeGenerated 
| summarize EventCount=count(), OperationNameList = make_set(OperationName), RequestURLList = make_set(requestUri_s), AccountList = make_set(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g), AccountMax = arg_max(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g,*) by Resource, id_s, clientInfo_s, LatestAnomalyTime
| extend timestamp = LatestAnomalyTime, IPCustomEntity = CallerIPAddress, AccountCustomEntity = AccountMax",1h,14d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDiagnostics/TimeSeriesKeyvaultAccessAnomaly.yaml,2020-10-04,TimeSeriesKeyvaultAccessAnomaly.yaml
96977c95-74b4-4cc2-b1a7-6a3ab17bd3f9,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1189,Drive-by Compromise,SaaS,Hunting Query,Azure Sentinel Community Github,Potential IIS code injection attempt,"'Potential code injection into web server roles via scan of IIS logs. This represents an attempt to gain initial access to a system using a 
drive-by compromise technique.  This sort of attack happens routinely as part of security scans, of both authorized and malicious types. 
The initial goal of this detection is to flag these events when they occur and give an opportunity to review the data and filter out authorized activity.'
",AzureMonitor(IIS),W3CIISLog,"
let lookback = 7d;
// set cIP and csMethod count limit to indicate potentially noisy events, this will be listed at the top of the results 
// for any returns that are gt or equal to the default of 50
let cIP_MethodCountLimit = 50;
// Exclude private ip ranges from cIP list
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.';
// Exclude common csMethods, add/modify this list as needed for your environment
let csMethodExclude = dynamic(['GET', 'DEBUG', 'DELETE', 'LOCK', 'MKCOL', 'MOVE', 'PATCH', 'POST', 'PROPPATCH', 
'PUT', 'SEARCH', 'TRACE', 'TRACK', 'UNLOCK', 'OPTIONS', 'HEAD', 'RPC_IN_DATA', 'RPC_OUT_DATA', 'PROPFIND','BITS_POST','CCM_POST']);
// Include in the list expected IPs where remote methods such as vuln scanning may be expected for your environment
let expectedIPs = dynamic(['X.X.X.X', 'Y.Y.Y.Y']);
let codeInjectionAttempts = W3CIISLog
| where TimeGenerated >= ago(lookback)
| extend cIPType = iff(cIP matches regex PrivateIPregex,""private"" ,""public"" )
| where cIPType ==""public""
| where cIP !in (expectedIPs)
| project TimeGenerated, cIP, csUserName, csMethod, csCookie, csHost, sIP, scStatus, csUriStem, csUriQuery, csUserAgent, csReferer 
// Throwing entire record into a single string column for attributable string matching
| extend pak = tostring(pack_all())
// Adding ""arr"" column containing indicators of matched suspicious strings
| extend arr = dynamic([])
| extend arr = iff(pak contains '<script' , array_concat(arr, pack_array('STRING MATCH : script')), arr)
| extend arr = iff(pak contains '%3Cscript' , array_concat(arr, pack_array('STRING MATCH : script')), arr)
| extend arr = iff(pak contains '%73%63%72%69%70%74' , array_concat(arr, pack_array('STRING MATCH : encoded script')), arr)
| extend arr = iff(pak contains '<img' , array_concat(arr, pack_array('STRING MATCH : img')), arr)
| extend arr = iff(pak contains '%3Cimg' , array_concat(arr, pack_array('STRING MATCH : img')), arr)
| extend arr = iff(pak contains 'passwd' , array_concat(arr, pack_array('STRING MATCH : passwd')), arr)
| extend arr = iff(csUserAgent contains 'nmap' , array_concat(arr, pack_array('STRING MATCH : nmap')), arr)
| extend arr = iff(csUserAgent contains 'nessus' , array_concat(arr, pack_array('STRING MATCH : nessus')), arr)
| extend arr = iff(csUserAgent contains 'qualys' , array_concat(arr, pack_array('STRING MATCH : qualys')), arr)
| extend arr = iff(csMethod !in (csMethodExclude), array_concat(arr, pack_array('INVALID HTTP METHOD')), arr)
| extend arr = iff(csUriStem == '/current_config/passwd' , array_concat(arr, pack_array('STRING MATCH : dahua scan url' )), arr)
| extend arr = iff(csUriQuery contains '..' and csUriQuery !endswith '...', array_concat(arr, pack_array('BACKTRACK ATTEMPT IN QUERY')), arr)
| extend arr = iff(csUriQuery contains 'http://www.webscantest.com' , array_concat(arr, pack_array('STRING MATCH : webscantest')), arr)
| extend arr = iff(csUriQuery contains 'http://appspidered.rapid7.com' , array_concat(arr, pack_array('STRING MATCH : appspider')), arr)
| where array_length(arr) > 0
| project-away pak;
let cIP_MethodHighCount = codeInjectionAttempts 
| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), cIP_MethodCount = count() 
by cIP, tostring(arr), cIP_MethodCountType = ""High Count of cIP and csMethod, this may be noise"" 
| where cIP_MethodCount >=  cIP_MethodCountLimit;
let codeInjectAtt = 
codeInjectionAttempts 
| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), cIP_MethodCount = count() 
by cIP, cIP_MethodCountType = ""Count of repeated entries, this is to reduce rowsets returned"", csMethod, 
tostring(arr), csHost, scStatus, sIP, csUriStem, csUriQuery, csUserName, csUserAgent, csCookie, csReferer;
// union the events and sort by cIP_MethodCount to identify potentially noisy entries.  Additionally, cIP_MethodCountType 
// indicates whether it is a high count or simply a count of repeated entries
(union isfuzzy=true
cIP_MethodHighCount, codeInjectAtt
| sort by cIP_MethodCount desc, cIP desc, StartTimeUtc desc)
| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName, URLCustomEntity = csUriQuery
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/Potential_IIS_CodeInject.yaml,2020-10-04,Potential_IIS_CodeInject.yaml
b725d62c-eb77-42ff-96f6-bdc6745fc6e0,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1203,Exploitation for Client Execution,SaaS,Detection,Azure Sentinel Community Github,New UserAgent observed in last 24 hours,"'Identifies new UserAgents observed in the last 24 hours versus the previous 14 days. This detection 
extracts words from user agents to build the baseline and determine rareity rather than perform a 
direct comparison. This avoids FPs caused by version numbers and other high entropy user agent components.
These new UserAgents could be benign. However, in normally stable environments,
these new UserAgents could provide a starting point for investigating malicious activity.
Note: W3CIISLog can be noisy depending on the environment, however OfficeActivity and AWSCloudTrail are
usually stable with low numbers of detections.'
",AzureMonitor(IIS),W3CIISLog,"
let starttime = 14d;
let endtime = 1d;
let UserAgentAll = 
(union isfuzzy=true
(OfficeActivity
| where TimeGenerated >= ago(starttime)
| where isnotempty(UserAgent)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = ClientIP, Account = UserId, Type, RecordType, Operation
),
(
W3CIISLog
| where TimeGenerated >= ago(starttime)
| where isnotempty(csUserAgent)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = csUserAgent, SourceIP = cIP, Account = csUserName, Type, sSiteName, csMethod, csUriStem
),
(
AWSCloudTrail
| where TimeGenerated >= ago(starttime)
| where isnotempty(UserAgent)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = SourceIpAddress, Account = UserIdentityUserName, Type, EventSource, EventName
))
// remove wordSize blocks of non-numeric hex characters prior to word extraction
| extend UserAgentNoHexAlphas = replace(""([A-Fa-f]{4,})"", ""x"", UserAgent)
// once blocks of hex chars are removed, extract wordSize blocks of a-z
| extend Tokens = extract_all(""([A-Za-z]{4,})"", UserAgentNoHexAlphas)
// concatenate extracted words to create a summarized user agent for baseline and comparison
| extend NormalizedUserAgent = strcat_array(Tokens, ""|"")
| project-away UserAgentNoHexAlphas, Tokens;
UserAgentAll
| where StartTime >= ago(endtime)
| summarize StartTime = min(StartTime), EndTime = max(EndTime), count() by UserAgent, NormalizedUserAgent, SourceIP, Account, Type, RecordType, Operation, EventSource, EventName, sSiteName, csMethod, csUriStem
| join kind=leftanti
(
UserAgentAll
| where StartTime < ago(endtime)
| summarize by NormalizedUserAgent, SourceIP, Account, Type, RecordType, Operation, EventSource, EventName, sSiteName, csMethod, csUriStem
)
on NormalizedUserAgent
| extend timestamp = StartTime, IPCustomEntity = SourceIP, AccountCustomEntity = Account
",1d,14d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NewUserAgentLast24h.yaml,2020-10-04,NewUserAgentLast24h.yaml
a357535e-f722-4afe-b375-cff362b2b376,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1203,Exploitation for Client Execution,Office 365,Detection,Azure Sentinel Community Github,Malformed user agent,"'Malware authors will sometimes hardcode user agent string values when writing the network communication component of their malware.
Malformed user agents can be an indication of such malware.'
",Office365,OfficeActivity,"
let endtime = 1d;
(union isfuzzy=true
(OfficeActivity | where TimeGenerated >= ago(endtime) | where UserAgent != """"),
(OfficeActivity
| where TimeGenerated >= ago(endtime)
| where RecordType in (""AzureActiveDirectoryAccountLogon"", ""AzureActiveDirectoryStsLogon"")
| extend OperationName = Operation, UserAgent = extractjson(""$[0].Value"", ExtendedProperties, typeof(string))),
(AzureDiagnostics
| where TimeGenerated >= ago(endtime)
| where ResourceType =~ ""APPLICATIONGATEWAYS"" 
| where OperationName =~ ""ApplicationGatewayAccess"" 
| extend ClientIP = columnifexists(""clientIP_s"", ""None""), UserAgent = columnifexists(""userAgent_s"", ""None"")))
// Likely artefact of hardcoding
| where UserAgent startswith ""User"" or UserAgent startswith ""\""""
// Incorrect casing
or (UserAgent startswith ""Mozilla"" and not(UserAgent containscs ""Mozilla""))
// Incorrect casing
or UserAgent containscs  ""(Compatible;""
// Missing MSIE version
or UserAgent matches regex @""MSIE\s?;""
// Incorrect spacing around MSIE version
or UserAgent matches regex  @""MSIE(?:\d|.{1,5}?\d\s;)""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationNames = makeset(OperationName), UserAgentCount = dcount(UserAgent), 
UserAgentList = makeset(UserAgent), RecordTypes = makeset(RecordType) by UserId, ClientIP
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP, AccountCustomEntity = UserId
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MalformedUserAgents.yaml,2020-10-04,MalformedUserAgents.yaml
df75ac6c-7b0b-40d2-82e4-191c012f1a07,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1203,Exploitation for Client Execution,SaaS,Hunting Query,Azure Sentinel Community Github,Exploit and Pentest Framework User Agent,"'There are several exploit and pen test frameworks that are being used by pen testers as well as attackers to 
compromise an environment and achieve their objective. The query tries to detect suspicious user agent strings 
used by these frameworks in some of the data sources that contain UserAgent field. 
This is based out of sigma rules described in references.
References: https://github.com/Neo23x0/sigma/blob/master/rules/proxy/proxy_ua_frameworks.yml'
",AzureMonitor(IIS),W3CIISLog,"
let timeframe = 14d;
let UserAgentList = ""Internet Explorer |Mozilla/4\\.0 \\(compatible; MSIE 6\\.0; Windows NT 5\\.1; SV1; InfoPath\\.2\\)|Mozilla/5\\.0 \\(Windows NT 10\\.0; Win32; x32; rv:60\\.0\\)|Mozilla/4\\.0 \\(compatible; Metasploit RSPEC\\)|Mozilla/4\\.0 \\(compatible; MSIE 6\\.1; Windows NT\\)|Mozilla/4\\.0 \\(compatible; MSIE 6\\.0; Windows NT 5\\.1\\)|Mozilla/4\\.0 \\(compatible; MSIE 8\\.0; Windows NT 6\\.0; Trident/4\\.0\\)|Mozilla/4\\.0 \\(compatible; MSIE 7\\.0; Windows NT 6\\.0; Trident/4\\.0; SIMBAR={7DB0F6DE-8DE7-4841-9084-28FA914B0F2E}; SLCC1; \\.N|Mozilla/5\\.0 \\(Windows; U; Windows NT 5\\.1; en-US\\) AppleWebKit/525\\.13 \\(KHTML, like Gecko\\) Chrome/4\\.0\\.221\\.6 Safari/525\\.13|Mozilla/5\\.0 \\(compatible; MSIE 9\\.0; Windows NT 6\\.1; WOW64; Trident/5\\.0; MAAU\\)|Mozilla/5\\.0[^\\s]|Mozilla/4\\.0 \\(compatible; SPIPE/1\\.0|Mozilla/5\\.0 \\(Windows NT 6\\.3; rv:39\\.0\\) Gecko/20100101 Firefox/35\\.0|Sametime Community Agent|X-FORWARDED-FOR|DotDotPwn v2\\.1|SIPDROID|wordpress hash grabber|exploit|okhttp/"";
// Excluding for IIS, as the main malicious usage for okhttp that we have seen was in the OfficeActivity logs and this can create noise for IIS.
let ExcludeIIS = ""okhttp/"";
(union isfuzzy=true
(OfficeActivity
| where TimeGenerated >= ago(timeframe) 
| where ExtendedProperties has ""UserAgent""
| extend UserAgent = extractjson(""$[0].Value"", ExtendedProperties, typeof(string))
| where UserAgent matches regex UserAgentList
| project TimeGenerated, Type, UserAgent, SourceIP
| extend IPCustomEntity = SourceIP
),
(
W3CIISLog
| where TimeGenerated >= ago(timeframe)
| extend UserAgent = replace('\\+', ' ', csUserAgent) 
| where UserAgent matches regex UserAgentList
| where UserAgent !startswith ExcludeIIS
| extend SourceIP = cIP
| project TimeGenerated, Type, UserAgent, SourceIP
| extend IPCustomEntity = SourceIP
),
(
AWSCloudTrail
| where TimeGenerated >= ago(timeframe) 
| where UserAgent matches regex UserAgentList
| extend SourceIP = SourceIpAddress
| project TimeGenerated, Type, UserAgent, SourceIP
))
| summarize min(TimeGenerated), max(TimeGenerated), count() by Type, UserAgent, SourceIP
| extend timestamp = min_TimeGenerated, IPCustomEntity = SourceIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UseragentExploitPentest.yaml,2020-10-04,UseragentExploitPentest.yaml
01f64465-b1ef-41ea-a7f5-31553a11ad43,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1204,User Execution,Windows,Detection,Azure Sentinel Community Github,Network endpoint to host executable correlation,"'Correlates blocked URLs hosting [malicious] executables with host endpoint data
to identify potential instances of executables of the same name having been recently run.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let endpointData = 
(SecurityEvent
  | where TimeGenerated >= ago(timeframe) 
  | where EventID == 4688
  | extend shortFileName = tostring(split(NewProcessName, '\\')[-1])
  );
// Correlate suspect executables seen in TrendMicro rule updates with similar activity on endpoints
CommonSecurityLog
| where TimeGenerated >= ago(timeframe)
| where DeviceVendor =~ ""Trend Micro""
| where Activity =~ ""Deny List updated"" 
| where RequestURL endswith "".exe""
| project TimeGenerated, Activity , RequestURL , SourceIP, DestinationIP
| extend suspectExeName = tolower(tostring(split(RequestURL, '/')[-1]))
| join (endpointData) on $left.suspectExeName == $right.shortFileName 
| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, URLCustomEntity = RequestURL
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NetworkEndpointCorrelation.yaml,2020-10-04,NetworkEndpointCorrelation.yaml
9f86885f-f31f-4e66-a39d-352771ee789e,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1204,User Execution,Windows,Detection,Azure Sentinel Community Github,Known Malware Detected,"'This creates an incident when a known Malware is detected on a endpoint managed by a Carbon Black.'
",VMwareCarbonBlack,CarbonBlackEvents_CL,"
let timeframe = ago(1h);
CarbonBlackEvents_CL
| where TimeGenerated > timeframe
| extend eventTime = datetime(1970-01-01) + tolong(eventTime_d/1000) * 1sec
| where targetApp_effectiveReputation_s =~ ""KNOWN_MALWARE""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by eventTime, deviceDetails_deviceName_s, deviceDetails_deviceIpAddress_s, processDetails_fullUserName_s, processDetails_targetName_s
| extend timestamp = StartTime, AccountCustomEntity = processDetails_fullUserName_s, HostCustomEntity = deviceDetails_deviceName_s, IPCustomEntity = deviceDetails_deviceIpAddress_s
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/VMwareCarbonBlack/KnownMalwareDetected.yaml,2020-10-04,KnownMalwareDetected.yaml
074ce265-f684-41cd-af07-613c5f3e6d0d,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1043,Commonly Used Port,GCP,Detection,Azure Sentinel Community Github,Known Strontium group domains,"'Matches domain name IOCs related to Strontium group activity with CommonSecurityLog, DnsEvents and VMConnection dataTypes.
References: https://blogs.microsoft.com/on-the-issues/2019/07/17/new-cyberthreats-require-new-ways-to-protect-democracy/.'
",PaloAltoNetworks,CommonSecurityLog,"
let timeframe = 1d;
let DomainNames = dynamic([""irf.services"",""microsoft-onthehub.com"",""msofficelab.com"",""com-mailbox.com"",""my-sharefile.com"",""my-sharepoints.com"",
""accounts-web-mail.com"",""customer-certificate.com"",""session-users-activities.com"",""user-profile-credentials.com"",""verify-linke.com"",""support-servics.net"",
""onedrive-sharedfile.com"",""onedrv-live.com"",""transparencyinternational-my-sharepoint.com"",""transparencyinternational-my-sharepoints.com"",""soros-my-sharepoint.com""]);
(union isfuzzy=true
(CommonSecurityLog 
| where TimeGenerated >= ago(timeframe) 
| parse Message with * '(' DNSName ')' * 
| extend Account = SourceUserID, Host = DeviceName, IPAddress = SourceIP),
(DnsEvents 
| where TimeGenerated >= ago(timeframe) 
| extend IPAddress = ClientIP, DNSName = Name, Host = Computer),
(VMConnection 
| where TimeGenerated >= ago(timeframe) 
| parse RemoteDnsCanonicalNames with * '[""' DNSName '""]' *
| extend IPAddress = RemoteIp, Host = Computer)
)
| where isnotempty(DNSName)
| where DNSName  in~ (DomainNames)
| extend timestamp = TimeGenerated, IPCustomEntity = IPAddress, AccountCustomEntity = Account, HostCustomEntity = Host",1d,1d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/StrontiumIOCs.yaml,2020-10-04,StrontiumIOCs.yaml
155f40c6-610d-497d-85fc-3cf06ec13256,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1043,Commonly Used Port,Office 365,Detection,Azure Sentinel Community Github,Known Phosphorus group domains/IP,"'Matches domain name IOCs related to Phosphorus group activity with CommonSecurityLog, DnsEvents, OfficeActivity and VMConnection dataTypes.
References: https://blogs.microsoft.com/on-the-issues/2019/03/27/new-steps-to-protect-customers-from-hacking/.'
",Office365,OfficeActivity,"
let timeframe = 1d;
let DomainNames = dynamic([""yahoo-verification.org"",""support-servics.com"",""verification-live.com"",""com-mailbox.com"",""com-myaccuants.com"",""notification-accountservice.com"",
""accounts-web-mail.com"",""customer-certificate.com"",""session-users-activities.com"",""user-profile-credentials.com"",""verify-linke.com"",""support-servics.net"",""verify-linkedin.net"", 
""yahoo-verification.net"",""yahoo-verify.net"",""outlook-verify.net"",""com-users.net"",""verifiy-account.net"",""te1egram.net"",""account-verifiy.net"",""myaccount-services.net"",
""com-identifier-servicelog.name"",""microsoft-update.bid"",""outlook-livecom.bid"",""update-microsoft.bid"",""documentsfilesharing.cloud"",""com-microsoftonline.club"",
""confirm-session-identifier.info"",""session-management.info"",""confirmation-service.info"",""document-share.info"",""broadcast-news.info"",""customize-identity.info"",""webemail.info"",
""com-identifier-servicelog.info"",""documentsharing.info"",""notification-accountservice.info"",""identifier-activities.info"",""documentofficupdate.info"",""recoveryusercustomer.info"",
""serverbroadcast.info"",""account-profile-users.info"",""account-service-management.info"",""accounts-manager.info"",""activity-confirmation-service.info"",""com-accountidentifier.info"",
""com-privacy-help.info"",""com-sessionidentifier.info"",""com-useraccount.info"",""confirmation-users-service.info"",""confirm-identity.info"",""confirm-session-identification.info"",
""continue-session-identifier.info"",""customer-recovery.info"",""customers-activities.info"",""elitemaildelivery.info"",""email-delivery.info"",""identify-user-session.info"",
""message-serviceprovider.info"",""notificationapp.info"",""notification-manager.info"",""recognized-activity.info"",""recover-customers-service.info"",""recovery-session-change.info"",
""service-recovery-session.info"",""service-session-continue.info"",""session-mail-customers.info"",""session-managment.info"",""session-verify-user.info"",""shop-sellwear.info"",
""supportmailservice.info"",""terms-service-notification.info"",""user-activity-issues.info"",""useridentity-confirm.info"",""users-issue-services.info"",""verify-user-session.info"",
""login-gov.info"",""notification-signal-agnecy.info"",""notifications-center.info"",""identifier-services-sessions.info"",""customers-manager.info"",""session-manager.info"",
""customer-managers.info"",""confirmation-recovery-options.info"",""service-session-confirm.info"",""session-recovery-options.info"",""services-session-confirmation.info"",
""notification-managers.info"",""activities-services-notification.info"",""activities-recovery-options.info"",""activity-session-recovery.info"",""customers-services.info"",
""sessions-notification.info"",""download-teamspeak.info"",""services-issue-notification.info"",""microsoft-upgrade.mobi"",""broadcastnews.pro"",""mobile-messengerplus.network""]);
let IPList = dynamic([""51.91.200.147""]);
let IPRegex = '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}';
(union isfuzzy=true
(CommonSecurityLog 
| where TimeGenerated >= ago(timeframe)
| parse Message with * '(' DNSName ')' * 
| extend MessageIP = extract(IPRegex, 0, Message)
| extend RequestURLIP = extract(IPRegex, 0, Message)
| where (isnotempty(SourceIP) and SourceIP in (IPList)) or (isnotempty(DestinationIP) and DestinationIP in (IPList)) 
or (isnotempty(DNSName) and DNSName in~ (DomainNames)) or (isnotempty(DestinationHostName) and DestinationHostName in~ (DomainNames)) or (isnotempty(RequestURL) and (RequestURL has_any (DomainNames) or RequestURLIP in (IPList))) 
or (isnotempty(Message) and MessageIP in (IPList))
| extend IPMatch = case(SourceIP in (IPList), ""SourceIP"", DestinationIP in (IPList), ""DestinationIP"", MessageIP in (IPList), ""Message"", RequestURLIP in (IPList), ""RequestUrl"", ""NoMatch"") 
| extend timestamp = TimeGenerated , IPCustomEntity = case(IPMatch == ""SourceIP"", SourceIP, IPMatch == ""DestinationIP"", DestinationIP,IPMatch == ""Message"", MessageIP,
IPMatch == ""RequestUrl"", RequestURLIP,""NoMatch""), Account = SourceUserID, Host = DeviceName
),
(DnsEvents 
| where TimeGenerated >= ago(timeframe) 
| extend DestinationIPAddress = IPAddresses, DNSName = Name, Host = Computer
| where  DestinationIPAddress in (IPList) or DNSName in~ (DomainNames) 
| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host),
(VMConnection 
| where TimeGenerated >= ago(timeframe) 
| parse RemoteDnsCanonicalNames with * '[""' DNSName '""]' *
| where isnotempty(SourceIP) or isnotempty(DestinationIP) or isnotempty(DNSName)
| where SourceIP in (IPList) or DestinationIP in (IPList) or DNSName in~ (DomainNames)
| extend IPMatch = case( SourceIP in (IPList), ""SourceIP"", DestinationIP in (IPList), ""DestinationIP"", ""None"") 
| extend timestamp = TimeGenerated , IPCustomEntity = case(IPMatch == ""SourceIP"", SourceIP, IPMatch == ""DestinationIP"", DestinationIP, ""None""), Host = Computer),
(OfficeActivity
| where TimeGenerated >= ago(timeframe)
| extend SourceIPAddress = ClientIP, Account = UserId
| where  SourceIPAddress in (IPList)
| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account )
)
",1d,1d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/PhosphorusIOCs.yaml,2020-10-04,PhosphorusIOCs.yaml
b8b7574f-1cd6-4308-822a-ab07256106f8,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1043,Commonly Used Port,Office 365,Hunting Query,Azure Sentinel Community Github,Retrospective hunt for STRONTIUM IP IOCs,"'Matches domain name IOCs related to Strontium group activity with CommonSecurityLog and SecurityAlert dataTypes.
The query is scoped in the time window that these IOCs were active.
References: https://blogs.microsoft.com/on-the-issues/2019/07/17/new-cyberthreats-require-new-ways-to-protect-democracy.'
",AzureSecurityCenter,SecurityAlert,"
let STRONTIUM_IPS = dynamic([""82.118.242.171"" , ""167.114.153.55"" , ""94.237.37.28"", ""31.220.61.251"" , ""128.199.199.187"" ]);
(union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))
| where SourceIP in (STRONTIUM_IPS) or DestinationIP in (STRONTIUM_IPS)
| extend IPCustomEntity = SourceIP
),
(SecurityAlert
| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))
| extend RemoteAddress = iff(ExtendedProperties has ""RemoteAddress"", tostring(parse_json(ExtendedProperties)[""RemoteAddress""]), ""None"")
| where RemoteAddress != ""None""
| where RemoteAddress in (STRONTIUM_IPS)
| extend IPCustomEntity = RemoteAddress
) 
)
| extend timestamp = TimeGenerated",,,,,High,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/STRONTIUM_IOC_RetroHunt.yaml,2020-10-04,STRONTIUM_IOC_RetroHunt.yaml
2b701288-b428-4fb8-805e-e4372c574786,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1136,Create Account,Azure AD,Detection,Azure Sentinel Community Github,Anomalous login followed by Teams action,"'Detects anomalous IP address usage by user accounts and then checks to see if a suspicious Teams action is performed.
Query calculates IP usage Delta for each user account and selects accounts where a delta >= 90% is observed between the most and least used IP.
To further reduce results the query performs a prevalence check on the lowest used IP's country, only keeping IP's where the country is unusual for the tenant (dynamic ranges)
Finally the user accounts activity within Teams logs is checked for suspicious commands (modifying user privileges or admin actions) during the period the suspicious IP was active.'
",AzureActiveDirectory,SigninLogs,"
//The bigger the window the better the data sample size, as we use IP prevalence, more sample data is better.
let timeRange = 30d;
//The minimum number of countries that the account has been accessed from [default: 2]
let minimumCountries = 2;
//The delta (%) between the largest in-use IP and the smallest [default: 90]
let deltaThreshold = 95;
//The maximum (%) threshold that the country appears in login data [default: 10]
let countryPrevalenceThreshold = 10;
//The time to project forward after the last login activity [default: 60min]
let projectedEndTime = 60min; 
//Get Teams successful signins globally
let signinData =
  SigninLogs
  | where TimeGenerated >= ago(timeRange)
  | where AppDisplayName has ""Teams""
  | where ConditionalAccessStatus =~ ""success""
  | extend country = tostring(LocationDetails['countryOrRegion'])
  | where isnotempty(country) and isnotempty(IPAddress);
// Collect successful signins to teams
let loginEvents = 
  signinData
  | summarize count(), country=any(country), make_list(TimeGenerated) by IPAddress, UserPrincipalName;
//Calcualte delta between logins
let loginDelta =
  loginEvents
  | summarize max(count_), min(count_) by UserPrincipalName
  | extend delta = toreal(max_count_ - min_count_) / max_count_ * 100
  | where delta >= deltaThreshold;
//Count number of countries used to sign in
let countryCount =
  loginEvents
  | summarize Countries = dcount(country) by UserPrincipalName;
//Join delta and sign in counts to successful logins
loginDelta
| join kind=rightouter  (
  loginEvents
) on UserPrincipalName
| join kind=rightouter (
  countryCount
) on UserPrincipalName
//Check where the record meets the minimum required countries
| where Countries >= minimumCountries
| join kind=leftouter (
      signinData
      | summarize count() by country
      | join (
          //Now get the total number of logins from any country and join it to the previous count in a single table
          signinData
          | summarize count() by country
          | summarize sum(count_), make_list(country)
          | mv-expand list_country
          | extend country = tostring(list_country)
      ) on country
      | summarize by country, count_, sum_count_
      //Now calculate each countries prevalence within login events
      | extend prevalence = toreal(count_) / toreal(sum_count_) * 100
      | project-away sum_count_
      | order by prevalence
) on country
//The % that suspicious country is prevalent in data, this can be configured, less than 10% is uncommon
| where prevalence < countryPrevalenceThreshold
| where min_count_ == count_
//Login start and end times from the JSON object, this is the activity window the suspicious IP was active within
| extend EventTimes = list_TimeGenerated
| extend SuspiciousIP = IPAddress
| project UserPrincipalName, SuspiciousIP, UserIPDelta = delta, SuspiciousLoginCountry = country, SuspiciousCountryPrevalence = prevalence, EventTimes
//Teams join to collect operations the user account has performed within the given time range
| join kind=inner( 
  TeamsData 
  | where TimeGenerated >= ago(timeRange)
  | where Operation in~ (""TeamsAdminAction"", ""MemberAdded"", ""MemberRemoved"", ""MemberRoleChanged"", ""AppInstalled"", ""BotAddedToTeam"")
  | project Operation, UserId=tolower(UserId), OperationTime=TimeGenerated
) on $left.UserPrincipalName == $right.UserId
| mv-expand StartTime = EventTimes
| extend StartTime = make_datetime(StartTime)
//The end time is projected 60 minutes forward, in case actions took place within the last hour of the final login for the suspicious IP
| extend ProjectedEndTime = make_datetime(StartTime + projectedEndTime)
//Limit to operations carried out by the user account in the timeframe the IP was active
| where OperationTime between (StartTime .. ProjectedEndTime)
| project UserPrincipalName, SuspiciousIP, StartTime, ProjectedEndTime, OperationTime, Operation, SuspiciousLoginCountry, SuspiciousCountryPrevalence
//Filter on suspicious actions
| extend activitySummary = pack(tostring(StartTime), pack(""Operation"",tostring(Operation), ""OperationTime"", OperationTime))
| summarize make_bag(activitySummary) by UserPrincipalName, SuspiciousIP, SuspiciousLoginCountry, SuspiciousCountryPrevalence
| extend IPCustomEntity = SuspiciousIP, AccountCustomEntity = UserPrincipalName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AnomalousIPUsageFollowedByTeamsAction.yaml,2020-10-04,AnomalousIPUsageFollowedByTeamsAction.yaml
f2dd4a3a-ebac-4994-9499-1a859938c947,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Azure,Detection,Azure Sentinel Community Github,Time series anomaly for data size transferred to public internet,"'Identifies anomalous data transfer to public networks. The query leverages built-in KQL anomaly detection algorithms that detects large deviations from a baseline pattern. 
A sudden increase in data transferred to unknown public networks is an indication of data exfiltration attempts and should be investigated. 
The higher the score, the further it is from the baseline value.
The output is aggregated to provide summary view of unique source IP to destination IP address and port bytes sent traffic observed in the flagged anomaly hour. 
The source IP addresses which were sending less than bytessentperhourthreshold have been exluded whose value can be adjusted as needed .
You may have to run queries for individual source IP addresses from SourceIPlist to determine if anything looks suspicious'
",AzureMonitor(VMInsights),VMConnection,"
let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let scorethreshold = 5;
let bytessentperhourthreshold = 10;
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.';
let TimeSeriesData = (union isfuzzy=true
(
VMConnection
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| where isnotempty(DestinationIP) and isnotempty(SourceIP)
| extend DestinationIpType = iff(DestinationIp matches regex PrivateIPregex,""private"" ,""public"" )
| where DestinationIpType == ""public"" | extend DeviceVendor = ""VMConnection""
| project TimeGenerated, BytesSent, DeviceVendor
| make-series TotalBytesSent=sum(BytesSent) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor
),
(
CommonSecurityLog 
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| where isnotempty(DestinationIP) and isnotempty(SourceIP)
| extend DestinationIpType = iff(DestinationIP matches regex PrivateIPregex,""private"" ,""public"" )
| where DestinationIpType == ""public""
| project TimeGenerated, SentBytes, DeviceVendor
| make-series TotalBytesSent=sum(SentBytes) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor
)
);
//Filter anomolies against TimeSeriesData
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent, scorethreshold, -1, 'linefit')
| mv-expand TotalBytesSent to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend AnomalyHour = TimeGenerated 
| extend TotalBytesSentinMBperHour = round(((TotalBytesSent / 1024)/1024),2), baselinebytessentperHour = round(((baseline / 1024)/1024),2), score = round(score,2)
| project DeviceVendor, AnomalyHour, TimeGenerated, TotalBytesSentinMBperHour, baselinebytessentperHour, anomalies, score;
//Union of all BaseLogs aggregated per hour
let BaseLogs = (union isfuzzy=true
(
CommonSecurityLog 
| where isnotempty(DestinationIP) and isnotempty(SourceIP)
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime))) 
| extend SentBytesinMB = ((SentBytes / 1024)/1024), ReceivedBytesinMB = ((ReceivedBytes / 1024)/1024) 
| summarize HourlyCount = count(), TimeGeneratedMax=arg_max(TimeGenerated, *), DestinationIPList=make_set(DestinationIP), DestinationPortList = make_set(DestinationPort), TotalSentBytesinMB = sum(SentBytesinMB), TotalReceivedBytesinMB = sum(ReceivedBytesinMB) by SourceIP, DeviceVendor, TimeGeneratedHour=bin(TimeGenerated,1h)
| project DeviceVendor, TimeGeneratedHour, TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB
| where TotalSentBytesinMB > bytessentperhourthreshold
),
(
VMConnection 
| where isnotempty(DestinationIp) and isnotempty(SourceIp)
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime))) 
| extend DeviceVendor = ""VMConnection"", SourceIP = SourceIp, DestinationIP = DestinationIp
| extend SentBytesinMB = ((BytesSent / 1024)/1024), ReceivedBytesinMB = ((BytesReceived / 1024)/1024)
| summarize HourlyCount = count(),TimeGeneratedMax=arg_max(TimeGenerated, *), DestinationIPList=make_set(DestinationIP), DestinationPortList = make_set(DestinationPort), TotalSentBytesinMB = sum(SentBytesinMB),TotalReceivedBytesinMB = sum(ReceivedBytesinMB) by SourceIP, DestinationIP, DeviceVendor, TimeGeneratedHour=bin(TimeGenerated,1h)
| project DeviceVendor, TimeGeneratedHour, TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB 
| where TotalSentBytesinMB > bytessentperhourthreshold
)
);
// Join against base logs to retrive records associated with the hour of anomoly
TimeSeriesAlerts
| join (
    BaseLogs | extend AnomalyHour = TimeGeneratedHour
) on DeviceVendor, AnomalyHour | sort by score desc 
| project DeviceVendor, AnomalyHour,TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies 
| summarize EventCount = count(), StartTimeUtc= min(TimeGeneratedMax), EndTimeUtc= max(TimeGeneratedMax), SourceIPMax= arg_max(SourceIP,*), TotalBytesSentinMB = sum(TotalSentBytesinMB), TotalBytesReceivedinMB = sum(TotalReceivedBytesinMB), SourceIPList = make_set(SourceIP), DestinationIPList = make_set(DestinationIPList) by AnomalyHour,TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies
| project DeviceVendor, AnomalyHour, StartTimeUtc, EndTimeUtc, SourceIPMax, SourceIPList, DestinationIPList, DestinationPortList, TotalBytesSentinMB, TotalBytesReceivedinMB, TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies, EventCount  
| extend timestamp =EndTimeUtc, IPCustomEntity = SourceIPMax 
",1h,14d,gt,1.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/TimeSeriesAnomaly-MultiVendor_DataExfiltration.yaml,2020-10-04,TimeSeriesAnomaly-MultiVendor_DataExfiltration.yaml
4b11568b-3f5f-4ba1-80c8-7f1dc8390eb7,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Office 365,Detection,Azure Sentinel Community Github,SharePointFileOperation via previously unseen IPs,"'Identifies when the volume of documents uploaded to or downloaded from Sharepoint by new IP addresses
exceeds a threshold (default is 50).'
",Office365,OfficeActivity,"
let threshold = 50;
let szSharePointFileOperation = ""SharePointFileOperation"";
let szOperations = dynamic([""FileDownloaded"", ""FileUploaded""]);
let starttime = 14d;
let endtime = 1d;
let historicalActivity =
OfficeActivity
| where TimeGenerated between(ago(starttime)..ago(endtime))
| where RecordType =~ szSharePointFileOperation
| where Operation in~ (szOperations)
| summarize historicalCount = count() by ClientIP, RecordType, Operation;
let recentActivity = OfficeActivity
| where TimeGenerated > ago(endtime)
| where RecordType =~ szSharePointFileOperation
| where Operation in~ (szOperations)
| summarize min(Start_Time), max(Start_Time), recentCount = count() by ClientIP, RecordType, Operation;
let RareIP = recentActivity | join kind= leftanti ( historicalActivity ) on ClientIP, RecordType, Operation
// More than 50 downloads/uploads from a new IP
| where recentCount > threshold;
OfficeActivity 
| where TimeGenerated >= ago(endtime) 
| where RecordType =~ szSharePointFileOperation
| where Operation in~ (szOperations)
| join kind= inner (RareIP) on ClientIP, RecordType, Operation
| where Start_Time between(min_Start_Time .. max_Start_Time)
| summarize StartTimeUtc = min(min_Start_Time), EndTimeUtc = max(max_Start_Time) by RecordType, Operation, UserType, UserId, ClientIP, OfficeWorkload, Site_Url, OfficeObjectId, UserAgent, IPSeenCount = recentCount
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Site_Url
| order by IPSeenCount desc, ClientIP asc, Operation asc, UserId asc
",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/SharePoint_Downloads_byNewIP.yaml,2020-10-04,SharePoint_Downloads_byNewIP.yaml
5dd76a87-9f87-4576-bab3-268b0e2b338b,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Office 365,Detection,Azure Sentinel Community Github,SharePointFileOperation via devices with previously unseen user agents,"'Identifies if the number of documents uploaded or downloaded from device(s) associated
with a previously unseen user agent exceeds a threshold (default is 5).'
",Office365,OfficeActivity,"
let threshold = 5;
let szSharePointFileOperation = ""SharePointFileOperation"";
let szOperations = dynamic([""FileDownloaded"", ""FileUploaded""]);
let starttime = 14d;
let endtime = 1d;
let historicalActivity =
OfficeActivity
| where TimeGenerated between(ago(starttime)..ago(endtime))
| where RecordType =~ szSharePointFileOperation
| where Operation in~ (szOperations)
| where isnotempty(UserAgent)
| summarize historicalCount = count() by UserAgent, RecordType, Operation;
let recentActivity = OfficeActivity
| where RecordType =~ szSharePointFileOperation
| where Operation in~ (szOperations)
| where TimeGenerated > ago(endtime)
| where isnotempty(UserAgent)
| summarize min(Start_Time), max(Start_Time), recentCount = count() by UserAgent, RecordType, Operation;
let RareUserAgent = recentActivity | join kind = leftanti (historicalActivity) on UserAgent
| order by recentCount desc, UserAgent
// More than 3 downloads/uploads from a new user agent today
| where recentCount > threshold;
OfficeActivity 
| where TimeGenerated > ago(endtime) 
| where RecordType =~ szSharePointFileOperation 
| where Operation in~ (szOperations)
| where isnotempty(UserAgent)
| join kind= inner (RareUserAgent)
on UserAgent, RecordType, Operation    
| where Start_Time between(min_Start_Time .. max_Start_Time)
| summarize StartTimeUtc = min(min_Start_Time), EndTimeUtc = max(max_Start_Time) by RecordType, Operation, UserAgent, UserType, UserId, ClientIP, OfficeWorkload, Site_Url, OfficeObjectId, UserAgentSeenCount = recentCount
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Site_Url
| order by UserAgentSeenCount desc, UserAgent asc, Operation asc, UserId asc
",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/SharePoint_Downloads_byNewUserAgent.yaml,2020-10-04,SharePoint_Downloads_byNewUserAgent.yaml
06a9b845-6a95-4432-a78b-83919b28c375,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,GCP,Detection,Azure Sentinel Community Github,Time series anomaly detection for total volume of traffic,"'Identifies anamalous spikes in network traffic logs as compared to baseline or normal historical patterns. 
The query leverages a KQL built-in anomaly detection algorithm to find large deviations from baseline patterns. 
Sudden increases in network traffic volume may be an indication of data exfiltration attempts and should be investigated.
The higher the score, the further it is from the baseline value.
The output is aggregated to provide summary view of unique source IP to destination IP address and port traffic observed in the flagged anomaly hour. 
The source IP addresses which were sending less than percentotalthreshold of the total traffic have been exluded whose value can be adjusted as needed .
You may have to run queries for individual source IP addresses from SourceIPlist to determine if anything looks suspicious'
",PaloAltoNetworks,CommonSecurityLog,"
let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let scorethreshold = 5;
let percentotalthreshold = 25;
let TimeSeriesData = CommonSecurityLog 
| where isnotempty(DestinationIP) and isnotempty(SourceIP)
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| project TimeGenerated,SourceIP, DestinationIP, DeviceVendor
| make-series Total=count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor;
//Filtering specific records associated with spikes as outliers
let TimeSeriesAlerts=TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')
| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend score = round(score,2), AnomalyHour = TimeGenerated
| project DeviceVendor,AnomalyHour, TimeGenerated, Total, baseline, anomalies, score;
//Join anomalies with Base Data to popalate associated records for investigation - Results sorted by score in descending order 
TimeSeriesAlerts 
| join (
    CommonSecurityLog 
| where isnotempty(DestinationIP) and isnotempty(SourceIP)
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| summarize HourlyCount = count(), TimeGeneratedMax = arg_max(TimeGenerated, *), DestinationIPlist = make_set(DestinationIP), DestinationPortlist = make_set(DestinationPort) by DeviceVendor, SourceIP, TimeGeneratedHour= bin(TimeGenerated, 1h)
| extend AnomalyHour = TimeGeneratedHour
) on AnomalyHour, DeviceVendor 
| extend PercentTotal = round((HourlyCount / Total) * 100, 3)
| where PercentTotal > percentotalthreshold
| project DeviceVendor , AnomalyHour, TimeGeneratedMax, SourceIP, DestinationIPlist, DestinationPortlist, HourlyCount, PercentTotal, Total, baseline, score, anomalies
| summarize HourlyCount=sum(HourlyCount), StartTimeUtc=min(TimeGeneratedMax), EndTimeUtc=max(TimeGeneratedMax), SourceIPlist = make_set(SourceIP), SourceIPMax= arg_max(SourceIP, *), DestinationIPlist = make_set(DestinationIPlist), DestinationPortlist = make_set(DestinationPortlist) by DeviceVendor , AnomalyHour, Total, baseline, score, anomalies
| project DeviceVendor , AnomalyHour, EndTimeUtc, SourceIPMax ,SourceIPlist, DestinationIPlist, DestinationPortlist, HourlyCount, Total, baseline, score, anomalies
| extend timestamp= EndTimeUtc , IPCustomEntity = SourceIPMax
",1h,14d,gt,3.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/TimeSeriesAnomaly-MultiVendor_NetworkTraffic.yaml,2020-10-04,TimeSeriesAnomaly-MultiVendor_NetworkTraffic.yaml
e472c490-4792-4f12-8b6b-6ab3e0404d35,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Linux,Hunting Query,Azure Sentinel Community Github,Squid data volume timeseries anomalies,"'Malware infections or data exfiltration activity often leads to anomalies in network data volume
this hunting query looks for anomalies in the volume of bytes traversing a squid proxy. Anomalies require further 
investigation to determine cause. This query presumes the default squid log format is being used.'
",Syslog,Syslog,"
let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let TimeSeriesData = 
Syslog
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
         Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
         contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where isnotempty(Bytes)
| make-series TotalBytesSent=sum(Bytes) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by ProcessName;
TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent,3, -1, 'linefit')
| extend timestamp = TimeGenerated
| render timechart with (title=""Squid Time Series anomalies"")
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/squid_volume_anomalies.yaml,2020-10-04,squid_volume_anomalies.yaml
e8ae1375-4640-430c-ae8e-2514d09c71eb,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Office 365,Hunting Query,Azure Sentinel Community Github,SharePointFileOperation via clientIP with previously unseen user agents,"'New user agents associated with a clientIP for sharepoint file uploads/downloads.'
",Office365,OfficeActivity,"
let starttime = 14d;
let endtime = 1d;
let historicalUA=
OfficeActivity
| where  RecordType == ""SharePointFileOperation""
| where Operation in (""FileDownloaded"", ""FileUploaded"")
| where TimeGenerated between(ago(starttime)..ago(endtime))
| summarize by ClientIP, UserAgent;
let recentUA = OfficeActivity
| where  RecordType == ""SharePointFileOperation""
| where Operation in (""FileDownloaded"", ""FileUploaded"")
| where TimeGenerated > ago(endtime) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by ClientIP, UserAgent;
recentUA | join kind=leftanti (
   historicalUA 
) on ClientIP, UserAgent
// Some OfficeActivity records do not contain ClientIP information - exclude these for fewer results:
| where not(isempty(ClientIP)) 
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/sharepoint_downloads.yaml,2020-10-04,sharepoint_downloads.yaml
f2367171-1514-4c67-88ef-27434b6a1093,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Office 365,Hunting Query,Azure Sentinel Community Github,SharePointFileOperation via devices with previously unseen user agents,"'Tracking via user agent is one way to differentiate between types of connecting device. 
In homogeneous enterprise environments the user agent associated with an attacker device may stand out as unusual.'
",Office365,OfficeActivity,"
let starttime = 14d;
let endtime = 1d;
let historicalActivity=
OfficeActivity
| where  RecordType == ""SharePointFileOperation""
| where Operation in (""FileDownloaded"", ""FileUploaded"")
| where TimeGenerated between(ago(starttime)..ago(endtime))
| summarize historicalCount=count() by UserAgent, RecordType;
let recentActivity = OfficeActivity
| where  RecordType == ""SharePointFileOperation""
| where Operation in (""FileDownloaded"", ""FileUploaded"")
| where TimeGenerated > ago(endtime) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), recentCount=count() by UserAgent, RecordType;
recentActivity | join kind = leftanti (
   historicalActivity 
) on UserAgent, RecordType
| order by recentCount asc, UserAgent
| extend timestamp = StartTimeUtc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/new_sharepoint_downloads_by_UserAgent.yaml,2020-10-04,new_sharepoint_downloads_by_UserAgent.yaml
e3d24cfd-b2a1-4ba7-8f80-0360892f9d57,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,Office 365,Hunting Query,Azure Sentinel Community Github,SharePointFileOperation via previously unseen IPs,"'Shows volume of documents uploaded to or downloaded from Sharepoint by new IP addresses. 
In stable environments such connections by new IPs may be unauthorized, especially if associated with 
spikes in volume which could be associated with large-scale document exfiltration.'
",Office365,OfficeActivity,"
let starttime = 14d;
let endtime = 1d;
let historicalActivity=
OfficeActivity
| where  RecordType == ""SharePointFileOperation""
| where Operation in (""FileDownloaded"", ""FileUploaded"")
| where TimeGenerated between(ago(starttime)..ago(endtime))
| summarize historicalCount=count() by ClientIP;
let recentActivity = OfficeActivity
| where  RecordType == ""SharePointFileOperation""
| where Operation in (""FileDownloaded"", ""FileUploaded"")
| where TimeGenerated > ago(endtime) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), recentCount=count() by ClientIP;
recentActivity | join kind= leftanti (
   historicalActivity 
) on ClientIP 
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/new_sharepoint_downloads_by_IP.yaml,2020-10-04,new_sharepoint_downloads_by_IP.yaml
a04cf847-a832-4c60-b687-b0b6147da219,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1114,Email Collection,Office 365,Detection,Azure Sentinel Community Github,Known Manganese IP and UserAgent activity,"'Matches IP plus UserAgent IOCs in OfficeActivity data, along with IP plus Connection string information in the CommonSecurityLog data related to Manganese group activity.
References: 
https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101/
https://fortiguard.com/psirt/FG-IR-18-384'
",Office365,OfficeActivity,"
let timeframe = 1d;
let IPList = dynamic([""45.63.52.41"",""140.82.17.161"",""207.148.101.95"",""45.32.87.51"",""66.42.98.156"",""45.76.144.105"",""217.163.28.35"",""45.32.141.174"",""149.28.165.249"",""209.250.225.247"",""45.63.100.115"",""95.179.229.230"",""209.250.233.247"",""45.77.121.232"",""45.76.175.65"",""104.238.160.237"",""45.77.181.97"",""95.179.192.125"",""149.28.93.184"",""140.82.16.81"",""45.76.173.103"",""45.77.255.22"",""45.32.11.71"",""149.28.77.26"",""45.32.54.50"",""104.156.233.156"",""45.32.21.118"",""45.63.62.109"",""45.77.244.202"",""149.248.11.205"",""104.238.190.244""]);
let IOCTerms = ""\\?lang=[/..]*/dev/cmdb/sslvpn_websession|/dana-na/jam/[/..]*home/webserver/htdocs/dana/html5acc/guacamole[/..]*etc/passwd\\?"";
(union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated >= ago(1d) 
| where isnotempty(SourceIP) or isnotempty(DestinationIP)
| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList)
| extend IPMatch = case(
SourceIP in (IPList), ""SourceIP"", 
DestinationIP in (IPList), ""DestinationIP"",
""Message"") 
| where Message matches regex IOCTerms
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch
| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == ""SourceIP"", SourceIP, IPMatch == ""DestinationIP"", DestinationIP, ""IP in Message Field"") 
),
(OfficeActivity
| where TimeGenerated >= ago(1d) 
| where isnotempty(UserAgent) and ClientIP in (IPList)
| where UserAgent contains ""ExchangeServicesClient/0.0.0.0""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP = ClientIP, Account = UserId, Type, RecordType, OfficeWorkload, UserAgent, OfficeObjectId, IPMatch = ""ClientIP""
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = SourceIP
)
)",1d,1d,gt,0.0,High,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Manganese_VPN-IOCs.yaml,2020-10-04,Manganese_VPN-IOCs.yaml
957cb240-f45d-4491-9ba5-93430a3c08be,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1114,Email Collection,Office 365,Detection,Azure Sentinel Community Github,Rare and potentially high-risk Office operations,"'Identifies Office operations that are typically rare and can provide capabilities useful to attackers.'
",Office365,OfficeActivity,"
let timeframe = 1d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where Operation in~ ( ""Add-MailboxPermission"", ""Add-MailboxFolderPermission"", ""Set-Mailbox"", ""New-ManagementRoleAssignment"")
and not(UserId has_any ('NT AUTHORITY\\SYSTEM (Microsoft.Exchange.ServiceHost)','devilfish-applicationaccount') and Operation in~ ( ""Add-MailboxPermission"", ""Set-Mailbox""))
| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/RareOfficeOperations.yaml,2020-10-04,RareOfficeOperations.yaml
723c5f46-133f-4f1e-ada6-5c138f811d75,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1114,Email Collection,Office 365,Hunting Query,Azure Sentinel Community Github,New Admin account activity seen which was not seen historically,"'This will help you discover any new admin account activity which was seen and were not seen historically. 
Any new accounts seen in the results can be validated and investigated for any suspicious activities.'
",Office365,OfficeActivity,"
let starttime = 14d;
let endtime = 1d;
let historicalActivity=
OfficeActivity
| where TimeGenerated between(ago(starttime)..ago(endtime))
| where RecordType==""ExchangeAdmin"" and UserType in (""Admin"",""DcAdmin"")
| summarize historicalCount=count() by UserId;
let recentActivity = OfficeActivity
| where TimeGenerated > ago(endtime)
| where UserType in (""Admin"",""DcAdmin"")
| summarize recentCount=count() by UserId;
recentActivity | join kind = leftanti (
   historicalActivity
) on UserId
| project UserId,recentCount
| order by recentCount asc, UserId
| join kind = rightsemi 
(OfficeActivity 
| where TimeGenerated >= ago(endtime) 
| where RecordType == ""ExchangeAdmin"" | where UserType in (""Admin"",""DcAdmin"")) 
on UserId
| summarize count(), min(TimeGenerated), max(TimeGenerated) by RecordType, Operation, UserType, UserId, OriginatingServer, ResultStatus
| extend timestamp = min_TimeGenerated, AccountCustomEntity = UserId
",,,,,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/new_adminaccountactivity.yaml,2020-10-04,new_adminaccountactivity.yaml
80733eb7-35b2-45b6-b2b8-3c51df258206,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1102,Web Service,Linux,Detection,Azure Sentinel Community Github,Squid proxy events related to mining pools,"'Checks for Squid proxy events in Syslog associated with common mining pools .This query presumes the default Squid log format is being used. 
 http://www.squid-cache.org/Doc/config/access_log/'
",Syslog,Syslog,"
let timeframe = 1d;
let DomainList = dynamic([""monerohash.com"", ""do-dear.com"", ""xmrminerpro.com"", ""secumine.net"", ""xmrpool.com"", ""minexmr.org"", ""hashanywhere.com"", ""xmrget.com"", 
""mininglottery.eu"", ""minergate.com"", ""moriaxmr.com"", ""multipooler.com"", ""moneropools.com"", ""xmrpool.eu"", ""coolmining.club"", ""supportxmr.com"",
""minexmr.com"", ""hashvault.pro"", ""xmrpool.net"", ""crypto-pool.fr"", ""xmr.pt"", ""miner.rocks"", ""walpool.com"", ""herominers.com"", ""gntl.co.uk"", ""semipool.com"", 
""coinfoundry.org"", ""cryptoknight.cc"", ""fairhash.org"", ""baikalmine.com"", ""tubepool.xyz"", ""fairpool.xyz"", ""asiapool.io"", ""coinpoolit.webhop.me"", ""nanopool.org"", 
""moneropool.com"", ""miner.center"", ""prohash.net"", ""poolto.be"", ""cryptoescrow.eu"", ""monerominers.net"", ""cryptonotepool.org"", ""extrmepool.org"", ""webcoin.me"", 
""kippo.eu"", ""hashinvest.ws"", ""monero.farm"", ""supportxmr.com"", ""xmrpool.eu"", ""linux-repository-updates.com"", ""1gh.com"", ""dwarfpool.com"", ""hash-to-coins.com"", 
""hashvault.pro"", ""pool-proxy.com"", ""hashfor.cash"", ""fairpool.cloud"", ""litecoinpool.org"", ""mineshaft.ml"", ""abcxyz.stream"", ""moneropool.ru"", ""cryptonotepool.org.uk"",
""extremepool.org"", ""extremehash.com"", ""hashinvest.net"", ""unipool.pro"", ""crypto-pools.org"", ""monero.net"", ""backup-pool.com"", ""mooo.com"", ""freeyy.me"", ""cryptonight.net"",
""shscrypto.net""]);
Syslog
| where TimeGenerated >= ago(timeframe)
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
        SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
        Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
        HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
        User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
        RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
        Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
        Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
        contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where HTTP_Status_Code == '200'
| where Domain contains "".""
| where Domain has_any (DomainList)
| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/squid_cryptomining_pools.yaml,2020-10-04,squid_cryptomining_pools.yaml
4d500e6d-c984-43a3-9f39-7edec8dcc04d,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1071,Application Layer Protocol,GCP,Detection,Azure Sentinel Community Github,Request for single resource on domain,"'This will look for connections to a domain where only a single file is requested, this is unusual as most modern web applications require additional recources. This type of activity is often assocaited with malware beaconing or tracking URL's delivered in emails. Developed for Zscaler but applicable to any outbound web logging.'
",Zscaler,CommonSecurityLog,"
let timeRange = 1d;
let scriptExtensions = dynamic(["".php"", "".aspx"", "".asp"", "".cfml""]);
//The number of URI's seen to be suspicious, higher = less likely to be suspicious
let uriThreshold = 1;
CommonSecurityLog
| where TimeGenerated >= ago(timeRange)
// Only look at connections that were allowed through the web proxy
| where DeviceVendor =~ ""Zscaler"" and DeviceAction =~ ""Allowed""
// Only look where some data was exchanged.
| where SentBytes > 0 and ReceivedBytes > 0
// Extract the Domain
| extend Domain = iff(countof(DestinationHostName,'.') >= 2, strcat(split(DestinationHostName,'.')[-2], '.',split(DestinationHostName,'.')[-1]), DestinationHostName)
| extend GetData=iff(RequestURL == ""?"", 1, 0)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makelist(RequestURL), makelist(DestinationIP), makelist(SourceIP), numOfConnections = count(), make_set(RequestMethod), max(GetData), max(RequestContext) by Domain
// Determine the number of URIs that have been visited for the domain
| extend destinationURI = arraylength(list_RequestURL)
| where destinationURI <= uriThreshold
| where tostring(list_RequestURL) has_any(scriptExtensions)
//Remove matches with referer
| where max_RequestContext == """"
//Keep requests where data was trasferred either in a GET with parameters or a POST
| where set_RequestMethod in~ (""POST"") or max_GetData == 1
//Defeat email click tracking, may increase FN's while decreasing FP's
| where list_RequestURL !has ""click"" and set_RequestMethod !has ""GET""
| mvexpand list_RequestURL, list_DestinationIP
| extend RequestURL = tostring(list_RequestURL), DestinationIP = tostring(list_DestinationIP), ClientIP = tostring(list_SourceIP)
//Extend custom entitites for incidents
| extend timestamp = StartTimeUtc, IPCustomEntity = DestinationIP
| project-away list_RequestURL, list_DestinationIP, list_SourceIP, destinationURI, Domain, StartTimeUtc, EndTimeUtc, max_GetData, max_RequestContext
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/Zscaler-LowVolumeDomainRequests.yaml,2020-10-04,Zscaler-LowVolumeDomainRequests.yaml
90e198a9-efb6-4719-ad89-81b8e93633a7,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1199,Trusted Relationship,Office 365,Hunting Query,Azure Sentinel Community Github,Files uploaded to teams and access summary,"'Provides a summary of files uploaded to teams chats and extracts 
the users and IP addresses that have accessed them.'
",Office365,OfficeActivity,"
OfficeActivity 
| where RecordType =~ ""SharePointFileOperation"" 
| where UserId != ""app@sharepoint""
| where SourceRelativeUrl contains ""Microsoft Teams Chat Files"" 
| where Operation =~ ""FileUploaded"" 
| join kind= leftouter ( 
   OfficeActivity 
    | where RecordType =~ ""SharePointFileOperation""
    | where UserId != ""app@sharepoint""
    | where SourceRelativeUrl contains ""Microsoft Teams Chat Files"" 
    | where Operation =~ ""FileDownloaded"" or Operation =~ ""FileAccessed"" 
) on OfficeObjectId 
| extend userBag = pack(UserId1, ClientIP1) 
| summarize makeset(UserId1), make_bag(userBag) by TimeGenerated, UserId, OfficeObjectId, SourceFileName 
| extend NumberUsers = array_length(bag_keys(bag_userBag))
| project timestamp=TimeGenerated, AccountCustomEntity=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName, AccessedBy=bag_userBag, NumberOfUsersAccessed=NumberUsers
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/TeamsFilesUploaded.yaml,2020-10-04,TeamsFilesUploaded.yaml
2ca4e7fc-c61a-49e5-9736-5da8035c47e0,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1210,Exploitation of Remote Services,Windows,Detection,Azure Sentinel Community Github,Critical Threat Detected,"'This creates an incident in the event a critical threat was identified on a Carbon Black managed endpoint.'
",VMwareCarbonBlack,CarbonBlackNotifications_CL,"
let timeframe = ago(1h);
let threshold = 8;
CarbonBlackNotifications_CL
| where TimeGenerated > timeframe
| where threatHunterInfo_score_d >= threshold
| extend eventTime = datetime(1970-01-01) + tolong(threatHunterInfo_time_d/1000) * 1sec
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by eventTime, Threat_Name = threatHunterInfo_reportName_s, Device_Name = deviceInfo_deviceName_s,  Internal_IP = deviceInfo_internalIpAddress_s, External_IP = deviceInfo_externalIpAddress_s, Threat_Score = threatHunterInfo_score_d
| project-away count_
| extend timestamp = StartTime, HostCustomEntity = Device_Name, IPCustomEntity = Internal_IP
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/VMwareCarbonBlack/CriticalThreatDetected.yaml,2020-10-04,CriticalThreatDetected.yaml
78422ef2-62bf-48ca-9bab-72c69818a425,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1076,Remote Desktop Protocol,Windows,Detection,Azure Sentinel Community Github,Multiple RDP connections from Single System,"'Identifies when an RDP connection is made to multiple systems and above the normal for the previous 7 days.  
Connections from the same system with the same account within the same day.
RDP connections are indicated by the EventID 4624 with LogonType = 10'
",SecurityEvents,SecurityEvent,"
let endtime = 1d;
let starttime = 8d;
let threshold = 2.0;
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)  
by Account, IpAddress, AccountType, Activity, LogonTypeName
| join kind=inner (
SecurityEvent
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize ComputerCountPrev7Days = dcount(Computer) by Account, IpAddress
) on Account, IpAddress
| extend Ratio = ComputerCountToday/(ComputerCountPrev7Days*1.0)
// Where the ratio of today to previous 7 days is more than double.
| where Ratio > threshold
| project StartTimeUtc, EndTimeUtc, Account, IpAddress, ComputerSet, ComputerCountToday, ComputerCountPrev7Days, Ratio, AccountType, Activity, LogonTypeName, ProcessSet
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = IpAddress
",1d,8d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RDP_MultipleConnectionsFromSingleSystem.yaml,2020-10-04,RDP_MultipleConnectionsFromSingleSystem.yaml
69a45b05-71f5-45ca-8944-2e038747fb39,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1076,Remote Desktop Protocol,Windows,Detection,Azure Sentinel Community Github,RDP Nesting,"'Identifies when an RDP connection is made to a first system and then an RDP connection is made from the first system 
to another system with the same account within the 60 minutes. Additionally, if historically daily  
RDP connections are indicated by the logged EventID 4624 with LogonType = 10'
",SecurityEvents,SecurityEvent,"
let endtime = 1d;
let starttime = 8d;
// The threshold below excludes matching on RDP connection computer counts of 5 or more by a given account and IP in a given day.  Change the threshold as needed.
let threshold = 5;
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
// Labeling the first RDP connection time, computer and ip
| extend FirstHop = TimeGenerated, FirstComputer = toupper(Computer), FirstIPAddress = IpAddress, Account = tolower(Account)  
| join kind=inner (
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
// Labeling the second RDP connection time, computer and ip
| extend SecondHop = TimeGenerated, SecondComputer = toupper(Computer), SecondIPAddress = IpAddress, Account = tolower(Account)
) on Account
// Make sure that the first connection is after the second connection --> SecondHop > FirstHop
// Then identify only RDP to another computer from within the first RDP connection by only choosing matches where the Computer names do not match --> FirstComputer != SecondComputer
// Then make sure the IPAddresses do not match by excluding connections from the same computers with first hop RDP connections to multiple computers --> FirstIPAddress != SecondIPAddress
| where FirstComputer != SecondComputer and FirstIPAddress != SecondIPAddress and SecondHop > FirstHop
// where the second hop occurs within 30 minutes of the first hop
| where SecondHop <= FirstHop+30m
| distinct Account, FirstHop, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, SecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName
// use left anti to exclude anything from the previous 7 days where the Account and IP has connected 5 or more computers.
| join kind=leftanti (
SecurityEvent
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize makeset(Computer), ComputerCount = dcount(Computer) by bin(TimeGenerated, 1d), Account = tolower(Account), IpAddress
// Connection count to computer by same account and IP to exclude counts of 5 or more on a given day
| where ComputerCount >= threshold
| mvexpand set_Computer
| extend Computer = toupper(set_Computer)
) on Account, $left.SecondComputer == $right.Computer, $left.SecondIPAddress == $right.IpAddress
| summarize FirstHopFirstSeen = min(FirstHop), FirstHopLastSeen = max(FirstHop) by Account, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, 
SecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName
| extend timestamp = FirstHopFirstSeen, AccountCustomEntity = Account, HostCustomEntity = FirstComputer, IPCustomEntity = FirstIPAddress
",1d,8d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RDP_Nesting.yaml,2020-10-04,RDP_Nesting.yaml
45b903c5-6f56-4969-af10-ae62ac709718,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1076,Remote Desktop Protocol,Windows,Detection,Azure Sentinel Community Github,Rare RDP Connections,"'Identifies when an RDP connection is new or rare related to any logon type by a given account today based on comparison with the previous 14 days.
RDP connections are indicated by the EventID 4624 with LogonType = 10'
",SecurityEvents,SecurityEvent,"
let starttime = 14d;
let endtime = 1d;
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count() 
by Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName
// use left anti to exclude anything from the previous 14 days that is not rare
| join kind=leftanti (
SecurityEvent
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| where EventID == 4624
| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)
) on Account, Computer
| summarize StartTime = min(StartTime), EndTime = max(EndTime), ConnectionCount = sum(ConnectionCount)  
by Account, Computer, IpAddress, AccountType, Activity, LogonTypeName, ProcessName
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress",1d,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RDP_RareConnection.yaml,2020-10-04,RDP_RareConnection.yaml
ef88eb96-861c-43a0-ab16-f3835a97c928,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1208,Kerberoasting,Windows,Detection,Azure Sentinel Community Github,Powershell Empire cmdlets seen in command line,"'Identifies instances of PowerShell Empire cmdlets in powershell process command line data.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let regexEmpire = @""SetDelay|GetDelay|Set-LostLimit|Get-LostLimit|Set-Killdate|Get-Killdate|Set-WorkingHours|Get-WorkingHours|Get-Sysinfo|Add-Servers|Invoke-ShellCommand|Start-AgentJob|Update-Profile|Get-FilePart|Encrypt-Bytes|Decrypt-Bytes|Encode-Packet|Decode-Packet|Send-Message|Process-Packet|Process-Tasking|Get-Task|Start-Negotiate|Invoke-DllInjection|Invoke-ReflectivePEInjection|Invoke-Shellcode|Invoke-ShellcodeMSIL|Get-ChromeDump|Get-ClipboardContents|Get-IndexedItem|Get-Keystrokes|Invoke-Inveigh|Invoke-NetRipper|local:Invoke-PatchDll|Invoke-NinjaCopy|Get-Win32Types|Get-Win32Constants|Get-Win32Functions|Sub-SignedIntAsUnsigned|Add-SignedIntAsUnsigned|Compare-Val1GreaterThanVal2AsUInt|Convert-UIntToInt|Test-MemoryRangeValid|Write-BytesToMemory|Get-DelegateType|Get-ProcAddress|Enable-SeDebugPrivilege|Invoke-CreateRemoteThread|Get-ImageNtHeaders|Get-PEBasicInfo|Get-PEDetailedInfo|Import-DllInRemoteProcess|Get-RemoteProcAddress|Copy-Sections|Update-MemoryAddresses|Import-DllImports|Get-VirtualProtectValue|Update-MemoryProtectionFlags|Update-ExeFunctions|Copy-ArrayOfMemAddresses|Get-MemoryProcAddress|Invoke-MemoryLoadLibrary|Invoke-MemoryFreeLibrary|Out-Minidump|Get-VaultCredential|Invoke-DCSync|Translate-Name|Get-NetDomain|Get-NetForest|Get-NetForestDomain|Get-DomainSearcher|Get-NetComputer|Get-NetGroupMember|Get-NetUser|Invoke-Mimikatz|Invoke-PowerDump|Invoke-TokenManipulation|Exploit-JMXConsole|Exploit-JBoss|Invoke-Thunderstruck|Invoke-VoiceTroll|Set-WallPaper|Invoke-PsExec|Invoke-SSHCommand|Invoke-PSInject|Invoke-RunAs|Invoke-SendMail|Invoke-Rule|Get-OSVersion|Select-EmailItem|View-Email|Get-OutlookFolder|Get-EmailItems|Invoke-MailSearch|Get-SubFolders|Get-GlobalAddressList|Invoke-SearchGAL|Get-SMTPAddress|Disable-SecuritySettings|Reset-SecuritySettings|Get-OutlookInstance|New-HoneyHash|Set-MacAttribute|Invoke-PatchDll|Get-SecurityPackages|Install-SSP|Invoke-BackdoorLNK|New-ElevatedPersistenceOption|New-UserPersistenceOption|Add-Persistence|Invoke-CallbackIEX|Add-PSFirewallRules|Invoke-EventLoop|Invoke-PortBind|Invoke-DNSLoop|Invoke-PacketKnock|Invoke-CallbackLoop|Invoke-BypassUAC|Get-DecryptedCpassword|Get-GPPInnerFields|Invoke-WScriptBypassUAC|Get-ModifiableFile|Get-ServiceUnquoted|Get-ServiceFilePermission|Get-ServicePermission|Invoke-ServiceUserAdd|Invoke-ServiceCMD|Write-UserAddServiceBinary|Write-CMDServiceBinary|Write-ServiceEXE|Write-ServiceEXECMD|Restore-ServiceEXE|Invoke-ServiceStart|Invoke-ServiceStop|Invoke-ServiceEnable|Invoke-ServiceDisable|Get-ServiceDetail|Find-DLLHijack|Find-PathHijack|Write-HijackDll|Get-RegAlwaysInstallElevated|Get-RegAutoLogon|Get-VulnAutoRun|Get-VulnSchTask|Get-UnattendedInstallFile|Get-Webconfig|Get-ApplicationHost|Write-UserAddMSI|Invoke-AllChecks|Invoke-ThreadedFunction|Test-Login|Get-UserAgent|Test-Password|Get-ComputerDetails|Find-4648Logons|Find-4624Logons|Find-AppLockerLogs|Find-PSScriptsInPSAppLog|Find-RDPClientConnections|Get-SystemDNSServer|Invoke-Paranoia|Invoke-WinEnum{|Get-SPN|Invoke-ARPScan|Invoke-Portscan|Invoke-ReverseDNSLookup|Invoke-SMBScanner|New-InMemoryModule|Add-Win32Type|Export-PowerViewCSV|Get-MacAttribute|Copy-ClonedFile|Get-IPAddress|Convert-NameToSid|Convert-SidToName|Convert-NT4toCanonical|Get-Proxy|Get-PathAcl|Get-NameField|Convert-LDAPProperty|Get-NetDomainController|Add-NetUser|Add-NetGroupUser|Get-UserProperty|Find-UserField|Get-UserEvent|Get-ObjectAcl|Add-ObjectAcl|Invoke-ACLScanner|Get-GUIDMap|Get-ADObject|Set-ADObject|Get-ComputerProperty|Find-ComputerField|Get-NetOU|Get-NetSite|Get-NetSubnet|Get-DomainSID|Get-NetGroup|Get-NetFileServer|SplitPath|Get-DFSshare|Get-DFSshareV1|Get-DFSshareV2|Get-GptTmpl|Get-GroupsXML|Get-NetGPO|Get-NetGPOGroup|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Invoke-ImpersonateUser|Create-ProcessWithToken|Free-AllTokens|Enum-AllTokens|Invoke-RevertToSelf|Set-Speaker(\$Volume){\$wshShell|Local:Get-RandomString|Local:Invoke-PsExecCmd|Get-GPPPassword|Local:Inject-BypassStuff|Local:Invoke-CopyFile\(\$sSource,|ind-Fruit|New-IPv4Range|New-IPv4RangeFromCIDR|Parse-Hosts|Parse-ILHosts|Exclude-Hosts|Get-TopPort|Parse-Ports|Parse-IpPorts|Remove-Ports|Write-PortscanOut|Convert-SwitchtoBool|Get-ForeignUser|Get-ForeignGroup"";
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName;
processEvents};
let decodedPS = ProcessCreationEvents
| where TimeGenerated >= ago(timeframe) 
| where CommandLine contains "" -encodedCommand""
| parse kind=regex flags=i CommandLine with * ""-EncodedCommand "" encodedCommand
| project StartTimeUtc = TimeGenerated, encodedCommand = tostring(split(encodedCommand, ' ')[0]), CommandLine
// Note: currently the base64_decodestring function is limited to supporting UTF8
| extend decodedCommand = translate('\0','', base64_decodestring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand);
(decodedPS
| union 
(ProcessCreationEvents
| where TimeGenerated >= ago(timeframe)
| where FileName in~ (""powershell.exe"",""powershell_ise.exe"")
| where CommandLine !contains ""-encodedcommand"")
| extend StartTimeUtc = TimeGenerated
)
| where CommandLine matches regex regexEmpire
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/powershell_empire.yaml,2020-10-04,powershell_empire.yaml
1572e66b-20a7-4012-9ec4-77ec4b101bc8,2020-10-04 07:11:15.6720053,mitre-attack,CredentialAccess,T1208,Kerberoasting,Windows,Detection,Azure Sentinel Community Github,Potential Kerberoasting,"'A service principal name (SPN) is used to uniquely identify a service instance in a Windows environment. 
Each SPN is usually associated with a service account. Organizations may have used service accounts with weak passwords in their environment. 
An attacker can try requesting Kerberos ticket-granting service (TGS) service tickets for any SPN from a domain controller (DC) which contains 
a hash of the Service account. This can then be used for offline cracking. This hunting query looks for accounts that are generating excessive 
requests to different resources within the last hour compared with the previous 24 hours.  Normal users would not make an unusually large number 
of request within a small time window. This is based on 4769 events which can be very noisy so environment based tweaking might be needed.'
",SecurityEvents,SecurityEvent,"
let starttime = 1d;
let endtime = 1h;
let prev23hThreshold = 4;
let prev1hThreshold = 15;
let Kerbevent =
SecurityEvent
| where TimeGenerated >= ago(starttime)
| where EventID == 4769
| parse EventData with * 'TicketEncryptionType"">' TicketEncryptionType ""<"" *
| where TicketEncryptionType == '0x17'
| parse EventData with * 'TicketOptions"">' TicketOptions ""<"" *
| where TicketOptions == '0x40810000'
| parse EventData with * 'Status"">' Status ""<"" *
| where Status == '0x0'
| parse EventData with * 'ServiceName"">' ServiceName ""<"" *
| where ServiceName !contains ""$"" and ServiceName !contains ""krbtgt"" 
| parse EventData with * 'TargetUserName"">' TargetUserName ""<"" *
| where TargetUserName !contains ""$@"" and TargetUserName !contains ServiceName
| parse EventData with * 'IpAddress"">::ffff:' ClientIPAddress ""<"" *;
let Kerbevent23h = Kerbevent
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)
| summarize ServiceNameCountPrev23h = dcount(ServiceName), ServiceNameSet23h = makeset(ServiceName) 
by Computer, TargetUserName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status
| where ServiceNameCountPrev23h < prev23hThreshold;
let Kerbevent1h = 
Kerbevent
| where TimeGenerated >= ago(endtime)
| summarize min(TimeGenerated), max(TimeGenerated), ServiceNameCountPrev1h = dcount(ServiceName), ServiceNameSet1h = makeset(ServiceName) 
by Computer, TargetUserName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status;
Kerbevent1h 
| join kind=leftanti
(
Kerbevent23h
) on TargetUserName
// Threshold value set above is based on testing, this value may need to be changed for your environment.
| where ServiceNameCountPrev1h > prev1hThreshold
| project StartTimeUtc = min_TimeGenerated, EndTimeUtc = max_TimeGenerated, TargetUserName, Computer, ClientIPAddress, TicketOptions, 
TicketEncryptionType, Status, ServiceNameCountPrev1h, ServiceNameSet1h
| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, IPCustomEntity = ClientIPAddress",1h,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/PotentialKerberoast.yaml,2020-10-04,PotentialKerberoast.yaml
49a4f65a-fe18-408e-afec-042fde93d3ce,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1059,Command and Scripting Interpreter,Office 365,Hunting Query,Azure Sentinel Community Github,Powershell or non-browser mailbox login activity,"'This will help you determine if mailbox login was done from Exchange Powershell session. 
By default, all accounts you create in Office 365 are allowed to use Exchange Online PowerShell. 
Administrators can use Exchange Online PowerShell to enable or disable a user's ability to connect to Exchange Online PowerShell.
Whitelist any benign scheduled activities using exchange powershell if applicable in your environment.
References: https://docs.microsoft.com/powershell/exchange/exchange-online/connect-to-exchange-online-powershell/connect-to-exchange-online-powershell?view=exchange-ps'
",Office365,OfficeActivity,"
let timeframe = 1d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where Operation == ""MailboxLogin""
| where ClientInfoString == ""Client=Microsoft.Exchange.Powershell; Microsoft WinRM Client""
| summarize count(), min(TimeGenerated), max(TimeGenerated) by Operation, OrganizationName, UserType, UserId, MailboxOwnerUPN, Logon_Type, ClientInfoString
| extend timestamp = min_TimeGenerated, AccountCustomEntity = UserId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/powershell_or_nonbrowser_MailboxLogin.yaml,2020-10-04,powershell_or_nonbrowser_MailboxLogin.yaml
ca67c83e-7fff-4127-a3e3-1af66d6d4cad,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1140,Deobfuscate/Decode Files or Information,Windows,Detection,Azure Sentinel Community Github,Base64 encoded Windows process command-lines,"'Identifies instances of a base64 encoded PE file header seen in the process command line parameter.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName,
FileName = Process, CommandLine, ParentProcessName;
processEvents};
ProcessCreationEvents
| where CommandLine contains ""TVqQAAMAAAAEAAA""
| where StartTimeUtc >= ago(timeframe)
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/base64_encoded_pefile.yaml,2020-10-04,base64_encoded_pefile.yaml
d6190dde-8fd2-456a-ac5b-0a32400b0464,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1140,Deobfuscate/Decode Files or Information,Windows,Detection,Azure Sentinel Community Github,Process executed from binary hidden in Base64 encoded file,"'Encoding malicious software is a technique used to obfuscate files from detection. 
The first CommandLine component is looking for Python decoding base64. 
The second CommandLine component is looking for Bash/sh command line base64 decoding.
The third one is looking for Ruby decoding base64.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName;
processEvents;
};
ProcessCreationEvents 
| where TimeGenerated > ago(timeframe) 
| where CommandLine contains "".decode('base64')""
        or CommandLine contains ""base64 --decode""
        or CommandLine contains "".decode64("" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), CountToday = count() by Computer, Account, AccountDomain, FileName, CommandLine, ParentProcessName 
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/execute_base64_decodedpayload.yaml,2020-10-04,execute_base64_decodedpayload.yaml
2c55fe7a-b06f-4029-a5b9-c54a2320d7b8,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1064,Scripting,Windows,Detection,Azure Sentinel Community Github,Process execution frequency anomaly,"'Identifies anomalous spike in frequency of executions of sensitive processes which are often leveraged as attack vectors. 
The query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns. 
Sudden increases in execution frequency of sensitive processes should be further investigated for malicious activity.
Tune the values from 1.5 to 3 in series_decompose_anomalies for further outliers or based on custom threshold values for score.'
",SecurityEvents,SecurityEvent,"
let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let TotalEventsThreshold = 5;
let ExeList = dynamic([""powershell.exe"",""cmd.exe"",""wmic.exe"",""psexec.exe"",""cacls.exe"",""rundll.exe""]);
let TimeSeriesData = 
SecurityEvent
| where EventID == 4688 | extend Process = tolower(Process)
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| where Process in (ExeList)
| project TimeGenerated, Computer, AccountType, Account, Process
| make-series Total=count() on TimeGenerated from ago(starttime) to ago(endtime) step timeframe by Process;
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 1.5, -1, 'linefit')
| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)
| where anomalies > 0
| project Process, TimeGenerated, Total, baseline, anomalies, score
| where Total > TotalEventsThreshold;
TimeSeriesAlerts
| join (
SecurityEvent
| where EventID == 4688 | extend Process = tolower(Process)
| summarize CommandlineCount = count() by bin(TimeGenerated, 1h), Process, CommandLine, Computer, Account
) on Process, TimeGenerated 
| project AnomalyHour = TimeGenerated, Computer, Account, Process, CommandLine, CommandlineCount, Total, baseline, anomalies, score 
| extend timestamp = AnomalyHour, AccountCustomEntity = Account, HostCustomEntity = Computer
",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/TimeSeriesAnomaly-ProcessExecutions.yaml,2020-10-04,TimeSeriesAnomaly-ProcessExecutions.yaml
81fd68a2-9ad6-4a1c-7bd7-18efe5c99081,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1064,Scripting,SaaS,Hunting Query,Azure Sentinel Community Github,Rare Custom Script Extension,"'The Custom Script Extension downloads and executes scripts on Azure virtual machines. This extension is useful for post deployment configuration, software installation, or any other configuration or management tasks. 
 Scripts could be downloaded from external links, Azure storage, GitHub, or provided to the Azure portal at extension run time. This could also be used maliciously by an attacker. 
 The query tries to identify rare custom script extensions that have been executed in your envioenment'
",AzureActivity,AzureActivity,"let current = 1d;
let Lookback = 14d;
let CustomScriptExecution = AzureActivity 
| where TimeGenerated >= ago(Lookback) 
| where OperationName =~ ""Create or Update Virtual Machine Extension""
| extend Settings = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).settings)))
| parse Settings with * 'fileUris"":[' FileURI ""]"" *
| parse Settings with * 'commandToExecute"":' commandToExecute '}' *
| extend message_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).statusMessage)).error)).message);
let LookbackCustomScriptExecution = CustomScriptExecution
| where TimeGenerated >= ago(Lookback) and TimeGenerated < ago(current)
| where isnotempty(FileURI) and isnotempty(commandToExecute)
| summarize max(TimeGenerated), OperationCount = count() by Caller, Resource, CallerIpAddress, FileURI, commandToExecute;
let CurrentCustomScriptExecution = CustomScriptExecution
| where TimeGenerated >= ago(current)
| where isnotempty(FileURI) and isnotempty(commandToExecute)
| project TimeGenerated, ActivityStatus, OperationId, CorrelationId, ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage = message_, HTTPRequest, Settings;
let RareCustomScriptExecution =  CurrentCustomScriptExecution
| join kind= leftanti (LookbackCustomScriptExecution) on Caller, CallerIpAddress, FileURI, commandToExecute;
let IPCheck = RareCustomScriptExecution 
| summarize arg_max(TimeGenerated, OperationName), OperationIds = makeset(OperationId), CallerIpAddresses = makeset(CallerIpAddress) by ActivityStatus, CorrelationId, ResourceId, Caller, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage
| extend IPArray = arraylength(CallerIpAddresses);
//Get IPs for later summarization so all associated CorrelationIds and Caller actions have an IP.  Success and Fails do not always have IP
let multiIP = IPCheck | where IPArray > 1
| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses)
| where isnotempty(CallerIpAddresses);
let singleIP = IPCheck | where IPArray <= 1
| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses);
let FullDetails = singleIP | union multiIP;
//Get IP address associated with successes and fails with no IP listed
let IPList = FullDetails | where isnotempty(CallerIpAddress) | summarize by CorrelationId, Caller, CallerIpAddress;
let EmptyIP = FullDetails | where isempty(CallerIpAddress) | project-away CallerIpAddress;
let IpJoin = EmptyIP | join kind= leftouter (IPList) on CorrelationId, Caller | project-away CorrelationId1, Caller1;
let nonEmptyIP = FullDetails | where isnotempty(CallerIpAddress);
nonEmptyIP | union IpJoin
// summarize all activities with a given CorrelationId and Caller together so we can provide a singular result
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityStatusSet = makeset(ActivityStatus), OperationIds = makeset(OperationIds), FailureMessages = makeset(FailureMessage) by CorrelationId, ResourceId, CallerIpAddress, Caller, Resource, ResourceGroup, FileURI, commandToExecute
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Rare_Custom_Script_Extension.yaml,2020-10-04,Rare_Custom_Script_Extension.yaml
75bf9902-0789-47c1-a5d8-f57046aa72df,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1158,Hidden Files and Directories,Windows,Detection,Azure Sentinel Community Github,Malware in the recycle bin,"'Identifies malware that has been hidden in the recycle bin.
References: https://azure.microsoft.com/blog/how-azure-security-center-helps-reveal-a-cyberattack/.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
let procList = dynamic([""cmd.exe"",""ftp.exe"",""schtasks.exe"",""powershell.exe"",""rundll32.exe"",""regsvr32.exe"",""msiexec.exe""]);
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, NewProcessName,
FileName = Process, CommandLine,  ParentProcessName;
processEvents};
ProcessCreationEvents 
| where TimeGenerated >= ago(timeframe)
| where FileName in~ (procList)
| where CommandLine contains "":\\recycler""
| project StartTimeUtc = TimeGenerated, Computer, Account, NewProcessName, FileName, CommandLine, ParentProcessName
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/malware_in_recyclebin.yaml,2020-10-04,malware_in_recyclebin.yaml
80da0a8f-cfe1-4cd0-a895-8bc1771a720e,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1107,File Deletion,Windows,Detection,Azure Sentinel Community Github,Security Event log cleared,"'Checks for event id 1102 which indicates the security event log was cleared. 
It uses Event Source Name ""Microsoft-Windows-Eventlog"" to avoid generating false positives from other sources, like AD FS servers for instance.'
",SecurityEvents,SecurityEvent,"
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 1102 and EventSourceName == ""Microsoft-Windows-Eventlog"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, EventID, Activity
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/SecurityEventLogCleared.yaml,2020-10-04,SecurityEventLogCleared.yaml
610d3850-c26f-4f20-8d86-f10fdf2425f5,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1107,File Deletion,AWS,Detection,Azure Sentinel Community Github,Changes made to AWS CloudTrail logs,"'Attackers often try to hide their steps by deleting or stopping the collection of logs that could show their activity. 
This alert identifies any manipulation of AWS CloudTrail, Cloudwatch/EventBridge or VPC Flow logs.
More Information: AWS CloudTrail API: https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_Operations.html
AWS Cloudwatch/Eventbridge API: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_Operations.html
AWS DelteteFlowLogs API : https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteFlowLogs.html '
",AWS,AWSCloudTrail,"
let timeframe = 1d;
let EventNameList = dynamic([""UpdateTrail"",""DeleteTrail"",""StopLogging"",""DeleteFlowLogs"",""DeleteEventBus""]);
AWSCloudTrail
| where TimeGenerated > ago(timeframe)
| where EventName in~ (EventNameList)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ClearStopChangeTrailLogs.yaml,2020-10-04,AWS_ClearStopChangeTrailLogs.yaml
8675dd7a-795e-4d56-a79c-fc848c5ee61c,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1192,Spearphishing Link,Office 365,Detection,Azure Sentinel Community Github,Malware Link Clicked,"'This query identifies a user clicking on an email link whose threat category is classified as a malware'
",ProofpointTAP,ProofPointTAPClicksPermitted_CL,"
let timeframe = ago(1h);
ProofPointTAPClicksPermitted_CL
| where TimeGenerated >= timeframe
| where classification_s =~ ""malware""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by TimeGenerated, Sender = sender_s, SenderIPAddress = senderIP_s, Recipient = recipient_s, TimeClicked = clickTime_t, URLClicked = url_s
| extend timestamp = StartTime, AccountCustomEntity = Recipient, IPCustomEntity = SenderIPAddress, URLCustomEntity = URLClicked
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointTAP/MalwareLinkClicked.yaml,2020-10-04,MalwareLinkClicked.yaml
1218175f-c534-421c-8070-5dcaabf28067,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1192,Spearphishing Link,,Detection,Azure Sentinel Community Github,Suspicious link sharing pattern,"'Alerts in links that have been shared across multiple Zoom chat channels by the same user in a short space if time. 
Adjust the threshold figure to change the number of channels a message needs to be posted in before an alert is raised.'
",CustomConnector,CustomLogs_CL,"
let threshold = 3; 
let lookback = 1d; 
ZoomLogs 
| where TimeGenerated >= ago(lookback) 
| where Event =~ ""chat_message.sent"" 
| extend Channel = tostring(parse_json(ChatEvents).Channel)  
| extend Message = tostring(parse_json(ChatEvents).Message) 
| where Message matches regex ""http(s?):\\/\\/"" 
| summarize Channels = makeset(Channel), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Message, User, UserId
| extend ChannelCount = arraylength(Channels) 
| where ChannelCount > threshold
| extend timestamp = StartTime, AccountCustomEntity = User",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/SupiciousLinkSharing.yaml,2020-10-04,SupiciousLinkSharing.yaml
0558155e-4556-447e-9a22-828f2a7de06b,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1193,Spearphishing Attachment,Office 365,Detection,Azure Sentinel Community Github,Malware attachment delivered,"'This query identifies a message containing a malware attachment that was delivered.'
",ProofpointTAP,ProofPointTAPMessagesDelivered_CL,"
let timeframe = ago(1h);
ProofPointTAPMessagesDelivered_CL
| where TimeGenerated >= timeframe
| mv-expand todynamic(threatsInfoMap_s)
| mv-expand todynamic(messageParts_s)
| extend threatType = tostring(threatsInfoMap_s.threatType), classification = tostring(threatsInfoMap_s.classification)
| extend filename = tostring(messageParts_s.filename)
| where threatType =~ ""attachment"" and classification =~ ""malware""
| summarize filenames = make_set(filename), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by TimeGenerated, Sender = sender_s, SenderIPAddress = senderIP_s, Recipient = recipient_s, threatType, classification,  Subject = subject_s
| extend timestamp = StartTime, extend AccountCustomEntity = Recipient, IPCustomEntity = SenderIPAddress
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointTAP/MalwareAttachmentDelivered.yaml,2020-10-04,MalwareAttachmentDelivered.yaml
d6491be0-ab2d-439d-95d6-ad8ea39277c5,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1485,Data Destruction,Azure,Detection,Azure Sentinel Community Github,Sensitive Azure Key Vault operations,"'Identifies when sensitive Azure Key Vault operations are used. This includes: VaultDelete, KeyDelete, KeyDecrypt, SecretDelete, SecretPurge, KeyPurge, SecretBackup, KeyBackup. 
Any Backup operations should match with expected scheduled backup activity.'
",AzureMonitor(Keyvault),AzureDiagnostics,"
let timeframe = 1d;
let SensitiveOperationList = dynamic(
[""VaultDelete"", ""KeyDelete"", ""SecretDelete"", ""SecretPurge"", ""KeyPurge"", ""SecretBackup"", ""KeyBackup""]);
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""NoResultType"")
| extend requestUri_s = columnifexists(""requestUri_s"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| extend id_s = columnifexists(""id_s"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None""), clientInfo_s = columnifexists(""clientInfo_s"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where id_s !~ ""None"" and isnotempty(id_s)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where clientInfo_s !~ ""None"" and isnotempty(clientInfo_s)
| where requestUri_s !~ ""None"" and isnotempty(requestUri_s)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success"" 
| where OperationName in~ (SensitiveOperationList)  
| summarize EventCount=count(), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s
| extend timestamp = StartTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDiagnostics/KeyVaultSensitiveOperations.yaml,2020-10-04,KeyVaultSensitiveOperations.yaml
67da5c4e-49f2-476d-96ff-2dbe4b855a48,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1485,Data Destruction,,Hunting Query,Azure Sentinel Community Github,GitHub Mass Deletion of repos or projects,"'This hunting query identifies GitHub activites where there are a large number of deletions that may be a sign of compromise.'
",CustomConnector,CustomLogs_CL,"
let LearningPeriod = 7d;
let BinTime = 1h;
let RunTime = 1h;
let StartTime = 1h;
let NumberOfStds = 3;
let MinThreshold = 10.0;
let EndRunTime = StartTime - RunTime;
let EndLearningTime = StartTime + LearningPeriod;
let GitHubRepositoryDestroyEvents = (GitHubAudit
| where Action == ""repo.destroy"");
GitHubRepositoryDestroyEvents
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))
| summarize count() by bin(TimeGenerated, BinTime)
| summarize AvgInLearning = avg(count_), StdInLearning = stdev(count_)
| extend LearningThreshold = max_of(AvgInLearning + StdInLearning * NumberOfStds, MinThreshold)
| extend Dummy = 1
| join kind=innerunique (
  GitHubRepositoryDestroyEvents
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))
  | summarize CountInRunTime = count() by bin(TimeGenerated, BinTime)
  | extend Dummy = 1
) on Dummy
| project-away Dummy
| where CountInRunTime > LearningThreshold
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Mass%20Deletion%20of%20Repositories%20.yaml,2020-10-04,Mass%20Deletion%20of%20Repositories%20.yaml
c3237d88-fdc4-4dee-8b90-118ded2c507c,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1485,Data Destruction,,Hunting Query,Azure Sentinel Community Github,GitHub First Time Repo Delete,"'This hunting query identifies GitHub activites its the first time a user deleted a repo that may be a sign of compromise.'
",CustomConnector,CustomLogs_CL,"
let LearningPeriod = 7d;
let RunTime = 1h;
let StartTime = 1h;
let EndRunTime = StartTime - RunTime;
let EndLearningTime = StartTime + LearningPeriod;
let GitHubRepositoryDestroyEvents = (GitHubAudit
| where Action == ""repo.destroy"");
GitHubRepositoryDestroyEvents
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))
| distinct Actor
| join kind=rightanti (
  GitHubRepositoryDestroyEvents
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))
  | distinct Actor
) on Actor
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/User%20First%20Time%20Repository%20Delete%20Activity.yaml,2020-10-04,User%20First%20Time%20Repository%20Delete%20Activity.yaml
427e4c9e-8cf4-4094-a684-a2d060dbca38,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1046,Network Service Scanning,Linux,Detection,Azure Sentinel Community Github,Port Scan Detected,"'This alert creates an incident when a source IP addresses attempt to communicate with a large amount of distinct ports within a short period.'
",SophosXGFirewall,Syslog,"
let timeframe = ago(1h);
let threshold = 50;
SophosXGFirewall
| where TimeGenerated >= timeframe
| where Log_Type =~ ""Firewall""
| where not(ipv4_is_match(""10.0.0.0"",Src_IP,8) or ipv4_is_match(""172.16.0.0"",Src_IP,12) or ipv4_is_match(""192.168.0.0"",Src_IP,16))
| summarize dcount(Dst_Port) by Src_IP, bin(TimeGenerated, 5m)
| where dcount_Dst_Port > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = Src_IP
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SophosXGFirewall/PortScanDetected.yaml,2020-10-04,PortScanDetected.yaml
15ae38a2-2e29-48f7-883f-863fb25a5a06,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1046,Network Service Scanning,Windows,Detection,Azure Sentinel Community Github,Rare client observed with high reverse DNS lookup count,"'Identifies clients with a high reverse DNS counts which could be carrying out reconnaissance or discovery activity.
Alert is generated if the IP performing such reverse DNS lookups was not seen doing so in the preceding 7-day period.'
",DNS,DnsEvents,"
let starttime = 8d;
let endtime = 1d;
let threshold = 10;
DnsEvents 
| where TimeGenerated > ago(endtime)
| where Name contains ""in-addr.arpa"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), dcount(Name) by ClientIP
| where dcount_Name > threshold
| project StartTimeUtc, EndTimeUtc, ClientIP , dcount_Name 
| join kind=leftanti (DnsEvents 
    | where TimeGenerated between(ago(starttime)..ago(endtime))
    | where Name contains ""in-addr.arpa"" 
    | summarize dcount(Name) by ClientIP, bin(TimeGenerated, 1d)
    | where dcount_Name > threshold
    | project ClientIP , dcount_Name 
) on ClientIP
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",1d,8d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DnsEvents/DNS_HighReverseDNSCount_detection.yaml,2020-10-04,DNS_HighReverseDNSCount_detection.yaml
5b72f527-e3f6-4a00-9908-8e4fee14da9f,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1046,Network Service Scanning,GCP,Detection,Azure Sentinel Community Github,Palo Alto - possible internal to external port scanning,"'Identifies a list of internal Source IPs (10.x.x.x Hosts) that have triggered 10 or more non-graceful tcp server resets from one or more Destination IPs which 
results in an ""ApplicationProtocol = incomplete"" designation. The server resets coupled with an ""Incomplete"" ApplicationProtocol designation can be an indication 
of internal to external port scanning or probing attack. 
References: https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClUvCAK and
https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClTaCAK'
",PaloAltoNetworks,CommonSecurityLog,"
let timeframe = 1h;
CommonSecurityLog 
| where TimeGenerated > ago(timeframe) 
| where isnotempty(DestinationPort) and DeviceAction !in (""reset-both"", ""deny"") 
// filter out common usage ports. Add ports that are legitimate for your environment
| where DestinationPort !in (""443"", ""53"", ""389"", ""80"", ""0"", ""880"", ""8888"", ""8080"")
| where ApplicationProtocol == ""incomplete"" 
// filter out IANA ephemeral or negotiated ports as per https://en.wikipedia.org/wiki/Ephemeral_port
| where DestinationPort !between (toint(49512) .. toint(65535)) 
| where Computer != """" 
| where DestinationIP !startswith ""10.""
// Filter out any graceful reset reasons of AGED OUT which occurs when a TCP session closes with a FIN due to aging out. 
| where AdditionalExtensions !has ""reason=aged-out"" 
// Filter out any TCP FIN which occurs when a TCP FIN is used to gracefully close half or both sides of a connection.
| where AdditionalExtensions !has ""reason=tcp-fin"" 
// Uncomment one of the following where clauses to trigger on specific TCP reset reasons
// See Palo Alto article for details - https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClUvCAK
// TCP RST-server - Occurs when the server sends a TCP reset to the client
// | where AdditionalExtensions has ""reason=tcp-rst-from-server""  
// TCP RST-client - Occurs when the client sends a TCP reset to the server
// | where AdditionalExtensions has ""reason=tcp-rst-from-client""  
| extend reason = tostring(split(AdditionalExtensions, "";"")[3])
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by DeviceName, SourceUserID, SourceIP, ApplicationProtocol, reason, DestinationPort, Protocol, DeviceVendor, DeviceProduct, DeviceAction, DestinationIP
| where count_ >= 10
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), makeset(DestinationIP), totalcount = sum(count_) by DeviceName, SourceUserID, SourceIP, ApplicationProtocol, reason, DestinationPort, Protocol, DeviceVendor, DeviceProduct, DeviceAction
| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIP, AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName 
",1h,1h,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/PaloAlto-PortScanning.yaml,2020-10-04,PaloAlto-PortScanning.yaml
edbeec9f-86b9-475d-8a42-cc7b95ad2baa,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1046,Network Service Scanning,Linux,Hunting Query,Azure Sentinel Community Github,Squid malformed requests,"'Malformed web requests are sometimes used for reconnaissance to detect the presence of network security devices.
Hunting for a large number of requests from a single source may assist in locating compromised hosts. Note: internal sites may
be detected by this query and may need excluding on a individual basis. This query presumes the default squid log format is
being used.'
",Syslog,Syslog,"
let timeframe = 14d;
Syslog
| where TimeGenerated >= ago(timeframe) 
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
         Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
         contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where Domain !contains '.' and isnotempty(Domain)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), badRequestCount = count() by Domain, SourceIP, User, URL
| order by badRequestCount desc
| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = SourceIP, URLCustomEntity = URL
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/squid_malformed_requests.yaml,2020-10-04,squid_malformed_requests.yaml
fda90754-4e22-4bb1-8b99-2bb49a991eae,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1046,Network Service Scanning,Windows,Hunting Query,Azure Sentinel Community Github,High reverse DNS count by host,"'Clients with a high reverse DNS count could be carrying out reconnaissance or discovery activity.'
",DNS,DnsEvents,"
let timeframe = 1d;
let threshold = 10;
DnsEvents 
| where TimeGenerated >= ago(timeframe)
| where Name contains ""in-addr.arpa"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), NameCount = dcount(Name), Names = make_set(Name), ClientIPCount = count() by ClientIP
| where NameCount > threshold
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_HighReverseDNSCount.yaml,2020-10-04,DNS_HighReverseDNSCount.yaml
3d645a88-2724-41a7-adea-db74c439cf79,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1499,Endpoint Denial of Service,Linux,Detection,Azure Sentinel Community Github,Excessive Amount of Denied Connections from a Single Source,"'This creates an incident in the event that a single source IP address generates a excessive amount of denied connections.'
",SophosXGFirewall,Syslog,"
let timeframe = ago(1h);
let threshold = 5000;
SophosXGFirewall
| where TimeGenerated >= timeframe
| where Log_Type =~ ""Firewall"" and Status =~ ""Deny""
| summarize count() by Src_IP, bin(TimeGenerated,5m)
| where count_ > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = Src_IP
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SophosXGFirewall/ExcessiveAmountofDeniedConnectionsfromASingleSource.yaml,2020-10-04,ExcessiveAmountofDeniedConnectionsfromASingleSource.yaml
fbd72eb8-087e-466b-bd54-1ca6ea08c6d3,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Office 365,Detection,Azure Sentinel Community Github,Office policy tampering,"'Identifies if any tampering is done to either auditlog, ATP Safelink, SafeAttachment, AntiPhish or Dlp policy. 
An adversary may use this technique to evade detection or avoid other policy based defenses.
References: https://docs.microsoft.com/powershell/module/exchange/advanced-threat-protection/remove-antiphishrule?view=exchange-ps.'
",Office365,OfficeActivity,"
let timeframe = 1d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where RecordType =~ ""ExchangeAdmin""
| where UserType in~ (""Admin"",""DcAdmin"") 
// Only admin or global-admin can disable/remove policy
| where Operation startswith ""Remove-"" or Operation startswith ""Disable-""
| where Operation has_any (""AntiPhish"", ""SafeAttachment"", ""SafeLinks"", ""Dlp"", ""Audit"")
| extend ClientIPOnly = case( 
ClientIP has ""."", tostring(split(ClientIP,"":"")[0]), 
ClientIP has ""["", tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))),
ClientIP
)  
| extend Port = case(
ClientIP has ""."", (split(ClientIP,"":"")[1]),
ClientIP has ""["", tostring(split(ClientIP,""]:"")[1]),
ClientIP
)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() by Operation, UserType, UserId, ClientIP = ClientIPOnly, Port, ResultStatus, Parameters
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/office_policytampering.yaml,2020-10-04,office_policytampering.yaml
194dd92e-d6e7-4249-85a5-273350a7f5ce,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Office 365,Detection,Azure Sentinel Community Github,Exchange AuditLog disabled,"'Identifies when the exchange audit logging has been disabled which may be an adversary attempt
to evade detection or avoid other defenses.'
",Office365,OfficeActivity,"
let timeframe = 1d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where UserType in~ (""Admin"",""DcAdmin"") 
// Only admin or global-admin can disable audit logging
| where Operation =~ ""Set-AdminAuditLogConfig"" 
| extend AdminAuditLogEnabledValue = tostring(parse_json(tostring(parse_json(tostring(array_slice(parse_json(Parameters),3,3)))[0])).Value)
| where AdminAuditLogEnabledValue =~ ""False"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() by Operation, UserType, UserId, ClientIP, ResultStatus, Parameters, AdminAuditLogEnabledValue
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP ",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/exchange_auditlogdisabled.yaml,2020-10-04,exchange_auditlogdisabled.yaml
7b634263-9971-4887-8ecf-0d83ab9c7370,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps- Addtional Org Admin added,"'This hunting query identifies Azure DevOps activities where additional organization admin is added'
",AzureMonitor,AzureDevOpsAuditing,"let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Group.UpdateGroupMembership.Add""
| where Category == ""Modify""
| where Area == ""Group""
| where Details contains (""Project Collection Administrators"")
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Addtional%20Org%20Admin%20Added.yaml,2020-10-04,Addtional%20Org%20Admin%20Added.yaml
c78a3845-37d9-448e-a8cd-e9543f00bcc5,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps- AAD Conditional Access Disabled,"'This hunting query identifies Azure DevOps activities where organization AADConditionalAccess policy disable by the admin'
",AzureMonitor,AzureDevOpsAuditing,"let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where OperationName ==""OrganizationPolicy.PolicyValueUpdated""
| where Data.PolicyName == ""Policy.EnforceAADConditionalAccess""
| where Data.PolicyValue == ""OFF""
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/AAD%20Conditional%20Access%20Disabled.yaml,2020-10-04,AAD%20Conditional%20Access%20Disabled.yaml
2380670e-e168-4a99-9529-6c4d127b3ce6,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps- Guest users access enabled,"'This hunting query identifies Azure DevOps activities where organization Guest Access policy is enabled by the admin'
",AzureMonitor,AzureDevOpsAuditing,"let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where OperationName ==""OrganizationPolicy.PolicyValueUpdated""
| where Data.PolicyName == ""Policy.DisallowAadGuestUserAccess""
| where Data.PolicyValue == ""OFF""
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Guest%20users%20access%20enabled.yaml,2020-10-04,Guest%20users%20access%20enabled.yaml
800ae9c9-0280-4296-821f-c6e0a473fb41,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps- Public project enabled by admin,"'This hunting query identifies Azure DevOps activities where organization public projects policy enabled by the admin'
",AzureMonitor,AzureDevOpsAuditing,"let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""OrganizationPolicy.PolicyValueUpdated""
| where Data.PolicyName == ""Policy.AllowAnonymousAccess""
| where Data.PolicyValue == ""ON""
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Public%20Projects%20enabled.yaml,2020-10-04,Public%20Projects%20enabled.yaml
3cdc5404-15ed-4656-8eb9-60bc8b495934,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps- Public project created,"'This hunting query identifies Azure DevOps activities where a public project is created'
",AzureMonitor,AzureDevOpsAuditing,"let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where Data.ProjectVisibility == ""Public""
| where OperationName == ""Project.CreateCompleted""
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Public%20project%20created.yaml,2020-10-04,Public%20project%20created.yaml
3ff0fffb-d963-40c0-b235-3404f915add7,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,,Detection,Azure Sentinel Community Github,GitHub Two Factor Auth Disable,"'Two-factor authentication is a process where a user is prompted during the sign-in process for an additional form of identification, such as to enter a code on their cellphone or to provide a fingerprint scan. Two factor authentication reduces the risk of account takeover. Attacker will want to disable such security tools in order to go undetected. '
",CustomConnector,CustomLogs_CL,"
let timeframe = 14d;
GitHubAudit
| where TimeGenerated > ago(timeframe)
| where Action == ""org.disable_two_factor_requirement""
| project TimeGenerated, Action, Actor, Country, IPaddress, Repository
| extend AccountCustomEntity = Actor, IPCustomEntity = IPaddress
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/Two%20Factor%20Authentication%20Disabled.yaml,2020-10-04,Two%20Factor%20Authentication%20Disabled.yaml
ec986fb7-34ed-4528-a5f3-a496e61d8860,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,,Hunting Query,Azure Sentinel Community Github,GitHub Update Permissions,"'This hunting query identifies GitHub activites where permissions are updated that may be a sign of compromise.'
",CustomConnector,CustomLogs_CL,"
GitHubAudit
| where Action == ""org.update_default_repository_permission""
| project TimeGenerated, Action, Actor, Country, Repository, PreviousPermission, CurrentPermission
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Org%20Repositories%20Default%20Permissions%20Change.yaml,2020-10-04,Org%20Repositories%20Default%20Permissions%20Change.yaml
667e6a70-adc9-49b7-9cf3-f21927c71959,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1089,Disabling Security Tools,,Hunting Query,Azure Sentinel Community Github,GitHub OAuth App Restrictions Disabled,"'This hunting query identifies GitHub OAuth Apps that have restrictions disabled that may be a sign of compromise. Attacker will want to disable such security tools in order to go undetected. '
",CustomConnector,CustomLogs_CL,"
let timeframe = 14d;
GitHubAudit
| where TimeGenerated > ago(timeframe)
| where Action == ""org.disable_oauth_app_restrictions""
| project TimeGenerated, Action, Actor, Location
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Oauth%20App%20Restrictions%20Disabled.yaml,2020-10-04,Oauth%20App%20Restrictions%20Disabled.yaml
d722831e-88f5-4e25-b106-4ef6e29f8c13,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1105,Ingress Tool Transfer,Office 365,Detection,Azure Sentinel Community Github,New executable via Office FileUploaded Operation,"'Identifies when executable file types are uploaded to Office services such as SharePoint and OneDrive.
List currently includes 'exe', 'inf', 'gzip', 'cmd', 'bat' file extensions.
Additionally, identifies when a given user is uploading these files to another users workspace.
This may be indication of a staging location for malware or other malicious activity.'
",Office365,OfficeActivity,"
// a threshold can be enabled, see commented line below for PrevSeenCount
let threshold = 2;
let uploadOp = 'FileUploaded';
// Extensions that are interesting. Add/Remove to this list as you see fit
let execExt = dynamic(['exe', 'inf', 'gzip', 'cmd', 'bat']);
let starttime = 8d;
let endtime = 1d;
OfficeActivity | where TimeGenerated >= ago(endtime)
// Limited to File Uploads due to potential noise, comment out the Operation statement below to include any operation type
// Additional, but potentially noisy operation types that include Uploads and Downloads can be included by adding the following - Operation contains ""upload"" or Operation contains ""download""
| where Operation =~ uploadOp
| where SourceFileExtension has_any (execExt)
| project TimeGenerated, OfficeId, OfficeWorkload, RecordType, Operation, UserType, UserKey, UserId, ClientIP, UserAgent, Site_Url, SourceRelativeUrl, SourceFileName
| join kind= leftanti (
OfficeActivity | where TimeGenerated between (ago(starttime) .. ago(endtime))
| where Operation =~ uploadOp
| where SourceFileExtension has_any (execExt)
| summarize SourceRelativeUrl = make_set(SourceRelativeUrl), UserId = make_set(UserId) , PrevSeenCount = count() by SourceFileName
// To exclude previous matches when only above a specific count, change threshold above and uncomment the line below
//| where PrevSeenCount > threshold
| mvexpand SourceRelativeUrl, UserId
| extend SourceRelativeUrl = tostring(SourceRelativeUrl), UserId = tostring(UserId)
) on SourceFileName, SourceRelativeUrl, UserId 
| extend SiteUrlUserFolder = tolower(split(Site_Url, '/')[-2])
| extend UserIdUserFolderFormat = tolower(replace('@|\\.', '_',UserId))
// identify when UserId is not a match to the specific site url personal folder reference
| extend UserIdDiffThanUserFolder = iff(Site_Url has '/personal/' and SiteUrlUserFolder != UserIdUserFolderFormat, true , false ) 
| summarize TimeGenerated = make_list(TimeGenerated), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), 
UserAgents = make_list(UserAgent), OfficeIds = make_list(OfficeId), SourceRelativeUrls = make_list(SourceRelativeUrl), FileNames = make_list(SourceFileName)
by OfficeWorkload, RecordType, Operation, UserType, UserKey, UserId, ClientIP, Site_Url, SiteUrlUserFolder, UserIdUserFolderFormat, UserIdDiffThanUserFolder
",1d,8d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Office_Uploaded_Executables.yaml,2020-10-04,Office_Uploaded_Executables.yaml
641ecd2d-27c9-4f05-8433-8205096b09fc,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1105,Ingress Tool Transfer,Office 365,Hunting Query,Azure Sentinel Community Github,New Windows Reserved Filenames staged on Office file services,"'Identifies when new Windows Reserved Filenames show up on Office services such as SharePoint and OneDrive in relation to the previous 7 days.
List currently includes 'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 
'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9' file extensions.
Additionally, identifies when a given user is uploading these files to another users workspace.
This may be indication of a staging location for malware or other malicious activity.
References: https://docs.microsoft.com/windows/win32/fileio/naming-a-file'
",Office365,OfficeActivity,"
// a threshold can be enabled, see commented line below for PrevSeenCount
let threshold = 1;
// Reserved FileNames/Extension for Windows
let Reserved = dynamic(['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9']);
let starttime = 8d;
let endtime = 1d;
OfficeActivity | where TimeGenerated >= ago(endtime)
| where isnotempty(SourceFileExtension)
| where SourceFileName !~ SourceFileExtension
| where SourceFileExtension in~ (Reserved) or SourceFileName in~ (Reserved)
| where UserAgent !has ""Mac OS"" 
| project TimeGenerated, OfficeId, OfficeWorkload, RecordType, Operation, UserType, UserKey, UserId, ClientIP, UserAgent, Site_Url, SourceRelativeUrl, SourceFileName, SourceFileExtension 
| join kind= leftanti (
OfficeActivity | where TimeGenerated between (ago(starttime) .. ago(endtime))
| where isnotempty(SourceFileExtension)
| where SourceFileName !~ SourceFileExtension
| where SourceFileExtension in~ (Reserved) or SourceFileName in~ (Reserved)
| where UserAgent !has ""Mac OS"" 
| summarize SourceRelativeUrl = make_set(SourceRelativeUrl), UserId = make_set(UserId), SourceFileName = make_set(SourceFileName) , PrevSeenCount = count() by SourceFileExtension
// To exclude previous matches when only above a specific count, change threshold above and uncomment the line below
//| where PrevSeenCount > threshold
| mvexpand SourceRelativeUrl, UserId, SourceFileName
| extend SourceRelativeUrl = tostring(SourceRelativeUrl), UserId = tostring(UserId), SourceFileName = tostring(SourceFileName)
) on SourceFileExtension
| extend SiteUrlUserFolder = tolower(split(Site_Url, '/')[-2])
| extend UserIdUserFolderFormat = tolower(replace('@|\\.', '_',UserId))
// identify when UserId is not a match to the specific site url personal folder reference
| extend UserIdDiffThanUserFolder = iff(Site_Url has '/personal/' and SiteUrlUserFolder != UserIdUserFolderFormat, true , false ) 
| summarize TimeGenerated = make_list(TimeGenerated), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Operations = make_list(Operation), UserAgents = make_list(UserAgent), 
OfficeIds = make_list(OfficeId), SourceRelativeUrls = make_list(SourceRelativeUrl), FileNames = make_list(SourceFileName)
by OfficeWorkload, RecordType, UserType, UserKey, UserId, ClientIP, Site_Url, SourceFileExtension, SiteUrlUserFolder, UserIdUserFolderFormat, UserIdDiffThanUserFolder
// Use mvexpand on any list items and you can expand out the exact time and other metadata about the hit
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/New_WindowsReservedFileNamesOnOfficeFileServices.yaml,2020-10-04,New_WindowsReservedFileNamesOnOfficeFileServices.yaml
61c28cd7-3139-4731-8ea7-2cbbeabb4684,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1105,Ingress Tool Transfer,Office 365,Hunting Query,Azure Sentinel Community Github,Windows Reserved Filenames staged on Office file services,"'Identifies when Windows Reserved Filenames show up on Office services such as SharePoint and OneDrive.
List currently includes 'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 
'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9' file extensions.
Additionally, identifies when a given user is uploading these files to another users workspace.
This may be indication of a staging location for malware or other malicious activity.
References: https://docs.microsoft.com/windows/win32/fileio/naming-a-file'
",Office365,OfficeActivity,"
// Reserved FileNames/Extension for Windows
let Reserved = dynamic(['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9']);
let endtime = 1d;
OfficeActivity | where TimeGenerated >= ago(endtime)
| where isnotempty(SourceFileExtension)
| where SourceFileExtension in~ (Reserved) or SourceFileName in~ (Reserved)
| where UserAgent !has ""Mac OS"" 
| extend SiteUrlUserFolder = tolower(split(Site_Url, '/')[-2])
| extend UserIdUserFolderFormat = tolower(replace('@|\\.', '_',UserId))
// identify when UserId is not a match to the specific site url personal folder reference
| extend UserIdDiffThanUserFolder = iff(Site_Url has '/personal/' and SiteUrlUserFolder != UserIdUserFolderFormat, true , false ) 
| summarize TimeGenerated = make_list(TimeGenerated), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Operations = make_list(Operation), UserAgents = make_list(UserAgent), 
OfficeIds = make_list(OfficeId), SourceRelativeUrls = make_list(SourceRelativeUrl), FileNames = make_list(SourceFileName)
by OfficeWorkload, RecordType, UserType, UserKey, UserId, ClientIP, Site_Url, SourceFileExtension,SiteUrlUserFolder, UserIdUserFolderFormat, UserIdDiffThanUserFolder
// Use mvexpand on any list items and you can expand out the exact time and other metadata about the hit
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/WindowsReservedFileNamesOnOfficeFileServices.yaml,2020-10-04,WindowsReservedFileNamesOnOfficeFileServices.yaml
500415fb-bba7-4227-a08a-9857fb61b6a7,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,Office 365,Detection,Azure Sentinel Community Github,Mail redirect via ExO transport rule,"'Identifies when Exchange Online transport rule configured to forward emails.
This could be an adversary mailbox configured to collect mail from multiple user accounts.'
",Office365,OfficeActivity,"
let timeframe = 1d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where OfficeWorkload == ""Exchange""
| where Operation in~ (""New-TransportRule"", ""Set-TransportRule"")
| extend p = parse_json(Parameters)
| extend RuleName = case(
  Operation =~ ""Set-TransportRule"", tostring(OfficeObjectId),
  Operation =~ ""New-TransportRule"", tostring(p[1].Value),
  ""Unknown""
  ) 
| mvexpand p
| where (p.Name =~ ""BlindCopyTo"" or p.Name =~ ""RedirectMessageTo"") and isnotempty(p.Value)
| extend RedirectTo = p.Value
| extend ClientIPOnly = case( 
  ClientIP has ""."" and ClientIP has "":"", tostring(split(ClientIP,"":"")[0]), 
  ClientIP has ""."" and ClientIP has ""-"", tostring(split(ClientIP,""-"")[0]), 
  ClientIP has ""["", tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))),
  ClientIP
  )  
| extend Port = case(
  ClientIP has ""."" and ClientIP has "":"", (split(ClientIP,"":"")[1]),
  ClientIP has ""."" and ClientIP has ""-"", (split(ClientIP,""-"")[1]),
  ClientIP has ""["" and ClientIP has "":"", tostring(split(ClientIP,""]:"")[1]),
  ClientIP has ""["" and ClientIP has ""-"", tostring(split(ClientIP,""]-"")[1]),
  ClientIP
  )
| extend ClientIP = ClientIPOnly
| project TimeGenerated, RedirectTo, ClientIP, Port, UserId, Operation, RuleName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP ",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Mail_redirect_via_ExO_transport_rule.yaml,2020-10-04,Mail_redirect_via_ExO_transport_rule.yaml
871ba14c-88ef-48aa-ad38-810f26760ca3,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,Office 365,Detection,Azure Sentinel Community Github,Multiple users email forwarded to same destination,"'Identifies when multiple (more than one) users mailboxes are configured to forward to the same destination. 
This could be an attacker-controlled destination mailbox configured to collect mail from multiple compromised user accounts.'
",Office365,OfficeActivity,"
let timeframe = 7d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where Operation =~ ""Set-Mailbox""
| where Parameters has ""ForwardingSmtpAddress""
| extend parsed = parse_json(Parameters)
| mv-expand parsed
| where parsed.Name == ""ForwardingSmtpAddress""
| extend parameterName = tostring(parsed.Name), fwdingDestination = tostring(parsed.Value)
| where isnotempty(fwdingDestination)
| extend ClientIPOnly = case( 
ClientIP has ""."" and ClientIP has ':', tostring(split(ClientIP,"":"")[0]), 
ClientIP has ""."" and ClientIP has '-', tostring(split(ClientIP,""-"")[0]), 
ClientIP has ']-', tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))),
ClientIP has ']:', tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))),
isempty(ClientIP) and ClientIP_ has ""."" and ClientIP_ has ':', tostring(split(ClientIP_,"":"")[0]), 
isempty(ClientIP) and ClientIP_ has ""."" and ClientIP_ has '-', tostring(split(ClientIP_,""-"")[0]), 
isempty(ClientIP) and ClientIP_ has ']-', tostring(trim_start(@'[[]',tostring(split(ClientIP_,""]"")[0]))),
isempty(ClientIP) and ClientIP_ has ']:', tostring(trim_start(@'[[]',tostring(split(ClientIP_,""]"")[0]))),
isnotempty(ClientIP), ClientIP,
isnotempty(ClientIP_), ClientIP_,
""IP Not Available""
)  
| extend Port = case(
ClientIP has ""."" and ClientIP has ':', tostring(split(ClientIP,"":"")[1]), 
ClientIP has ""."" and ClientIP has '-', tostring(split(ClientIP,""-"")[1]), 
ClientIP has ']-', tostring(split(ClientIP,""]-"")[1]), 
ClientIP has ']:', tostring(split(ClientIP,""]:"")[1]), 
isempty(ClientIP) and ClientIP_ has ""."" and ClientIP_ has ':', tostring(split(ClientIP_,"":"")[1]), 
isempty(ClientIP) and ClientIP_ has ""."" and ClientIP_ has '-', tostring(split(ClientIP_,""-"")[1]), 
isempty(ClientIP) and ClientIP_ has ']-', tostring(split(ClientIP_,""]-"")[1]),
isempty(ClientIP) and ClientIP_ has ']:', tostring(split(ClientIP_,""]:"")[1]),
isnotempty(ClientIP), ClientIP,
isnotempty(ClientIP_), ClientIP_,
""IP Not Available""
)
| extend UserId = iff(isempty(UserId), UserId_, UserId)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctUserCount = dcount(UserId), UserId = make_set(UserId), 
Ports = make_set(Port), EventCount = count() by fwdingDestination, ClientIP = ClientIPOnly 
| where DistinctUserCount > 1
| mv-expand UserId
| extend UserId = tostring(UserId), Ports = tostring(Ports)
| distinct StartTimeUtc, EndTimeUtc, UserId, DistinctUserCount, ClientIP, Ports, fwdingDestination, EventCount
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP
",1d,7d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Office_MailForwarding.yaml,2020-10-04,Office_MailForwarding.yaml
0a8f410d-38b5-4d75-90da-32b472b97230,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,Office 365,Hunting Query,Azure Sentinel Community Github,Non-owner mailbox login activity,"'This will help you determine if mailbox access observed with Admin/Delegate Logontype. 
The logon type indicates mailbox accessed from non-owner user. Exchange allows Admin 
and delegate permissions to access other user's inbox.
If your organization has valid admin, delegate access given to users, you can whitelist those and investigate other results.
References: https://docs.microsoft.com/office/office-365-management-api/office-365-management-activity-api-schema#logontype'
",Office365,OfficeActivity,"
let timeframe = 1d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where Operation == ""MailboxLogin"" and Logon_Type != ""Owner"" 
| summarize count(), min(TimeGenerated), max(TimeGenerated) by Operation, OrganizationName, UserType, UserId, MailboxOwnerUPN, Logon_Type
| extend timestamp = min_TimeGenerated, AccountCustomEntity = UserId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/nonowner_MailboxLogin.yaml,2020-10-04,nonowner_MailboxLogin.yaml
9891684a-1e3a-4546-9403-3439513cbc70,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,Office 365,Hunting Query,Azure Sentinel Community Github,Mail redirect via ExO transport rule,"'Identifies when Exchange Online transport rule configured to forward emails.
This could be an adversary mailbox configured to collect mail from multiple user accounts.'
",Office365,OfficeActivity,"
let timeframe = 14d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where OfficeWorkload == ""Exchange""
| where Operation in~ (""New-TransportRule"", ""Set-TransportRule"")
| extend p = parse_json(Parameters)
| extend RuleName = case(
  Operation =~ ""Set-TransportRule"", tostring(OfficeObjectId),
  Operation =~ ""New-TransportRule"", tostring(p[1].Value),
  ""Unknown""
  ) 
| mvexpand p
| where (p.Name =~ ""BlindCopyTo"" or p.Name =~ ""RedirectMessageTo"") and isnotempty(p.Value)
| extend RedirectTo = p.Value
| extend ClientIPOnly = case( 
  ClientIP has ""."" and ClientIP has "":"", tostring(split(ClientIP,"":"")[0]), 
  ClientIP has ""."" and ClientIP has ""-"", tostring(split(ClientIP,""-"")[0]), 
  ClientIP has ""["", tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))),
  ClientIP
  )  
| extend Port = case(
  ClientIP has ""."" and ClientIP has "":"", (split(ClientIP,"":"")[1]),
  ClientIP has ""."" and ClientIP has ""-"", (split(ClientIP,""-"")[1]),
  ClientIP has ""["" and ClientIP has "":"", tostring(split(ClientIP,""]:"")[1]),
  ClientIP has ""["" and ClientIP has ""-"", tostring(split(ClientIP,""]-"")[1]),
  ClientIP
  )
| extend ClientIP = ClientIPOnly
| project TimeGenerated, RedirectTo, ClientIP, Port, UserId, Operation, RuleName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP ",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Mail_redirect_via_ExO_transport_rule_hunting.yaml,2020-10-04,Mail_redirect_via_ExO_transport_rule_hunting.yaml
d49fc965-aef3-49f6-89ad-10cc4697eb5b,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,Office 365,Hunting Query,Azure Sentinel Community Github,Office Mail Forwarding - Hunting Version,"'Adversaries often abuse email-forwarding rules to monitor activities of a victim, steal information and further gain intelligence on
victim or victim's organization.This query over Office Activity data highlights cases where user mail is being forwarded and shows if 
it is being forwarded to external domains as well.'
",Office365,OfficeActivity,"
let timeframe = 14d;
OfficeActivity
| where TimeGenerated >= ago(timeframe)
| where (Operation =~ ""Set-Mailbox"" and Parameters contains 'ForwardingSmtpAddress') 
or (Operation =~ 'New-InboxRule' and Parameters contains 'ForwardTo')
| extend parsed=parse_json(Parameters)
| extend fwdingDestination_initial = (iif(Operation=~""Set-Mailbox"", tostring(parsed[1].Value), tostring(parsed[2].Value)))
| where isnotempty(fwdingDestination_initial)
| extend fwdingDestination = iff(fwdingDestination_initial has ""smtp"", (split(fwdingDestination_initial,"":"")[1]), fwdingDestination_initial )
| parse fwdingDestination with * '@' ForwardedtoDomain 
| parse UserId with *'@' UserDomain
| extend subDomain = ((split(strcat(tostring(split(UserDomain, '.')[-2]),'.',tostring(split(UserDomain, '.')[-1])), '.') [0]))
| where ForwardedtoDomain !contains subDomain
| extend Result = iff( ForwardedtoDomain != UserDomain ,""Mailbox rule created to forward to External Domain"", ""Forward rule for Internal domain"")
| extend ClientIPAddress = case( ClientIP has ""."", tostring(split(ClientIP,"":"")[0]), ClientIP has ""["", tostring(trim_start(@'[[]',tostring(split(ClientIP,""]"")[0]))), ClientIP )
| extend Port = case(
ClientIP has ""."", (split(ClientIP,"":"")[1]),
ClientIP has ""["", tostring(split(ClientIP,""]:"")[1]),
ClientIP
)
| project TimeGenerated, UserId, UserDomain, subDomain, Operation, ForwardedtoDomain, ClientIPAddress, Result, Port, OriginatingServer, OfficeObjectId, fwdingDestination
| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIPAddress, HostCustomEntity =  OriginatingServer 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/OfficeMailForwarding_hunting.yaml,2020-10-04,OfficeMailForwarding_hunting.yaml
0ef8dee1-eb94-44c8-b59b-2eb096a4b983,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,,Hunting Query,Azure Sentinel Community Github,S3 Bucket outbound Data transfer anomaly,"'Identifies when an anomalous spike occur in data transfer from an S3 bucket based on GetObject API call and the BytesTransferredOut field. 
The query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns. 
Sudden increases in execution frequency of sensitive actions should be further investigated for malicious activity.
Manually change scorethreshold from 1.5 to 3 or higher to reduce the noise based on outliers flagged from the query criteria.
Read more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash 
AWS S3 API GetObject at https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html
S3 LogStash Config: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/Logstash/input-aws_s3-output-loganalytics.conf
S3 KQL Parser: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/AwsS3BucketAPILogsParser.txt'
",CustomConnector,CustomLogs_CL,"
let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let scorethreshold = 1.5;
// Preparing the time series data aggregated on BytesTransferredOut column in the form of multi-value array so that it can be used with time series anomaly function.
let TimeSeriesData=
AwsBucketAPILogs_CL 
| where EventTime between (startofday(ago(starttime))..startofday(ago(endtime)))
| where EventName == ""GetObject""
| make-series Total=sum(BytesTransferredOut) on EventTime from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe;
// Use the time series data prepared in previous step with time series aomaly function to generate baseline pattern and flag the outlier based on scorethreshold value.
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')
| mv-expand Total to typeof(double), EventTime to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)
| where anomalies > 0
| project EventTime, Total, baseline, anomalies, score;
// Joining the flagged outlier from the previous step with the original dataset to present contextual information during the anomalyhour to analysts to conduct investigation or informed decistions.
TimeSeriesAlerts
| join 
(
  AWSS3BucketAPILogParsed 
  | where EventTime between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where EventName == ""GetObject""
  | summarize Total = sum(BytesTransferredOut), Files= makeset(Key) , max(EventTime) by bin(EventTime, 1h), EventSource,EventName, SourceIPAddress, UserIdentityType, UserIdentityArn, UserIdentityUserName, BucketName, Host, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName
) on EventTime
| project AnomalyTime = max_EventTime, SourceIPAddress, UserIdentityType,UserIdentityUserName,SessionUserName, BucketName, Host, AuthenticationMethod, Files, Total, baseline, anomalies, score 
| extend timestamp = AnomalyTime, AccountCustomEntity = SessionUserName , HostCustomEntity = Host, IPCustomEntity = SourceIPAddress",1h,14d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSS3/AWSBucketAPILogs-S3BucketDataTransferTimeSeriesAnomaly.yaml,2020-10-04,AWSBucketAPILogs-S3BucketDataTransferTimeSeriesAnomaly.yaml
64990414-b015-4edf-bef0-343b741e68c5,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1489,Service Stop,Office 365,Hunting Query,Azure Sentinel Community Github,Multiple Teams deleted by a single user,"'This hunting query identifies where multiple Teams have been deleted by a single user in a short timeframe.
 This query is works with the built-in Teams data connector only.'
",Office365,OfficeActivity,"
// Adjust this value to change how many Teams should be deleted before including
let max_delete = 3;
// Adjust this value to change the timewindow the query runs over
let time_window = 1d;
let deleting_users = (
OfficeActivity
| where TimeGenerated > ago(time_window)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation =~ ""TeamDeleted""
| summarize count() by UserId
| where count_ > max_delete
| project UserId);
  OfficeActivity
| where TimeGenerated > ago(time_window)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation =~ ""TeamDeleted""
| where UserId in (deleting_users)
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = TimeGenerated, AccountCustomEntity = UserId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Teams/MultipleTeamsDeletes.yaml,2020-10-04,MultipleTeamsDeletes.yaml
173f8699-6af5-484a-8b06-8c47ba89b380,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1489,Service Stop,,Hunting Query,Azure Sentinel Community Github,Multiple Teams deleted by a single user,"'This hunting query identifies where multiple Teams have been deleted by a single user in a short timeframe.
This query requires you to have Teams data collected from the O365 Management Activity API
and the Teams parser function enabled.
More details: https://techcommunity.microsoft.com/t5/azure-sentinel/protecting-your-teams-with-azure-sentinel/ba-p/1265761'
",CustomConnector,CustomLogs_CL,"
// Adjust this value to change how many Teams should be deleted before including
let max_delete = 3;
// Adjust this value to change the timewindow the query runs over
let time_window = 1d;
let deleting_users = (
TeamsData 
| where CreationTime > ago(time_window)
| where Operation =~ ""TeamDeleted""
| summarize count() by UserId
| where count_ > max_delete
| project UserId);
TeamsData
| where CreationTime > ago(time_window)
| where Operation =~ ""TeamDeleted""
| where UserId in (deleting_users)
| extend TeamGuid = tostring(Details.TeamGuid)
| project-away AddOnName, Members, Settings
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = CreationTime, AccountCustomEntity = UserId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/TeamsLogs/MultipleTeamsDeletes.yaml,2020-10-04,MultipleTeamsDeletes.yaml
0d76e9cf-788d-4a69-ac7d-f234826b5bed,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1035,Service Execution,Windows,Detection,Azure Sentinel Community Github,DNS events related to mining pools,"'Identifies IP addresses that may be performing DNS lookups associated with common currency mining pools.'
",DNS,DnsEvents,"
let timeframe = 1d;
DnsEvents
| where TimeGenerated > ago(timeframe)
| where Name contains "".""
| where Name has_any (""monerohash.com"", ""do-dear.com"", ""xmrminerpro.com"", ""secumine.net"", ""xmrpool.com"", ""minexmr.org"", ""hashanywhere.com"", 
""xmrget.com"", ""mininglottery.eu"", ""minergate.com"", ""moriaxmr.com"", ""multipooler.com"", ""moneropools.com"", ""xmrpool.eu"", ""coolmining.club"", 
""supportxmr.com"", ""minexmr.com"", ""hashvault.pro"", ""xmrpool.net"", ""crypto-pool.fr"", ""xmr.pt"", ""miner.rocks"", ""walpool.com"", ""herominers.com"", 
""gntl.co.uk"", ""semipool.com"", ""coinfoundry.org"", ""cryptoknight.cc"", ""fairhash.org"", ""baikalmine.com"", ""tubepool.xyz"", ""fairpool.xyz"", ""asiapool.io"", 
""coinpoolit.webhop.me"", ""nanopool.org"", ""moneropool.com"", ""miner.center"", ""prohash.net"", ""poolto.be"", ""cryptoescrow.eu"", ""monerominers.net"", ""cryptonotepool.org"", 
""extrmepool.org"", ""webcoin.me"", ""kippo.eu"", ""hashinvest.ws"", ""monero.farm"", ""supportxmr.com"", ""xmrpool.eu"", ""linux-repository-updates.com"", ""1gh.com"", 
""dwarfpool.com"", ""hash-to-coins.com"", ""hashvault.pro"", ""pool-proxy.com"", ""hashfor.cash"", ""fairpool.cloud"", ""litecoinpool.org"", ""mineshaft.ml"", ""abcxyz.stream"", 
""moneropool.ru"", ""cryptonotepool.org.uk"", ""extremepool.org"", ""extremehash.com"", ""hashinvest.net"", ""unipool.pro"", ""crypto-pools.org"", ""monero.net"", 
""backup-pool.com"", ""mooo.com"", ""freeyy.me"", ""cryptonight.net"", ""shscrypto.net"")
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DnsEvents/DNS_Miners.yaml,2020-10-04,DNS_Miners.yaml
aaf84b80-7764-420c-98eb-239b5e194b3d,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1035,Service Execution,Windows,Hunting Query,Azure Sentinel Community Github,DNS Domains linked to WannaCry ransomware campaign,"'Displays client DNS request for any of the known domains linked to WannaCry.
These results may indicate Wannacry/Wannacrypt ransomware infection.
Reference: Domain listing from https://pastebin.com/cRUii32E'
",DNS,DnsEvents,"
let timeframe = 1d;
let badDomains = dynamic([""agrdwrtj.us"", ""bctxawdt.us"", ""cokfqwjmferc.us"", ""cxbenjiikmhjcerbj.us"", ""depuisgef.us"", ""edoknehyvbl.us"", 
""enyeikruptiukjorq.com"", ""frullndjtkojlu.us"", ""gcidpiuvamynj.us"", ""gxrytjoclpvv.us"", ""hanoluexjqcf.us"", ""iarirjjrnuornts.us"", 
""ifbjoosjqhaeqjjwaerri.us"", ""iouenviwrc.us"", ""kuuelejkfwk.us"", ""lkbsxkitgxttgaobxu.us"", ""nnnlafqfnrbynwor.us"", ""ns768.com"", 
""ofdwcjnko.us"", ""peuwdchnvn.us"", ""pvbeqjbqrslnkmashlsxb.us"", ""pxyhybnyv.us"", ""qkkftmpy.us"", ""rkhlkmpfpoqxmlqmkf.us"", 
""ryitsfeogisr.us"", ""srwcjdfrtnhnjekjerl.us"", ""thstlufnunxaksr.us"", ""udrgtaxgdyv.us"", ""w5q7spejg96n.com"", ""xmqlcikldft.us"", 
""yobvyjmjbsgdfqnh.us"", ""yrwgugricfklb.us"", ""ywpvqhlqnssecpdemq.us""]);
DnsEvents
| where TimeGenerated >= ago(timeframe) 
| where Name in~ (badDomains)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Computer, ClientIP, WannaCrypt_Related_Domain = Name
| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, IPCustomEntity = ClientIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_WannaCry.yaml,2020-10-04,DNS_WannaCry.yaml
a83ef0f4-dace-4767-bce3-ebd32599d2a0,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1048,Exfiltration Over Alternative Protocol,Windows,Detection,Azure Sentinel Community Github,DNS events related to ToR proxies,"'Identifies IP addresses performing DNS lookups associated with common ToR proxies.'
",DNS,DnsEvents,"
let timeframe = 1d;
DnsEvents
| where TimeGenerated > ago(timeframe)
| where Name contains "".""
| where Name has_any (""tor2web.org"", ""tor2web.com"", ""torlink.co"", ""onion.to"", ""onion.ink"", ""onion.cab"", ""onion.nu"", ""onion.link"", 
""onion.it"", ""onion.city"", ""onion.direct"", ""onion.top"", ""onion.casa"", ""onion.plus"", ""onion.rip"", ""onion.dog"", ""tor2web.fi"", 
""tor2web.blutmagie.de"", ""onion.sh"", ""onion.lu"", ""onion.pet"", ""t2w.pw"", ""tor2web.ae.org"", ""tor2web.io"", ""tor2web.xyz"", ""onion.lt"", 
""s1.tor-gateways.de"", ""s2.tor-gateways.de"", ""s3.tor-gateways.de"", ""s4.tor-gateways.de"", ""s5.tor-gateways.de"", ""hiddenservice.net"")
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DnsEvents/DNS_TorProxies.yaml,2020-10-04,DNS_TorProxies.yaml
06c52a66-fffe-4d3b-a05a-646ff65b7ec2,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1048,Exfiltration Over Alternative Protocol,Azure,Hunting Query,Azure Sentinel Community Github,RareDNSLookupWithDataTransfer,"'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.
This can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.
Feel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'
",AzureMonitor(VMInsights),VMConnection,"
let lookbackint = 7;
let lookupThreshold = lookbackint*3;
let lookbackstring = strcat(tostring(lookbackint),"".00:00:00"");
let lookbacktime = totimespan(lookbackstring)+1d;
//startofday is setting to 00:00:00 for the given days ago
let starttime = startofday(ago(lookbacktime)); 
let endtime = startofday(now(-1d)); 
let binvalue = 1;
let bintime = make_timespan(binvalue,0);
let avgCalc = starttime/1h;
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.'; 
// Identify all domain lookups after starttime variable and prior to endtime variable
let DomainLookups = DnsEvents 
| where TimeGenerated >= starttime and TimeGenerated <= endtime 
| where SubType == ""LookupQuery""
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize DomainCount = count() by Domain
| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;
// Common lookups should not include items that occurred more rarely over the lookback period.
let CommonLookups = DomainLookups
| where DailyAvgLookupCountOverLookback > lookupThreshold;
// Get todays lookups to compare against the lookback period
let TodayLookups = DnsEvents 
| where TimeGenerated >= endtime
| where SubType == ""LookupQuery""
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses 
| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;
// Remove Common Lookups from lookback period from Todays lookups
let UncommonLookupsToday = TodayLookups
| join kind=leftanti ( 
CommonLookups
)
on Domain;
// Join back the Daily Average Lookup Count to add context to rarity over lookback period
let RareLookups = UncommonLookupsToday | join kind= innerunique (
DomainLookups 
) on Domain 
| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;
let DNSIPBreakout = RareLookups
| extend DnsIPAddress = iff(IPAddresses has "","", split(IPAddresses, "",""), todynamic(IPAddresses)) 
| mvexpand DnsIPAddress
| extend DnsIPAddress = tostring(DnsIPAddress)
| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback
| extend IPCustomEntity = DnsIPAddress
| extend DnsIPType = iff(DnsIPAddress matches regex PrivateIPregex,""private"" ,""public"" )
| where DnsIPType ==""public""
;
let DataMovement = ( union isfuzzy=true 
(CommonSecurityLog
| where TimeGenerated >= endtime
| where DeviceVendor ==""Palo Alto Networks"" and Activity == ""TRAFFIC""
| extend DestinationIPType = iff(DestinationIP matches regex PrivateIPregex,""private"" ,""public"" )
| where DestinationIPType ==""public""
| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| sort by sum_SentBytes desc
),
(WireData
| where TimeGenerated >= endtime
| where Direction == ""Outbound""
| extend RemoteIPType = iff(RemoteIP matches regex PrivateIPregex,""private"" ,""public"" ) 
| where RemoteIPType ==""public"" 
| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes 
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| extend DataType = Type
| sort by sum_SentBytes desc
),
(VMConnection 
| where TimeGenerated >= endtime
| where Direction == ""outbound""
| extend DestinationIPType = iff(DestinationIp matches regex PrivateIPregex,""private"" ,""public"" )
| where DestinationIPType ==""public""
| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent 
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort
| sort by sum_SentBytes desc
| extend IPCustomEntity = DestinationIP
)
);
DNSIPBreakout | join kind = leftouter (
DataMovement
) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP
| project-away DnsIPAddress, ClientIP
// The below condition can be removed to see all DNS results.
// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP
| where isnotempty(DataType)
| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml,2020-10-04,RareDNSLookupWithDataTransfer.yaml
8e9c4680-8c0b-4885-b183-3b09efd8fc2c,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1048,Exfiltration Over Alternative Protocol,Windows,Hunting Query,Azure Sentinel Community Github,DNS lookups for commonly abused TLDs,"'Some top level domains (TLDs) are more commonly associated with malware for a range of 
reasons - including how easy domains on these TLDs are to obtain. Many of these may be undesirable 
from an enterprise policy perspective. You can update and extend the list of TLD's  you wish to search for.
The NameCount column provides an initial insight into how widespread the domain usage is across the environment.'
",DNS,DnsEvents,"
let timeframe = 7d;
// Add additional TLDs to this list are reuqired.
let abusedTLD = dynamic([""click"", ""club"", ""download"",  ""xxx"", ""xyz""]);
DnsEvents
| where TimeGenerated >= ago(timeframe) 
| where Name has ""."" 
| extend tld = tostring(split(Name, ""."")[-1])
| where tld in~ (abusedTLD)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), NameCount = count() by Name, ClientIP, tld
| order by NameCount desc
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_CommonlyAbusedTLDs.yaml,2020-10-04,DNS_CommonlyAbusedTLDs.yaml
a0954a17-cc66-4d47-9651-8bf524bbdcc8,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1048,Exfiltration Over Alternative Protocol,Windows,Hunting Query,Azure Sentinel Community Github,Abnormally long DNS URI queries,"'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'
",DNS,DnsEvents,"
let timeframe = 1d;
// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents | where TimeGenerated >= ago(1d)
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ""."")[-2]),""."", tostring(split(Computer, ""."")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents | where TimeGenerated >= ago(1d)
| where SubType =~ ""LookupQuery""
| where ipv4_is_match(""127.0.0.1"", ClientIP) == False 
| where Name !endswith "".local"" and Name !startswith ""_"" and Name !startswith ""#""
| where Name !contains ""::1""
| where Name !has ""cnr.io"" and Name !has ""kr0.io"" and Name !has ""arcticwolf.net"" and Name !has ""webcfs00.com"" and Name !has ""barracudabrts.com""and Name !has ""trendmicro.com"" 
and Name !has ""sophosxl.net"" and Name !has ""spotify.com"" and Name !has ""e5.sk"" and Name !has ""mcafee.com"" and Name !has ""opendns.com""  and Name !has ""spameatingmonkey.net"" 
and Name !has ""_ldap"" and Name !has ""_kerberos"" and Name !has ""modsecurity.org"" and Name !has ""fdmarc.net"" and Name !has ""ipass.com"" and Name !has ""wpad""
and Name !has ""cnr.io"" and Name !has ""trendmicro.com"" and Name !has ""sophosxl.net"" and Name !has ""spotify.com"" and Name !has ""e5.sk"" and Name !has ""mcafee.com"" 
and Name !has ""opendns.com""  and Name !has ""spameatingmonkey.net"" and Name !has ""_ldap"" and Name !has ""_kerberos"" and Name !has ""modsecurity.org"" and Name !has ""fdmarc.net"" 
and Name !has ""ipass.com"" and Name !has ""wpad""
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ""."")) <= 2, Name,
tostring(split(Name, ""."")[-2]) == ""corp"", strcat(tostring(split(Name, ""."")[-3]),""."",tostring(split(Name, ""."")[-2]),""."", tostring(split(Name, ""."")[-1])),
strlen(tostring(split(Name, ""."")[-1])) == 2, strcat(tostring(split(Name, ""."")[-3]),""."",tostring(split(Name, ""."")[-2]),""."", tostring(split(Name, ""."")[-1])),
strlen(tostring(split(Name, ""."")[-2])) != ""corp"", strcat(tostring(split(Name, ""."")[-2]),""."", tostring(split(Name, ""."")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP , Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml,2020-10-04,DNS_LongURILookup.yaml
1d9951b7-51f0-4aa7-af0c-654359aadfff,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1048,Exfiltration Over Alternative Protocol,Windows,Hunting Query,Azure Sentinel Community Github,DNS - domain anomalous lookup increase,"'Checking for a threefold increase or more of domain lookups per client IP address for the current day vs daily average for the previous week. 
This can potentially identify excessive traffic to a given location that could be indicative of data transfer out of your network to a group of systems based on the same second level domain.  
For example, if one client is sending requests for test1.badguy.com and another client is sending requests for test2.badguy.com, you may not see a high enough count to be interesting. 
However, a combination of the requests to badguy.com could have a high enough count to be interesting. 
This is only Name lookups, so it would be recommended to review the Firewall\Webproxy logs in relation to the client IP address making the interesting requests.'
",DNS,DnsEvents,"
let startTime = 8d;
let endTime = 1d;
//example of excluding Saturday and Sunday in Average as those are potentially low volume and decrease the average, feel free to change
let excludedDays = dynamic([""Saturday"", ""Sunday""]);
// average is across 5 days as we are dropping weekends, change as needed
let numDays = 5;
// limit to over 1000 lookups somewhat random but helps focus in on higher lookups, change as needed
let avglookupThreshold = 3;
let lookupThreshold = 1000;
DnsEvents
//Setting to startofday so we get 7 days prior to today
| where TimeGenerated >= startofday(ago(startTime)) and TimeGenerated <= startofday(ago(endTime))
| where SubType =~ ""LookupQuery""
//getting the associated number of the day of the week so we can map to a given day for later parsing if needed
| extend DayNumberofWeek = tostring(dayofweek(TimeGenerated))
//Setting the Day of the week value so that certain days could be excluded if needed
| extend DayofWeek = iff(DayNumberofWeek == ""00:00:00"", ""Sunday"", 
(iff(DayNumberofWeek == ""1.00:00:00"", ""Monday"", 
(iff(DayNumberofWeek == ""2.00:00:00"", ""Tuesday"", 
(iff(DayNumberofWeek == ""3.00:00:00"", ""Wednesday"", 
(iff(DayNumberofWeek == ""4.00:00:00"", ""Thursday"", 
(iff(DayNumberofWeek == ""5.00:00:00"", ""Friday"", 
(iff(DayNumberofWeek == ""6.00:00:00"", ""Saturday"", DayNumberofWeek)))))))))))))
| where DayofWeek !in~ (excludedDays) 
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ClientIP, Domain, IPAddresses
| project StartTimeUtc, EndTimeUtc, ClientIP, Domain, IPAddresses, DailyAvgLookupCountOverLastWeek = count_/numDays 
| join ( DnsEvents 
| where TimeGenerated >= startofday(ago(endTime)) 
| where SubType =~ ""LookupQuery""
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize count() by ClientIP, Domain, IPAddresses 
| project ClientIP, LookupCountToday = count_, Domain, IPAddresses 
)
on ClientIP, Domain, IPAddresses 
| where LookupCountToday > ( DailyAvgLookupCountOverLastWeek * avglookupThreshold) and LookupCountToday > lookupThreshold 
| project StartTimeUtc, EndTimeUtc, ClientIP, SecondLevelDomain = Domain , LookupCountToday , DailyAvgLookupCountOverLastWeek, IPAddresses 
| order by LookupCountToday desc nulls last 
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_DomainAnomalousLookupIncrease.yaml,2020-10-04,DNS_DomainAnomalousLookupIncrease.yaml
81b478a7-46e2-4f7f-a1aa-aba5e541232b,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1048,Exfiltration Over Alternative Protocol,Windows,Hunting Query,Azure Sentinel Community Github,DNS Full Name anomalous lookup increase,"'Checking for a threefold increase or more of Full Name lookup per Client IP for the current day for today vs the daily average for the previous week.  
This can potentially identify excessive traffic to a given location that could be indicative of data transfer out of your network.  
This is only Name lookups, so it would be recommended to review the Firewall\Webproxy logs in relation to the ClientIP making the interesting requests.'
",DNS,DnsEvents,"
let startTime = 8d;
let endTime = 1d;
//example of excluding Saturday and Sunday in Average as those are potentially low volume and decrease the average, feel free to change
let excludedDays = dynamic([""Saturday"", ""Sunday""]);
// average is across 5 days as we are dropping weekends, change as needed
let numDays = 5;
// limit to over 1000 lookups somewhat random but helps focus in on higher lookups, change as needed
let avglookupThreshold = 3;
let lookupThreshold = 1000;
DnsEvents
//Setting to startofday so we get 7 days prior to today
| where TimeGenerated >= startofday(ago(startTime)) and TimeGenerated <= startofday(ago(endTime))
| where SubType =~ ""LookupQuery""
//getting the associated number of the day of the week so we can map to a given day for later parsing if needed
| extend DayNumberofWeek = tostring(dayofweek(TimeGenerated)) 
//Setting the Day of the week value so that certain days could be excluded if needed
| extend DayofWeek = iff(DayNumberofWeek == ""00:00:00"", ""Sunday"", 
(iff(DayNumberofWeek == ""1.00:00:00"", ""Monday"", 
(iff(DayNumberofWeek == ""2.00:00:00"", ""Tuesday"", 
(iff(DayNumberofWeek == ""3.00:00:00"", ""Wednesday"", 
(iff(DayNumberofWeek == ""4.00:00:00"", ""Thursday"", 
(iff(DayNumberofWeek == ""5.00:00:00"", ""Friday"", 
(iff(DayNumberofWeek == ""6.00:00:00"", ""Saturday"", DayNumberofWeek)))))))))))))
| where DayofWeek !in~ (excludedDays) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ClientIP, Name, IPAddresses
| project StartTimeUtc, EndTimeUtc, ClientIP, FullNameLookup = Name, IPAddresses, DailyAvgLookupCountOverLastWeek = count_/numDays
| join ( DnsEvents 
| where TimeGenerated >= startofday(ago(endTime))
| where SubType =~ ""LookupQuery""
| summarize count() by ClientIP, FullNameLookup = Name, IPAddresses
| project ClientIP, LookupCountToday = count_, FullNameLookup, IPAddresses
)
on ClientIP, FullNameLookup, IPAddresses
| where LookupCountToday > (DailyAvgLookupCountOverLastWeek * avglookupThreshold) and LookupCountToday >= lookupThreshold 
| project StartTimeUtc, EndTimeUtc, ClientIP, LookupCountToday, DailyAvgLookupCountOverLastWeek, FullNameLookup, IPAddresses
| order by LookupCountToday desc nulls last 
| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_FullNameAnomalousLookupIncrease.yaml,2020-10-04,DNS_FullNameAnomalousLookupIncrease.yaml
3255ec41-6bd6-4f35-84b1-c032b18bbfcb,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1065,Uncommonly Used Port,GCP,Detection,Azure Sentinel Community Github,Fortinet - Beacon pattern detected,"'Identifies patterns in the time deltas of contacts between internal and external IPs in Fortinet network data that are consistent with beaconing.
 Accounts for randomness (jitter) and seasonality such as working hours that may have been introduced into the beacon pattern.
 The lookback is set to 1d, the minimum granularity in time deltas is set to 60 seconds and the minimum number of beacons required to emit a
 detection is set to 4.
 Increase the lookback period to capture beacons with larger periodicities.
 The jitter tolerance is set to 0.2 - This means we account for an overall 20% deviation from the infered beacon periodicity. Seasonality is dealt with
 automatically using series_outliers.
 Note: In large environments it may be necessary to reduce the lookback period to get fast query times.'
",Fortinet,CommonSecurityLog,"
let starttime = 1d;
let TimeDeltaThresholdInSeconds = 60; // we ignore beacons diffs that fall below this threshold 
let TotalBeaconsThreshold = 4; // minimum number of beacons required in a session to surface a row
let JitterTolerance = 0.2; // tolerance to jitter, e.g. - 0.2 = 20% jitter is tolerated either side of the periodicity
let PrivateIPregex = @""^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.""; // exclude destinations that fall into this category
CommonSecurityLog
| where DeviceVendor == ""Fortinet""
| where TimeGenerated > ago(starttime)
// eliminate bad data
| where isnotempty(SourceIP) and isnotempty(DestinationIP) and SourceIP != ""0.0.0.0""
// filter out deny, close, rst and SNMP to reduce data volume
| where DeviceAction !in (""close"", ""client-rst"", ""server-rst"", ""deny"") and DestinationPort != 161
// map input fields
| project TimeGenerated , SourceIP, DestinationIP, DestinationPort, ReceivedBytes, SentBytes, DeviceAction 
// where destination IPs are public
| extend DestinationIPType = iff(DestinationIP matches regex PrivateIPregex,""private"" ,""public"" )
| where DestinationIPType == ""public""
// sort into source->destination 'sessions'
| sort by SourceIP asc, DestinationIP asc, DestinationPort asc, TimeGenerated asc
| serialize
// time diff the contact times between source and destination to get a list of deltas
| extend nextTimeGenerated = next(TimeGenerated, 1), nextSourceIP = next(SourceIP, 1), nextDestIP = next(DestinationIP, 1), nextDestPort = next(DestinationPort, 1)
| extend TimeDeltainSeconds = datetime_diff(""second"",nextTimeGenerated,TimeGenerated)
| where SourceIP == nextSourceIP and DestinationIP == nextDestIP and DestinationPort == nextDestPort
// remove small time deltas below the set threshold
| where TimeDeltainSeconds > TimeDeltaThresholdInSeconds
| project TimeGenerated, TimeDeltainSeconds, SourceIP, DestinationIP, DestinationPort, ReceivedBytes, SentBytes, DeviceAction 
// summarize the deltas by source->destination
| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), sum(ReceivedBytes), sum(SentBytes), makelist(TimeDeltainSeconds), makeset(DeviceAction) by SourceIP, DestinationIP, DestinationPort
// get some statistical properties of the delta distribution and smooth any outliers (e.g. laptop shut overnight, working hours)
| extend series_stats(list_TimeDeltainSeconds), outliers=series_outliers(list_TimeDeltainSeconds)
// expand the deltas and the outliers
| mvexpand list_TimeDeltainSeconds to typeof(double), outliers to typeof(double)
// replace outliers with the average of the distribution
| extend list_TimeDeltainSeconds_normalized=iff(outliers > 1.5 or outliers < -1.5, series_stats_list_TimeDeltainSeconds_avg , list_TimeDeltainSeconds)
// summarize with the smoothed distribution
| summarize BeaconCount=count(), makelist(list_TimeDeltainSeconds), list_TimeDeltainSeconds_normalized=makelist(list_TimeDeltainSeconds_normalized), makeset(set_DeviceAction) by StartTime, EndTime, SourceIP, DestinationIP, DestinationPort, sum_ReceivedBytes, sum_SentBytes
// get stats on the smoothed distribution
| extend series_stats(list_TimeDeltainSeconds_normalized)
// match jitter tolerance on smoothed distrib
| extend MaxJitter = (series_stats_list_TimeDeltainSeconds_normalized_avg*JitterTolerance)
| where series_stats_list_TimeDeltainSeconds_normalized_stdev < MaxJitter
// where the minimum beacon threshold is satisfied and there was some data transfer
| where BeaconCount > TotalBeaconsThreshold and (sum_SentBytes > 0 or sum_ReceivedBytes > 0)
// final projection
| project StartTime, EndTime, SourceIP, DestinationIP, DestinationPort, BeaconCount, TimeDeltasInSeconds=list_list_TimeDeltainSeconds, Periodicity=series_stats_list_TimeDeltainSeconds_normalized_avg, ReceivedBytes=sum_ReceivedBytes, SentBytes=sum_SentBytes, Actions=set_set_DeviceAction
// where periodicity is order of magnitude larger than time delta threshold (eliminates FPs whose periodicity is close to the values we ignored)
| where Periodicity >= (10*TimeDeltaThresholdInSeconds)
| extend timestamp = StartTime, IPCustomEntity = DestinationIP",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/Fortinet-NetworkBeaconPattern.yaml,2020-10-04,Fortinet-NetworkBeaconPattern.yaml
f0be259a-34ac-4946-aa15-ca2b115d5feb,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1065,Uncommonly Used Port,GCP,Detection,Azure Sentinel Community Github,Palo Alto - potential beaconing detected,"'Identifies beaconing patterns from Palo Alto Network traffic logs based on recurrent timedelta patterns. 
The query leverages various KQL functions to calculate time deltas and then compares it with total events observed in a day to find percentage of beaconing. 
This outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts.
Reference Blog:
http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/'
",PaloAltoNetworks,CommonSecurityLog,"
let starttime = 2d;
let endtime = 1d;
let TimeDeltaThreshold = 10;
let TotalEventsThreshold = 15;
let PercentBeaconThreshold = 80;
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.';
CommonSecurityLog
| where DeviceVendor == ""Palo Alto Networks"" and Activity == ""TRAFFIC""
| where TimeGenerated between (ago(starttime)..ago(endtime))
| extend DestinationIPType = iff(DestinationIP matches regex PrivateIPregex,""private"" ,""public"" )
| where DestinationIPType == ""public""
| project TimeGenerated, DeviceName, SourceUserID, SourceIP, SourcePort, DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| serialize
| extend nextTimeGenerated = next(TimeGenerated, 1), nextSourceIP = next(SourceIP, 1)
| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)
| where SourceIP == nextSourceIP
//Whitelisting criteria/ threshold criteria
| where TimeDeltainSeconds > TimeDeltaThreshold 
| project TimeGenerated, TimeDeltainSeconds, DeviceName, SourceUserID, SourceIP, SourcePort, DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| summarize count(), sum(ReceivedBytes), sum(SentBytes), make_list(TimeDeltainSeconds) 
by TimeDeltainSeconds, bin(TimeGenerated, 1h), DeviceName, SourceUserID, SourceIP, DestinationIP, DestinationPort
| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSentBytes = sum(sum_SentBytes), TotalReceivedBytes = sum(sum_ReceivedBytes) 
by bin(TimeGenerated, 1h), DeviceName, SourceUserID, SourceIP, DestinationIP, DestinationPort
| where TotalEvents > TotalEventsThreshold 
| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100
| where BeaconPercent > PercentBeaconThreshold
| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName ",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/PaloAlto-NetworkBeaconing.yaml,2020-10-04,PaloAlto-NetworkBeaconing.yaml
9e146876-e303-49af-b847-b029d1a66852,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1065,Uncommonly Used Port,SaaS,Hunting Query,Azure Sentinel Community Github,Port opened for an Azure Resource,"'Identifies what ports may have been opened for a given Azure Resource over the last 7 days' 
",AzureActivity,AzureActivity,"
let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName has_any (""Create"", ""Update"") and OperationName has_any (""Ip"", ""Security Rule"")
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatus == ""Accepted"" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatus, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml,2020-10-04,PortOpenedForAzureResource.yaml
33aa0e01-87e2-43ea-87f9-2f7e3ff1d532,2020-10-04 07:11:15.6720053,mitre-attack,CommandAndControl,T1065,Uncommonly Used Port,Linux,Hunting Query,Azure Sentinel Community Github,Detect beacon like pattern based on repetitive time intervals in Wire Data Traffic,"'This query will identify beaconing patterns from Wire Data logs based on timedelta patterns. The query leverages various KQL functions
to calculate time delta and then compare it with total events observed in a day to find percentage of beaconing.  
Results of such beaconing patterns to untrusted public networks can be a good starting point for investigation.
References: Blog about creating dataset to identify network beaconing via repetitive time intervals seen against total traffic 
between same source-destination pair. 
http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/'
",AzureMonitor(WireData),WireData,"
let starttime = 7d; 
let endtime = 1d; 
let TimeDeltaThreshold = 10; 
let TotalEventsThreshold = 15; 
let PercentBeaconThreshold = 95; 
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.'; 
WireData
| where TimeGenerated between (ago(starttime)..ago(endtime)) 
| extend RemoteIPType = iff(RemoteIP matches regex PrivateIPregex,""private"" ,""public"" ) 
| where RemoteIPType ==""public"" 
| project TimeGenerated , LocalIP , LocalPortNumber , RemoteIP, RemotePortNumber, ReceivedBytes, SentBytes 
| sort by LocalIP asc,TimeGenerated asc, RemoteIP asc, RemotePortNumber asc 
| serialize
| extend nextTimeGenerated = next(TimeGenerated, 1), nextLocalIP = next(LocalIP, 1) 
| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated) 
| where LocalIP == nextLocalIP 
//Whitelisting criteria/ threshold criteria 
| where TimeDeltainSeconds > TimeDeltaThreshold  
| where RemotePortNumber != ""0""
| project TimeGenerated, TimeDeltainSeconds, LocalIP, LocalPortNumber,RemoteIP,RemotePortNumber, ReceivedBytes, SentBytes 
| summarize count(), sum(ReceivedBytes), sum(SentBytes), make_list(TimeDeltainSeconds) by TimeDeltainSeconds, bin(TimeGenerated, 1h), LocalIP, RemoteIP, RemotePortNumber 
| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds)=arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSentBytes=sum(sum_SentBytes),TotalReceivedBytes=sum(sum_ReceivedBytes) by bin(TimeGenerated, 1h), LocalIP, RemoteIP, RemotePortNumber 
| where TotalEvents > TotalEventsThreshold  
| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100 
| where BeaconPercent > PercentBeaconThreshold
| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/WireData/WireDataBeacon.yaml,2020-10-04,WireDataBeacon.yaml
795edf2d-cf3e-45b5-8452-fe6c9e6a582e,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1498,Network Denial of Service,GCP,Detection,Azure Sentinel Community Github,Cisco ASA - threat detection message fired,"'Identifies when the Cisco ASA Threat Detection engine fired an alert based on malicious activity occurring on the network inicated by DeviceEventClassID 733101-733105
Resources: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog/syslogs9.html
Details on how to further troubleshoot/investigate: https://www.cisco.com/c/en/us/support/docs/security/asa-5500-x-series-next-generation-firewalls/113685-asa-threat-detection.html'
",CiscoASA,CommonSecurityLog,"
let timeframe = 1h;
CommonSecurityLog 
| where TimeGenerated >= ago(timeframe)
| where isempty(CommunicationDirection) 
| where DeviceEventClassID in (""733101"",""733102"",""733103"",""733104"",""733105"")
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName
",1h,1h,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/CiscoASA-ThreatDetectionMessage.yaml,2020-10-04,CiscoASA-ThreatDetectionMessage.yaml
79f29feb-6a9d-4cdf-baaa-2daf480a5da1,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1498,Network Denial of Service,GCP,Detection,Azure Sentinel Community Github,Cisco ASA - average attack detection rate increase,"'This will help you determine if Cisco ASA devices are under heavier attack than normal over the last hour versus the previous 6 hours based on DeviceEventClassID 733100
References: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog/syslogs9.html
Details on how to further troubleshoot/investigate: https://www.cisco.com/c/en/us/support/docs/security/asa-5500-x-series-next-generation-firewalls/113685-asa-threat-detection.html'
",CiscoASA,CommonSecurityLog,"
let timeframe = 1h;
let last1h = CommonSecurityLog 
| where TimeGenerated >= ago(timeframe)
| where isempty(CommunicationDirection) 
| where DeviceEventClassID == ""733100""
| extend SourceOfDropRateCount = tostring(split(tostring(split(Message, ""]"")[0]),""[ "")[1])
| extend splitMessage = split(Message, ""."")
| extend DropRate = tostring(split(tostring(splitMessage[0]),""] "")[1])
| extend CurrentBurstRate = split(tostring(split(tostring(splitMessage[1]),""  "")[0]),""is "")
| extend CurrentBurstRatePerSec = toint(split(tostring(CurrentBurstRate[1]),"" "")[0])
| extend MaxConfiguredBurstRate = toint(CurrentBurstRate[2])
| extend CurrentAvgRate = split(tostring(split(tostring(splitMessage[1]),""  "")[1]),""is "")
| extend CurrentAvgRatePerSec = toint(split(tostring(CurrentAvgRate[1]),"" "")[0])
| extend MaxConfiguredAvgRate = toint(CurrentAvgRate[2])
| extend CumulativeTotal = toint(split(tostring(split(tostring(splitMessage[1]),""  "")[2]),""is "")[1])
| summarize last1hCumTotal = sum(CumulativeTotal), last1hAvgRatePerSec = avg(CurrentAvgRatePerSec), last1hAvgBurstRatePerSec = avg(CurrentBurstRatePerSec) by DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate;
let prev6h = CommonSecurityLog 
| where TimeGenerated between (ago(6h) .. ago(1h))
| where isempty(CommunicationDirection) 
| where DeviceEventClassID == ""733100""
| extend SourceOfDropRateCount = tostring(split(tostring(split(Message, ""]"")[0]),""[ "")[1])
| extend splitMessage = split(Message, ""."")
| extend DropRate = tostring(split(tostring(splitMessage[0]),""] "")[1])
| extend CurrentBurstRate = split(tostring(split(tostring(splitMessage[1]),""  "")[0]),""is "")
| extend prevCurrentBurstRatePerSec = toint(split(tostring(CurrentBurstRate[1]),"" "")[0])
| extend prevMaxConfiguredBurstRate = toint(CurrentBurstRate[2])
| extend CurrentAvgRate = split(tostring(split(tostring(splitMessage[1]),""  "")[1]),""is "")
| extend prevCurrentAvgRatePerSec = toint(split(tostring(CurrentAvgRate[1]),"" "")[0])
| extend prevMaxConfiguredAvgRate = toint(CurrentAvgRate[2])
| extend prevCumulativeTotal = toint(split(tostring(split(tostring(splitMessage[1]),""  "")[2]),""is "")[1])
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), prev6hCumTotal = sum(prevCumulativeTotal), prev6hAvgRatePerSec = avg(prevCurrentAvgRatePerSec), prev6hAvgBurstRatePerSec = avg(prevCurrentBurstRatePerSec) 
by DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate;
last1h | join (
  prev6h 
) on DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate
| project StartTimeUtc, EndTimeUtc, DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate, last1hCumTotal, prev6hCumTotal, prev6hAvgCumTotal = prev6hCumTotal/6, last1hAvgRatePerSec, prev6hAvgRatePerSec, last1hAvgBurstRatePerSec, prev6hAvgBurstRatePerSec
// Select only events that indicate a doubling of the expected rate in the last hour over the previous 6 hours
| where last1hCumTotal > 2*prev6hAvgCumTotal or last1hAvgRatePerSec > 2*prev6hAvgRatePerSec or last1hAvgBurstRatePerSec > 2*prev6hAvgBurstRatePerSec
| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName
",1h,6h,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/CiscoASA-AvgAttackDetectRateIncrease.yaml,2020-10-04,CiscoASA-AvgAttackDetectRateIncrease.yaml
32555639-b639-4c2b-afda-c0ae0abefa55,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1087,Account Discovery,AWS,Detection,Azure Sentinel Community Github,Monitor AWS Credential abuse or hijacking,"'Looking for GetCallerIdentity Events where the UserID Type is AssumedRole 
An attacker who has assumed the role of a legitimate account can call the GetCallerIdentity function to determine what account they are using.
A legitimate user using legitimate credentials would not need to call GetCallerIdentity since they should already know what account they are using.
More Information: https://duo.com/decipher/trailblazer-hunts-compromised-credentials-in-aws
AWS STS GetCallerIdentity API: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html '
",AWS,AWSCloudTrail,"
let timeframe = 1d;
AWSCloudTrail
| where TimeGenerated > ago(timeframe)
| where EventName =~ ""GetCallerIdentity"" and UserIdentityType =~ ""AssumedRole"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIpAddress, EventName, EventTypeName, UserIdentityType, UserIdentityAccountId, UserIdentityPrincipalid, 
UserAgent, UserIdentityUserName, SessionMfaAuthenticated,AWSRegion, EventSource, AdditionalEventData, ResponseElements
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress
| sort by EndTimeUtc desc nulls last ",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_CredentialHijack.yaml,2020-10-04,AWS_CredentialHijack.yaml
5d2399f9-ea5c-4e67-9435-1fba745f3a39,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1087,Account Discovery,SaaS,Hunting Query,Azure Sentinel Community Github,Azure storage key enumeration,"'Listing of storage keys is an interesting operation in Azure which might expose additional 
secrets and PII to callers as well as granting access to VMs. While there are many benign operations of this
type, it would be interesting to see if the account performing this activity or the source IP address from 
which it is being done is anomalous. 
The query below generates known clusters of ip address per caller, notice that users which only had single
operations do not appear in this list as we cannot learn from it their normal activity (only based on a single
event). The activities for listing storage account keys is correlated with this learned 
clusters of expected activities and activity which is not expected is returned.' 
",AzureActivity,AzureActivity,"
let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""List Storage Account Keys""
| where ActivityStatus == ""Succeeded"" 
| join kind= inner (
    AzureActivity
    | where TimeGenerated >= ago(timeframe)
    | where OperationName == ""List Storage Account Keys""
    | where ActivityStatus == ""Succeeded"" 
    | project ExpectedIpAddress=CallerIpAddress, Caller 
    | evaluate autocluster()
) on Caller 
| where CallerIpAddress != ExpectedIpAddress
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResourceIds = makeset(ResourceId), ResourceIdCount = dcount(ResourceId) by OperationName, Caller, CallerIpAddress
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Anomalous_Listing_Of_Storage_Keys.yaml,2020-10-04,Anomalous_Listing_Of_Storage_Keys.yaml
66fb97d1-55c3-4268-ac22-b9742d0fdccc,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1087,Account Discovery,Office 365,Hunting Query,Azure Sentinel Community Github,Rare domains seen in Cloud Logs,"'This will identify rare domain accounts accessing or attempting to access cloud resources by examining the AuditLogs, OfficeActivity and SigninLogs
Rare does not mean malicious, but it may be something you would be interested in investigating further
Additionally, it is possible that there may be many domains if you have allowed access by 3rd party domain accounts.
Lower the domainLimit value as needed.  For example, if you only want to see domains that have an access attempt count of 2 or less,
then set domainLimit = 2 below.  If you need to set it lower only for a given log, then use customLimit in the same way and uncomment 
that line in the script.'
",Office365,OfficeActivity,"
// Provide customLimit value with default above domainLimit value so it will not block unless changed
let customLimit = 11;
let domainLimit = 10;
let lookback = 14d;
let domainLookback = union isfuzzy=true
(AuditLogs
| where TimeGenerated >= ago(lookback)
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
// parse out AuditLog values for various locations where UPN could be
| extend UserPrincipalName = iff(isnotempty(UserPrincipalName),
UserPrincipalName, 
iif((tostring(InitiatedBy.user.userPrincipalName)=='unknown'), 
extract(""Email: ([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+)"", 1, tostring(parse_json(TargetResources)[0].displayName)), 
InitiatedBy.user.userPrincipalName))
| where UserPrincipalName has ""@"" or UserPrincipalName startswith ""NT AUTHORITY""
| extend RareDomain = toupper(tostring(split(UserPrincipalName, ""@"")[-1]))
| where isnotempty(RareDomain) 
| summarize RareDomainCount = count() by Type, RareDomain
| where RareDomainCount <= domainLimit
| extend AccountCustomEntity = UserPrincipalName
// remove comment from below if you would like to have a lower limit for RareDomainCount specific to AuditLog
//| where RareDomainCount <= customLimit
),
(OfficeActivity
| where TimeGenerated >= ago(lookback)
| extend UserPrincipalName = tolower(UserId)
| where UserPrincipalName has ""@"" or UserPrincipalName startswith ""NT AUTHORITY""
| extend RareDomain = toupper(tostring(split(UserPrincipalName, ""@"")[-1]))
| summarize RareDomainCount = count() by Type, RareDomain
| where RareDomainCount <= domainLimit
| extend AccountCustomEntity = UserPrincipalName
// remove comment from below if you would like to have a lower limit for RareDomainCount specific to OfficeActivity
//| where RareDomainCount <= customLimit
),
(SigninLogs
| where TimeGenerated >= ago(lookback)
| where UserPrincipalName has ""@"" or UserPrincipalName startswith ""NT AUTHORITY""
| extend RareDomain = toupper(tostring(split(UserPrincipalName, ""@"")[-1]))
| summarize RareDomainCount = count() by Type, RareDomain
| where RareDomainCount <= domainLimit
// remove comment from below if you would like to have a lower limit for RareDomainCount specific to SigninLogs
//| where RareDomainCount <= customLimit
);
let AuditLogsRef = domainLookback | join (
   AuditLogs
   | where TimeGenerated >= ago(lookback)
   | extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
   | extend UserPrincipalName = iff(isempty(UserPrincipalName), tostring(InitiatedBy.user.userPrincipalName), UserPrincipalName)
   | extend RareDomain = toupper(tostring(split(UserPrincipalName, ""@"")[-1]))
   | where isnotempty(RareDomain) 
   | summarize UPNRefCount = count() by TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName, Category, Result
   | extend AccountCustomEntity = UserPrincipalName
) on Type, RareDomain;
let OfficeActivityRef = domainLookback | join (
    OfficeActivity
    | where TimeGenerated >= ago(lookback)
    | extend UserPrincipalName = tolower(UserId)
    | where UserPrincipalName has ""@"" or UserPrincipalName startswith ""NT AUTHORITY""
    | extend RareDomain = toupper(tostring(split(UserPrincipalName, ""@"")[-1]))
    | summarize UPNRefCount = count() by TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName = Operation, Category = OfficeWorkload, Result = ResultStatus
    | extend AccountCustomEntity = UserPrincipalName
) on Type, RareDomain;
let SigninLogsRef = domainLookback | join (
    SigninLogs
    | where TimeGenerated >= ago(lookback)
    | extend UserPrincipalName = tolower(UserId)
    | where UserPrincipalName has ""@"" or UserPrincipalName startswith ""NT AUTHORITY""
    | extend RareDomain = toupper(tostring(split(UserPrincipalName, ""@"")[-1]))
    | summarize UPNRefCount = count() by TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName, Category = AppDisplayName, Result = ResultType
    | extend AccountCustomEntity = UserPrincipalName
) on Type, RareDomain;
let Results = union isfuzzy=true
AuditLogsRef,OfficeActivityRef,SigninLogsRef;
Results | project TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName, Category, Result, UPNRefCount 
| order by TimeGenerated asc 
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDomainsInCloudLogs.yaml,2020-10-04,RareDomainsInCloudLogs.yaml
431cccd3-2dff-46ee-b34b-61933e45f556,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1087,Account Discovery,SaaS,Hunting Query,Azure Sentinel Community Github,Tracking Privileged Account Rare Activity,"'This query will determine rare activity by a high-value account carried out on a system or service.
High Value accounts are determined by Group Membership to High Value groups via events listed below.
Rare here means an activity type seen in the last day which has not been seen in the previous 7 days.
If any account with such rare activity is found, the query will attempt to retrieve related activity
from that account on that same day and summarize the information.
4728 - A member was added to a security-enabled global group
4732 - A member was added to a security-enabled local group
4756 - A member was added to a security-enabled universal group'
",AzureMonitor(IIS),W3CIISLog,"
let LocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let GroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$"";
let timeframe = 8d;
let p_Accounts = SecurityEvent
| where TimeGenerated > ago(timeframe)
| where EventID in (""4728"", ""4732"", ""4756"") and AccountType == ""User"" and MemberName == ""-""
// Exclude Remote Desktop Users group: S-1-5-32-555 and IIS Users group S-1-5-32-568
| where TargetSid !in (""S-1-5-32-555"", ""S-1-5-32-568"")
| where TargetSid matches regex LocalSID or TargetSid matches regex GroupSID
| summarize by DomainSlashAccount = tolower(SubjectAccount), NtDomain = SubjectDomainName,
AccountAtDomain = tolower(strcat(SubjectUserName,""@"",SubjectDomainName)), AccountName = tolower(SubjectUserName);
// Build custom high value account list
let cust_Accounts = datatable(Account:string, NtDomain:string, Domain:string)[
""john"", ""Contoso"", ""contoso.com"",  ""greg"", ""Contoso"", ""contoso.com"",  ""larry"", ""Domain"", ""contoso.com""];
let c_Accounts = cust_Accounts
| extend AccountAtDomain = tolower(strcat(Account,""@"",Domain)), AccountName = tolower(Account),
DomainSlashAccount = tolower(strcat(NtDomain,""\\"",Account));
let AccountFormat = p_Accounts | union c_Accounts | project AccountName, AccountAtDomain, DomainSlashAccount;
// Normalize activity from diverse sources into common schema using a function
let activity = view (a_StartTime:datetime, a_EndTime:datetime) {
(union isfuzzy=true
(AccountFormat | join kind=inner 
(AWSCloudTrail
| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime
| extend ClientIP = ""-"", AccountName = tolower(UserIdentityUserName), WinSecEventDomain = ""-""
| project-rename EventType = EventName, ServiceOrSystem = EventSource)
on AccountName),
(AccountFormat | join kind=inner
(SigninLogs
| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime
| extend AccountName = tolower(split(UserPrincipalName, ""@"")[0]), WinSecEventDomain = ""-""
| project-rename EventType = strcat(OperationName, ""-"", ResultType, ""-"", ResultDescription), ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)
on AccountName),
(AccountFormat | join kind=inner
(OfficeActivity
| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime
| extend AccountName = tolower(split(UserId, ""@"")[0]), WinSecEventDomain = ""-""
| project-rename EventType = strcat(Operation, ""-"", ResultStatus), ServiceOrSystem = OfficeWorkload)
on AccountName),
(AccountFormat | join kind=inner
(SecurityEvent
| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime
| where EventID in (4624, 4625) 
| extend ClientIP = ""-""
| extend AccountName = tolower(split(Account,""\\"")[1]), Domain = tolower(split(Account,""\\"")[0])
| project-rename EventType = Activity, ServiceOrSystem = Computer, WinSecEventDomain = Domain)
on AccountName),
(AccountFormat | join kind=inner
(W3CIISLog
| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime
| where csUserName != ""-"" and isnotempty(csUserName)
| extend AccountName = tolower(csUserName), WinSecEventDomain = ""-""
| project-rename EventType = csMethod, ServiceOrSystem = sSiteName, ClientIP = cIP)
on AccountName),
(AccountFormat | join kind=inner
(W3CIISLog
| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime
| where csUserName != ""-"" and isnotempty(csUserName)
| extend AccountAtDomain = tolower(csUserName), WinSecEventDomain = ""-""
| project-rename EventType = csMethod, ServiceOrSystem = sSiteName, ClientIP = cIP)
on AccountAtDomain));
};
// Rare activity today versus prior week
let LastDay = startofday(ago(1d));
let PrevDay = endofday(ago(2d));
let Prev7Day = startofday(ago(8d));
let ra_LastDay = activity(LastDay, now())
| summarize ra_StartTime = min(TimeGenerated), ra_EndTime = max(TimeGenerated),
ra_Count = count() by Type, AccountName, EventType, ClientIP, ServiceOrSystem, WinSecEventDomain;
let a_7day = activity(Prev7Day, PrevDay)
| summarize ha_Count = count() by Type, AccountName, EventType, ClientIP, ServiceOrSystem, WinSecEventDomain;
let ra_Today = ra_LastDay | join kind=leftanti (a_7day) on Type, AccountName, ServiceOrSystem
| extend RareServiceOrSystem = ServiceOrSystem;
// Retrieve related activity as context
let a_Related =
(union isfuzzy=true
(// Make sure we at least publish the unusual activity we identified above - even if no related context activity is found in the subsequent union
ra_Today),
// Remaining elements of the union look for related activity
(ra_Today | join kind=inner
(OfficeActivity
| where TimeGenerated > LastDay
| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(OfficeWorkload),
rel_ServiceOrSystemSet = makeset(OfficeWorkload), rel_ClientIPSet = makeset(ClientIP),
rel_Count = count() by AccountName = tolower(UserId), rel_EventType = Operation, Type
) on AccountName),
(ra_Today | join kind=inner
(SecurityEvent | where TimeGenerated > LastDay
| where EventID in (4624, 4625)
| where AccountType == ""User""
| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(Computer),
rel_ServiceOrSystemSet = makeset(Computer), rel_ClientIPSet = makeset(""-""),
rel_Count = count() by DomainSlashAccount = tolower(Account), rel_EventType = Activity, Type
) on DomainSlashAccount),
(ra_Today | join kind=inner
(Event | where TimeGenerated > LastDay
// 7045: A service was installed in the system
| where EventID == 7045
| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(Computer),
rel_ServiceOrSystemSet = makeset(Computer), rel_ClientIPSet = makeset(""-""),
rel_Count = count() by DomainSlashAccount = tolower(UserName), rel_EventType = strcat(EventID, ""-"", tostring(split(RenderedDescription,""."")[0])), Type
) on DomainSlashAccount),
(ra_Today | join kind=inner
(SecurityEvent | where TimeGenerated > LastDay
// 4720: Account created, 4726: Account deleted
| where EventID in (4720,4726)
| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(UserPrincipalName),
rel_ServiceOrSystemSet = makeset(UserPrincipalName), rel_ClientIPSet = makeset(""-""),
rel_Count = count() by DomainSlashAccount = tolower(Account), rel_EventType = Activity, Type
) on DomainSlashAccount),
(ra_Today | join kind=inner
(SigninLogs | where TimeGenerated > LastDay
| extend RemoteHost = tolower(tostring(parsejson(DeviceDetail.[""displayName""])))
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser, StatusCode = tostring(Status.errorCode),
StatusDetails = tostring(Status.additionalDetails), State = tostring(LocationDetails.state)
| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), a_RelatedRemoteHostSet = makeset(RemoteHost),
rel_ServiceOrSystemSet = makeset(AppDisplayName), rel_ServiceOrSystemCount = dcount(AppDisplayName), rel_ClientIPSet = makeset(IPAddress),
rel_StateSet = makeset(State),
rel_Count = count() by AccountAtDomain = tolower(UserPrincipalName), rel_EventType = iff(isnotempty(ResultDescription), ResultDescription, StatusDetails), Type
) on AccountAtDomain),
(ra_Today | join kind=inner
(AWSCloudTrail | where TimeGenerated > LastDay
| summarize rel_StartTime = min(TimeGenerated),rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemSet = makeset(EventSource),
rel_ServiceOrSystemCount = dcount(EventSource), rel_ClientIPSet = makeset(""-""),
rel_Count= count() by AccountName = tolower(UserIdentityUserName), rel_EventType = EventName, Type
) on AccountName),
(ra_Today | join kind=inner
(SecurityAlert | where TimeGenerated > LastDay
| extend ExtProps=parsejson(ExtendedProperties)
| extend AccountName = tostring(ExtProps.[""user name""])
| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(AlertType),
rel_ServiceOrSystemSet = makeset(AlertType), 
rel_Count = count() by DomainSlashAccount = tolower(AccountName), rel_EventType = ProductName, Type
) on DomainSlashAccount)
);
a_Related
| project Type, RareActivtyStartTimeUtc = ra_StartTime, RareActivityEndTimeUtc = ra_EndTime, RareActivityCount = ra_Count,
AccountName, WinSecEventDomain, EventType, RareServiceOrSystem, RelatedActivityStartTimeUtc = rel_StartTime,
RelatedActivityEndTimeUtc = rel_EndTime, RelatedActivityEventType = rel_EventType, RelatedActivityClientIPSet = rel_ClientIPSet,
RelatedActivityServiceOrSystemCount = rel_ServiceOrSystemCount, RelatedActivityServiceOrSystemSet = rel_ServiceOrSystemSet, RelatedActivityCount = rel_Count
| extend timestamp = RareActivtyStartTimeUtc, AccountCustomEntity = AccountName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/TrackingPrivAccounts.yaml,2020-10-04,TrackingPrivAccounts.yaml
42e69ff6-719d-4853-95a5-2b211e2bb031,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1213,Data from Information Repositories,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps- Project visibility changed to public,"'This hunting query identifies Azure DevOps activities where organization project visibility changed to public project'
",AzureMonitor,AzureDevOpsAuditing,"let timeframe = 7d;
AzureDevOpsAuditing
| where TimeGenerated >= ago(timeframe)
| where Area == ""Project""
| where OperationName == ""Project.UpdateVisibilityCompleted""
| where Data.PreviousProjectVisibility == ""private""
| where Data.ProjectVisibility == ""public""
| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Project%20visibility%20changed%20to%20public.yaml,2020-10-04,Project%20visibility%20changed%20to%20public.yaml
a6e2afd3-559c-4e88-a693-39c1f6789ef1,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,GitHub Repo switched from private to public,"'This hunting query identifies GitHub activites where a repo was changed from private to public that may be a sign of compromise.'
",CustomConnector,CustomLogs_CL,"
let timeframe = 14d;
GitHubAudit
| where TimeGenerated > ago(timeframe)
| where Action == ""repo.access""
| where OperationType == ""MODIFY""
| where node_visibility_s == ""PUBLIC"" 
| project TimeGenerated, Action, Actor, Country, Repository, Visability
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Repository%20Permission%20Switched%20to%20Public.yaml,2020-10-04,Repository%20Permission%20Switched%20to%20Public.yaml
ccef3c74-4b4f-445b-8109-06d38687e4a4,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,GitHub Repo Clone - Time Series Anomly,"'Attacker can exfiltrate data from you GitHub repository after gaining access to it by performing clone action. This hunting queries allows you to track the clones activities for each of your repositories. The visualization allow you to quickly identify anomalies/excessive clone, to further investigate repo access & permissions'
",CustomConnector,CustomLogs_CL,"
let min_t = toscalar(GitHubRepo
| summarize min(timestamp_t));
let max_t = toscalar(GitHubRepo
| summarize max(timestamp_t));
GitHubRepo
| where Action == ""Clones""
| distinct TimeGenerated, Repository, Count
| make-series num=sum(Count) default=0 on TimeGenerated in range(min_t, max_t, 1h) by Repository 
| extend (anomalies, score, baseline) = series_decompose_anomalies(num, 1.5, -1, 'linefit')
| render timechart 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Unusual%20Number%20of%20Repository%20Clones.yaml,2020-10-04,Unusual%20Number%20of%20Repository%20Clones.yaml
cf0c493b-a8af-4b32-8c7e-d4303f3a406f,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1036,Masquerading,Azure,Hunting Query,Azure Sentinel Community Github,Azure DevOps Display Name Changes,"'Shows all users with more than 1 display name in recent history.  This is to hunt for users maliciously changing their display name as a masquerading technique'
",AzureMonitor,AzureDevOpsAuditing,"
let timeframe = 14d;
AzureDevOpsAuditing
| where TimeGenerated > ago(timeframe)
| where ActorCUID != '00000000-0000-0000-0000-000000000000' and ActorDisplayName != ""Azure DevOps User""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), DisplayNameCount = dcount(ActorDisplayName), ActorDisplayNames = make_set(ActorDisplayName), make_set(IpAddress), make_set(ProjectName) by ActorCUID, ActorUPN
| where DisplayNameCount > 1
| extend timestamp = StartTime, AccountCustomEntity = ActorUPN",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/AzDODisplayNameSwapping.yaml,2020-10-04,AzDODisplayNameSwapping.yaml
d12580c2-1474-4125-a8a3-553f50d91215,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1036,Masquerading,Office 365,Hunting Query,Azure Sentinel Community Github,Exes with double file extentsion and access summary,"'Provides a summary of executable files with double file extensions in SharePoint 
 and the users and IP addresses that have accessed them.'
",Office365,OfficeActivity,"
let timeframe = 14d;
let known_ext = dynamic([""lnk"",""log"",""option"",""config"", ""manifest"", ""partial""]);
let excluded_users = dynamic([""app@sharepoint""]);
OfficeActivity
| where TimeGenerated > ago(timeframe)
| where RecordType =~ ""SharePointFileOperation"" and isnotempty(SourceFileName)
| where OfficeObjectId has "".exe."" and SourceFileExtension !in~ (known_ext)
| extend Extension = extract(""[^.]*.[^.]*$"",0, OfficeObjectId)
| join kind= leftouter ( 
  OfficeActivity
    | where TimeGenerated > ago(timeframe)
    | where RecordType =~ ""SharePointFileOperation"" and (Operation =~ ""FileDownloaded"" or Operation =~ ""FileAccessed"") 
    | where SourceFileExtension !in~ (known_ext)
) on OfficeObjectId 
| where UserId1 !in~ (excluded_users)
| extend userBag = pack(UserId1, ClientIP1) 
| summarize makeset(UserId1), make_bag(userBag), Start=max(TimeGenerated), End=min(TimeGenerated) by UserId, OfficeObjectId, SourceFileName, Extension 
| extend NumberOfUsers = array_length(bag_keys(bag_userBag))
| project UploadTime=Start, Uploader=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName, AccessedBy=bag_userBag, Extension, NumberOfUsers
| extend timestamp = UploadTime, AccountCustomEntity = Uploader",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/double_file_ext_exes.yaml,2020-10-04,double_file_ext_exes.yaml
22b0262c-b6b5-4f15-82a4-93663e9965d7,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1531,Account Access Removal,SaaS,Hunting Query,Azure Sentinel Community Github,Anomalous Password Reset,"'Adversaries may interrupt availability of system and network resources by inhibiting access to accounts utilized by legitimate users. Accounts may be deleted, locked, or manipulated (ex: changed credentials) to remove access to accounts. LockerGoga, for example, has been observed changing account passwords and logging off current users. The query below generates an output of all users performing Reset user password where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,AuditLogs,"
BehaviorAnalytics
| where ActionType == ""Reset user password""
| where ActivityInsights has ""True""
| join (
AuditLogs
) on $left.SourceRecordId == $right._ItemId
| mv-expand TargetResources
| extend Target =  iff(tostring(TargetResources.userPrincipalName) has ""#EXT#"",replace(""_"",""@"",tostring(split(TargetResources.userPrincipalName, ""#"")[0])),TargetResources.userPrincipalName),tostring(TargetResources.userPrincipalName)
| extend UserPrincipalName = iff(UserPrincipalName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserPrincipalName),
UserName = iff(UserName has ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserName)
| sort by TimeGenerated desc
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [""TargetUser""]=Target,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Password%20Reset.yaml,2020-10-04,Anomalous%20Password%20Reset.yaml
e7642e6e-cf27-46ec-a4b9-e4475228fead,2020-10-04 07:11:15.6720053,mitre-attack,Impact,T1531,Account Access Removal,Windows,Hunting Query,Azure Sentinel Community Github,AD Account Lockout,"'Detects Active Directory account lockouts'
",SecurityEvents,SecurityEvent,"let timeframe = 7d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4740
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), LockoutsCount = count() by Activity, Account, TargetSid, TargetDomainName, SourceComputerId, SourceDomainController = Computer
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = TargetDomainName
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ADAccountLockouts.yaml,2020-10-04,ADAccountLockouts.yaml
77a58c08-bc8e-48b3-8fe9-6c38fd011cd9,2020-10-04 07:11:15.6720053,,CredentialAccess,T1110.001,,Azure AD,Hunting Query,Azure Sentinel Community Github,Anomalous Failed Logon,"'Adversaries with no prior knowledge of legitimate credentials within the system or environment may guess passwords to attempt access to accounts. Emotet, for example, has been observed using a hard coded list of passwords to brute force user accounts. The query below generates an output of all users with 'High' BlastRadius that perform failed Sign-in:Invalid username or password.'
",BehaviorAnalytics,SigninLogs,"
BehaviorAnalytics
| where ActivityType == ""LogOn""
| where UsersInsights.BlastRadius == ""High""
| join (
SigninLogs  | where Status.errorCode == 50126
) on $left.SourceRecordId == $right._ItemId
| extend UserPrincipalName = iff(UserPrincipalName contains ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserPrincipalName),
UserName = iff(UserName contains ""#EXT#"",replace(""_"",""@"",tostring(split(UserPrincipalName, ""#"")[0])),UserName)
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,[""Evidence""]=ActivityInsights, ResourceDisplayName,AppDisplayName ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Failed%20Logon.yaml,2020-10-04,Anomalous%20Failed%20Logon.yaml
1ef1c38f-26dd-4e28-b884-5b3665352648,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1053,Scheduled Task/Job,Linux,Hunting Query,Azure Sentinel Community Github,Crypto currency miners EXECVE,"'This query hunts through EXECVE syslog data generated by AUOMS to find instances of crypto currency miners being
downloaded.  It returns a table of suspicious command lines.
Find more details on collecting EXECVE data into Azure Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'
",Syslog,Syslog,"// Extract EventType and EventData from AUOMS Syslog message
Syslog
| parse SyslogMessage with ""type="" EventType "" audit("" * ""): "" EventData
| project TimeGenerated, EventType, Computer, EventData 
// Extract AUOMS_EXECVE details from EventData
| where EventType =~ ""AUOMS_EXECVE""
| parse EventData with * ""syscall="" syscall "" syscall_r="" * "" success="" success "" exit="" exit "" a0"" * "" ppid="" ppid "" pid="" pid "" audit_user="" audit_user "" auid="" auid "" user="" user "" uid="" uid "" group="" group "" gid="" gid ""effective_user="" effective_user "" euid="" euid "" set_user="" set_user "" suid="" suid "" filesystem_user="" filesystem_user "" fsuid="" fsuid "" effective_group="" effective_group "" egid="" egid "" set_group="" set_group "" sgid="" sgid "" filesystem_group="" filesystem_group "" fsgid="" fsgid "" tty="" tty "" ses="" ses "" comm=\"""" comm ""\"" exe=\"""" exe ""\"""" * ""cwd=\"""" cwd ""\"""" * ""name=\"""" name ""\"""" * ""cmdline=\"""" cmdline ""\"" containerid="" containerid
// Find wget and curl commands
| where comm in (""wget"", ""curl"")
// Find command lines featuring known crypto currency miner names
| where cmdline contains ""nicehashminer"" or cmdline contains ""ethminer"" or cmdline contains ""equihash"" or cmdline contains ""NsCpuCNMiner64"" or cmdline contains ""minergate"" or cmdline contains ""minerd"" or cmdline contains ""cpuminer"" or cmdline contains ""xmr-stak-cpu"" or cmdline contains ""xmrig"" or cmdline contains ""stratum+tcp"" or cmdline contains ""cryptonight"" or cmdline contains ""monero"" or cmdline contains ""oceanhole"" or cmdline contains ""dockerminer"" or cmdline contains ""xmrdemo""
| project TimeGenerated, Computer, audit_user, user, cmdline
| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated
| sort by TimeGenerated desc
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/CryptoCurrencyMiners.yaml,2020-10-04,CryptoCurrencyMiners.yaml
d0ae35df-0eaf-491f-b23e-8190e4f3ffe9,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1037,Boot or Logon Initialization Scripts,Linux,Hunting Query,Azure Sentinel Community Github,Rare process running on a Linux host,"'Looks for rare processes that are running on Linux hosts. Looks for process seen less than 14 times in last 7 days, 
 or observed rate is less than 1% of of the average for the environment and fewer than 100.'
",Syslog,Syslog,"let starttime = 7d;
let endtime = 1m;
let lookback = 30d
let count_threshold = 100;
let perc_threshold = 0.01;
let host_threshold = 14;
let basic=materialize(
  Syslog
    | where TimeGenerated >= ago(lookback)
    | summarize FullCount = count()
                , Count= countif(TimeGenerated between (ago(starttime) .. ago(endtime)))
                , min_TimeGenerated=min(TimeGenerated)
                , max_TimeGenerated=max(TimeGenerated) 
                      by Computer, ProcessName
    | where Count > 0 and Count < count_threshold);
let basic_avg = basic
    | summarize Avg = avg(FullCount) by  ProcessName;
basic | project-away FullCount
  | join kind=inner 
basic_avg 
  on ProcessName | project-away ProcessName1
  | where Count < host_threshold or (Count <= Avg*perc_threshold and Count < count_threshold) 
  | extend HostCustomEntity=Computer",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/RareProcess_ForLxHost.yaml,2020-10-04,RareProcess_ForLxHost.yaml
6f0f1821-5981-408a-930b-8b2ca60e9e6c,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1037,Boot or Logon Initialization Scripts,Linux,Hunting Query,Azure Sentinel Community Github,Editing Linux scheduled tasks through Crontab,"'This query shows when users have edited or replaced the scheduled tasks using crontab. The events are bucketed into 10 minute intervals 
and all the actions that a particular used took are collected into the List of Actions. Default query is for seven days.'
",Syslog,Syslog,"
// Change startdate below if you want a different timespan
let startdate = 14d;
// Pull messages from Syslog-cron logs where the process is crontab and the severity level is ""info"". Extract the User and Action information from the SyslogMessage
Syslog 
| where TimeGenerated  >= ago(startdate)
| where Facility =~ ""cron"" 
| where ProcessName =~ ""crontab"" 
| where SeverityLevel =~ ""info"" 
| project TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage
| parse SyslogMessage with * ""("" user  "") "" Action "" ("" *
// Only look for messages that contain edit or replace
| where Action contains ""EDIT"" or Action contains ""REPLACE""
//| summarize all the actions into a single set based on 10 minute time intervals
| summarize makeset(Action) by bin(TimeGenerated, 10m), Computer, user  
| project EventTime10MinInterval = TimeGenerated, Computer, user, ListOfActions = set_Action 
| order by Computer asc nulls last, EventTime10MinInterval asc
| extend timestamp = EventTime10MinInterval, AccountCustomEntity = user, HostCustomEntity = Computer
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/SchedTaskEditViaCrontab.yaml,2020-10-04,SchedTaskEditViaCrontab.yaml
eb09da09-6f6c-4502-bf74-f7b9f1343539,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1037,Boot or Logon Initialization Scripts,Linux,Hunting Query,Azure Sentinel Community Github,Linux scheduled task Aggregation,"'This query aggregates information about all of the scheduled tasks (Cron jobs) and presents the data in a chart.
The aggregation is done based on unique user-commandline pairs. It returns how many times a command line has
been run from a particular user, how many computers that pair has run on, and what percentage that is of the
total number of computers in the tenant.'
",Syslog,Syslog,"
// Change startdate below if you want a different timespan
let startdate = 7d;
// Pull messages from Syslog-cron where the process name is ""CRON"" or ""CROND"", the severity level is info, and the SyslogMessage contains ""CMD"".
// It also parses out the user and commandline from the message.
let RawCommands = Syslog 
| where TimeGenerated >= ago(startdate)
| where Facility =~ ""cron"" 
| where SeverityLevel =~ ""info"" 
| where ProcessName =~ ""CRON"" or ProcessName =~ ""CROND""  
| where SyslogMessage contains ""CMD "" 
| project TenantId, TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage
| extend TrimmedSyslogMsg = trim_end(@""\)"", SyslogMessage)
| parse TrimmedSyslogMsg with * ""("" user  "") CMD ("" cmdline 
| project TenantId, TimeGenerated, Computer, user, cmdline; 
// Count how many times a particular commandline has been seen based on unique Computer, User, and cmdline sets
let CommandCount = RawCommands
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count(cmdline) by Computer, user, cmdline
| project StartTimeUtc, EndTimeUtc, Computer, user, cmdline, CmdlineCount = count_cmdline ; 
// Count how many computers have run a particular user and cmdline pair
let DistComputerCount = RawCommands
| summarize dcount(Computer) by TenantId, user, cmdline
| project TenantId, user, cmdline, ComputerCount = dcount_Computer ; 
// Join above counts based on user and commandline pair
let CommandSummary = CommandCount | join (DistComputerCount) on user, cmdline
| project StartTimeUtc, EndTimeUtc, TenantId, user, CmdlineCount, ComputerCount, cmdline ;
// Count the total number of computers reporting cron messages in the tenant
let TotalComputers = Syslog
| where Facility =~ ""cron""
| summarize dcount(Computer) by TenantId ;
// Join the previous counts with the total computers count. Calculate the percentage of total computers value.
let FinalSummary = CommandSummary | join kind= leftouter (TotalComputers) on TenantId
| project StartTimeUtc, EndTimeUtc, user, TimesCmdlineSeen = CmdlineCount, CompsThatHaveRunCmdline = ComputerCount, 
AsPercentOfTotalComps = round(100 * (toreal(ComputerCount)/toreal(dcount_Computer)),2), cmdline
| order by user asc, TimesCmdlineSeen desc;
FinalSummary 
| extend timestamp = StartTimeUtc, AccountCustomEntity = user
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/SchedTaskAggregation.yaml,2020-10-04,SchedTaskAggregation.yaml
bc17381e-07ee-48a2-931f-06a3d9e149c9,2020-10-04 07:11:15.6720053,mitre-attack,LateralMovement,T1021,Remote Services,Azure AD,Hunting Query,Azure Sentinel Community Github,Same User - Successful logon for a given App and failure on another App within 1m and low distribution,"'This identifies when a user account successfully logs onto a given App and within 1 minute fails to logon to a different App.
This may indicate a malicious attempt at accessing disallowed Apps for discovery or potential lateral movement'
",AzureActiveDirectory,SigninLogs,"
let timeFrame = ago(1d);
let logonDiff = 1m;
let Success = SigninLogs 
| where TimeGenerated >= timeFrame 
| where ResultType == ""0"" 
| where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"", ""Office 365 SharePoint Online"")
| project SuccessLogonTime = TimeGenerated, UserPrincipalName, IPAddress , SuccessAppDisplayName = AppDisplayName;
let Fail = SigninLogs 
| where TimeGenerated >= timeFrame 
| where ResultType !in (""0"", ""50140"") 
| where ResultDescription !~ ""Other"" 
| where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"", ""Office 365 SharePoint Online"")
| project FailedLogonTime = TimeGenerated, UserPrincipalName, IPAddress , FailedAppDisplayName = AppDisplayName, ResultType, ResultDescription;
let InitialDataSet = 
Success | join kind= inner (
Fail
) on UserPrincipalName, IPAddress 
| where isnotempty(FailedAppDisplayName)
| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and SuccessAppDisplayName != FailedAppDisplayName;
let InitialHits = 
InitialDataSet
| summarize FailedLogonTime = min(FailedLogonTime), SuccessLogonTime = min(SuccessLogonTime) 
by UserPrincipalName, SuccessAppDisplayName, FailedAppDisplayName, IPAddress, ResultType, ResultDescription;
// Only take hits where there is 5 or less distinct AppDisplayNames on the success side as this limits highly active applications where failures occur more regularly
let Distribution =
InitialDataSet
| summarize count(SuccessAppDisplayName) by SuccessAppDisplayName, ResultType
| where count_SuccessAppDisplayName <= 5;
InitialHits | join (
   Distribution 
) on SuccessAppDisplayName, ResultType
| project UserPrincipalName, SuccessLogonTime, IPAddress, SuccessAppDisplayName, FailedLogonTime, FailedAppDisplayName, ResultType, ResultDescription 
| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessThenFail_SameUserDiffApp.yaml,2020-10-04,SuccessThenFail_SameUserDiffApp.yaml
9eb64924-ec8d-44d0-b1f2-10665150fb74,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1119,Automated Collection,Office 365,Hunting Query,Azure Sentinel Community Github,Bots added to multiple teams,"'This hunting query helps identify bots added to multiple Teams in a short space of time.
 This query is works with the built-in Teams data connector only.'
",Office365,OfficeActivity,"
// Adjust these thresholds to suit your environment.
let threshold = 2;
let time_threshold = timespan(5m);
let timeframe = 30d;
OfficeActivity
  | where TimeGenerated > ago(timeframe)
  | where OfficeWorkload =~ ""MicrosoftTeams""
  | where Operation =~ ""BotAddedToTeam""
  | summarize Start=max(TimeGenerated), End=min(TimeGenerated), Teams = makeset(TeamName)
  | extend CountOfTeams = array_length(Teams)
  | extend TimeDelta = End - Start 
  | where CountOfTeams > threshold
  | where TimeDelta >= time_threshold
  | project Start, End, Teams, CountOfTeams
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Teams/MultiTeamBot.yaml,2020-10-04,MultiTeamBot.yaml
bf76e508-9282-4cf1-9cc1-5c20c3dea2ee,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1119,Automated Collection,,Hunting Query,Azure Sentinel Community Github,Previously unseen bot or applicaiton added to Teams,"'This hunting query helps identify new, and potentially unapproved applications or bots 
being added to Teams.
This query requires you to have Teams data collected from the O365 Management Activity API
and the Teams parser function enabled.
More details: https://techcommunity.microsoft.com/t5/azure-sentinel/protecting-your-teams-with-azure-sentinel/ba-p/1265761'
",CustomConnector,CustomLogs_CL,"
// If you have more than 14 days worth of Teams data change this value
let data_date = 14d;
let historical_bots = (
TeamsData
| where CreationTime > ago(data_date)
| where isnotempty(AddOnName)
| project AddOnName);
TeamsData
| where CreationTime > ago(1d)
// Look for add-ins we have never seen before
| where AddOnName in (historical_bots)
// Uncomment the following line to map query entities is you plan to use this as a detection query
//| extend timestamp = CreationTime, AccountCustomEntity = UserId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/TeamsLogs/NewBotAdded.yaml,2020-10-04,NewBotAdded.yaml
3d6d0c04-7337-40cf-ace6-c471d442356d,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1566,Phishing,Office 365,Hunting Query,Azure Sentinel Community Github,User added to Team and immediately uploads file,"'This hunting queries identifies users who are added to a Team or Teams chat
and within 1 minute of being added upload a file via the chat. This might be
an indicator of suspicious activity.'
",Office365,OfficeActivity,"
let timeframe = 7d;
let threshold = 1m;
OfficeActivity
| where TimeGenerated > ago(timeframe)
| where OfficeWorkload =~ ""MicrosoftTeams""
| where Operation == ""MemberAdded""
| extend TeamName = iff(isempty(TeamName), Members[0].UPN, TeamName)
| project TimeGenerated, UploaderID=UserId, TeamName
| join (
  OfficeActivity
  | where TimeGenerated > ago(timeframe)
  | where RecordType == ""SharePointFileOperation""
  | where SourceRelativeUrl has ""Microsoft Teams Chat Files""
  | where Operation == ""FileUploaded""
  | project UploadTime=TimeGenerated, UploaderID=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName
  ) on UploaderID
| where UploadTime > TimeGenerated and UploadTime < TimeGenerated+threshold
| project-away UploaderID1
| extend timestamp=TimeGenerated, AccountCustomEntity = UserId 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Teams/TeamsUserAddUpload.yaml,2020-10-04,TeamsUserAddUpload.yaml
94588842-7e24-470e-97ef-983d8d85355c,2020-10-04 07:11:15.6720053,mitre-attack,InitialAccess,T1566,Phishing,Office 365,Hunting Query,Azure Sentinel Community Github,Summarize files uploads in a Teams chat,"'This hunting queries identifies files uploaded to SharePoint via a Teams chat and
summarizes users and IP addresses that have accessed these files. This allows for 
identification of anomolous file sharing patterns.'
",Office365,OfficeActivity,"
let timeframe = 7d;
OfficeActivity
| where TimeGenerated > ago(timeframe)
| where RecordType =~ ""SharePointFileOperation""
| where SourceRelativeUrl has ""Microsoft Teams Chat Files""
| where Operation =~ ""FileUploaded""
| join kind= leftouter (
  OfficeActivity
    | where TimeGenerated > ago(timeframe)
    | where RecordType =~ ""SharePointFileOperation""
    | where SourceRelativeUrl has ""Microsoft Teams Chat Files""
    | where Operation =~ ""FileDownloaded"" or Operation =~ ""FileAccessed""
) on OfficeObjectId
| extend userBag = pack(UserId1, ClientIP1)
| summarize make_set(UserId1), make_bag(userBag) by TimeGenerated, UserId, OfficeObjectId, SourceFileName
| project UploadTime=TimeGenerated, Uploader=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName, AccessedBy=bag_userBag
| extend timestamp=UploadTime, AccountCustomEntity=Uploader 
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Teams/FilesUploadedTeamsChat.yaml,2020-10-04,FilesUploadedTeamsChat.yaml
e0a67cd7-b4e5-4468-aae0-26cb16a1bbd2,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1484,Group Policy Modification,AWS,Hunting Query,Azure Sentinel Community Github,Changes made to AWS IAM policy,"Identity and Access Management (IAM) securely manages access to AWS services and resources. 
This query looks for when an API call is made to change an IAM, particularly those related to new policies being 
attached to users and roles, as well as changes to access methods and changes to account level policies. 
If these turn out to be noisy filter out the most common for your environment.  
",AWS,AWSCloudTrail,"
let timeframe = 7d;
AWSCloudTrail
| where TimeGenerated >= ago(timeframe)
| where  EventName in~ (""AttachGroupPolicy"", ""AttachRolePolicy"", ""AttachUserPolicy"", ""CreatePolicy"",
""DeleteGroupPolicy"", ""DeletePolicy"", ""DeleteRolePolicy"", ""DeleteUserPolicy"", ""DetachGroupPolicy"",
""PutUserPolicy"", ""PutGroupPolicy"", ""CreatePolicyVersion"", ""DeletePolicyVersion"", ""DetachRolePolicy"", ""CreatePolicy"")
| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityAccountId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_IAM_PolicyChange.yaml,2020-10-04,AWS_IAM_PolicyChange.yaml
e0d57543-acbd-428b-bb96-24a67506f84d,2020-10-04 07:11:15.6720053,mitre-attack,DefenseEvasion,T1535,Unused/Unsupported Cloud Regions,AWS,Hunting Query,Azure Sentinel Community Github,Unused or Unsupported Cloud Regions,"'Adversaries may create cloud instances in unused geographic service regions in order to evade detection. 
Access is usually obtained through compromising accounts used to manage cloud infrastructure.
Refer: https://attack.mitre.org/techniques/T1535/'
",AWS,AWSCloudTrail,"
let starttime = 14d;
let midtime = 2d;
let endtime = 1d;
// Generating historical table of all events per AccountId and Region
let EventInfo_CurrentDay =  materialize (AWSCloudTrail | where TimeGenerated >= ago(endtime));
let EventInfo_historical = AWSCloudTrail  | where TimeGenerated  between (ago(starttime)..ago(midtime)) | summarize max(TimeGenerated) by AWSRegion, UserIdentityAccountId; 
// Doing Leftanti join to find new regions historically not seen for the same account.
let EventInfo_Unseen = materialize (
EventInfo_CurrentDay
| summarize max(TimeGenerated) by AWSRegion, UserIdentityAccountId
| join kind= leftanti
(
  EventInfo_historical
) on AWSRegion, UserIdentityAccountId
);
EventInfo_Unseen
// Join Ununsed region seen with current data to gather context about API events seen
| join kind= inner (
   EventInfo_CurrentDay
) on AWSRegion, UserIdentityAccountId
| extend UnusedRegion = AWSRegion
| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))
| summarize EventCount = count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), EventNameList=make_set(EventName), IPList=make_set(SourceIpAddress) by UserIdentityAccountId, UnusedRegion, UserIdentityUserName
| extend timestamp = StartTime , AccountCustomEntity = UserIdentityUserName",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_Unused_UnsupportedCloudRegions.yaml,2020-10-04,AWS_Unused_UnsupportedCloudRegions.yaml
e4779bdc-397a-4b71-be28-59e6a1e1d16b,2020-10-04 07:11:15.6720053,mitre-attack,Discovery,T1040,Network Sniffing,,Detection,Azure Sentinel Community Github,Zoom E2E Encryption Disabled,"'This alerts when end to end encryption is disabled for Zoom meetings.'
",CustomConnector,CustomLogs_CL,"
let timeframe = 1d;
ZoomLogs  
| where TimeGenerated >= ago(timeframe)
| where Event =~ ""account.settings_updated""  
| extend OldE2ESetting = columnifexists(""payload_object_settings_in_meeting_e2e_encryption_b"", """")  
| extend NewE2ESetting = columnifexists(""payload_old_object_settings_in_meeting_e2e_encryption_b"", """")  
| where OldE2ESetting =~ 'false' and NewE2ESetting =~ 'true'
| extend timestamp = TimeGenerated, AccountCustomEntity = User
",1d,1d,gt,0.0,Medium,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/E2EEDisbaled.yaml,2020-10-04,E2EEDisbaled.yaml
669e1338-b1a2-4d73-b720-a1e60d5d1474,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1530,Data from Cloud Storage Object,,Hunting Query,Azure Sentinel Community Github,Suspicious Data Access to S3 Bucket from Unknown IP,"'Adversaries may access data objects from improperly secured cloud storage. This query will identify any access originating from a Source IP which was not seen historically accessing the bucket or downloading files from it.
You can also limit the query to only private buckets with sensitive files by setting the value or list of values to BucketName column.
Read more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash 
and AWS S3 API GetObject at https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html and ListObject at https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html
and ListBucket at https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListBuckets.html
S3 LogStash Config: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/Logstash/input-aws_s3-output-loganalytics.conf
S3 KQL Parser: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/AwsS3BucketAPILogsParser.txt'
",CustomConnector,CustomLogs_CL,"
let EventNameList = dynamic([""ListBucket"",""ListObjects"",""GetObject""]);
let starttime = 14d;
let midtime = 2d;
let endtime = 1d;
AwsBucketAPILogs_CL 
| where EventTime >= ago(endtime)
| where EventName in (EventNameList)
| project EventTime, EventSource,EventName, SourceIPAddress, UserIdentityType, UserIdentityArn, UserIdentityUserName, BucketName, Host, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName, Key
| join kind=leftanti
(
  AWSS3BucketAPILogParsed 
  | where EventTime between (ago(starttime)..ago(midtime))
  | where EventName in (EventNameList)
) on SourceIPAddress
| summarize EventCount=count(), StartTimeUtc = min(EventTime), EndTimeUtc = max(EventTime), Files= makeset(Key), EventNames = makeset(EventName) by EventSource, SourceIPAddress, UserIdentityType, UserIdentityArn, UserIdentityUserName, BucketName, Host, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName
| project StartTimeUtc, EndTimeUtc, EventSource, Host, SourceIPAddress, UserIdentityType, BucketName, EventNames, Files, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName, EventCount
| extend timestamp = StartTimeUtc, HostCustomEntity = Host, AccountCustomEntity = SessionUserName, IPCustomEntity = SourceIPAddress
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSS3/AWSBucketAPILogs-SuspiciousDataAccessToS3BucketsfromUnknownIP.yaml,2020-10-04,AWSBucketAPILogs-SuspiciousDataAccessToS3BucketsfromUnknownIP.yaml
79cf4646-0959-442f-9707-60fc66eb8145,2020-10-04 07:11:15.6720053,mitre-attack,Persistence,T1109,Component Firmware,,Hunting Query,Azure Sentinel Community Github,Zoom room high CPU alerts,"'This hunting query identifies Zoom room systems with high CPU alerts that may be a sign of device compromise.'
",CustomConnector,CustomLogs_CL,"
let hunt_time = 14d; 
ZoomLogs 
| where TimeGenerated >= ago(hunt_time) 
| where Event =~ ""zoomroom.alert"" 
| extend AlertType = toint(parse_json(RoomEvents).AlertType), AlertKind = toint(parse_json(RoomEvents).AlertKind) 
| extend RoomName = payload_object_room_name_s, User = payload_object_email_s
| where AlertType == 1 and AlertKind == 1 
| extend timestamp = TimeGenerated, AccountCustomEntity = User
// Uncomment the lines below to analyse event over time
//| summarize count() by bin(TimeGenerated, 1h), RoomName
//| render timechart
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/HighCPURoom.yaml,2020-10-04,HighCPURoom.yaml
467e6a70-adc9-49b7-8cf3-f21927c71159,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1537,Transfer Data to Cloud Account,,Hunting Query,Azure Sentinel Community Github,GitHub OAuth App Restrictions Disabled,"'This hunting query identifies a fork activity against a repository done by a user who is not the owner of the repo nor a contributes.'
",CustomConnector,CustomLogs_CL,"
let RunTime = 1h; 
let CollaboratorsUserToRepoMapping = (
GitHubRepo
| where TimeGenerated < ago(RunTime)
| where Action == ""Collaborators""
| distinct Repository , Actor, Organization);
let UserCommitsInRepoMapping = (
GitHubRepo
| where Action == ""Commits""
| where TimeGenerated < ago(RunTime)
| distinct  Repository ,Actor, Organization);
union CollaboratorsUserToRepoMapping, UserCommitsInRepoMapping
| summarize ContributedToRepos = make_set(Repository) by Actor, Organization
| join kind=innerunique (
GitHubRepo
| where TimeGenerated > ago(RunTime)
| where Action == ""Forks""
| distinct Repository , Actor, Organization
) on Actor, Organization
| project-away Actor1, Organization1
| where ContributedToRepos !contains Repository
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Suspicious%20Fork%20Activity.yaml,2020-10-04,Suspicious%20Fork%20Activity.yaml
f18c4dfb-4fa6-4a9d-9bd3-f7569d1d685a,2020-10-04 07:11:15.6720053,,PrivilegeEscalation,T10178,,,Hunting Query,Azure Sentinel Community Github,GitHub User Grants Access and Other User Grants Access,"'This hunting query identifies Accounts in GitHub that have granted access to another account which then grants access to yet another account that may be a sign of compromise.'
",CustomConnector,CustomLogs_CL,"
GitHubAudit
| where ImpactedUser != """"
| where Action == ""org.invite_member"" or Action == ""org.add_member"" or Action == ""team.add_member"" or Action == ""repo.add_member""
| distinct ImpactedUser, TimeGenerated, Actor
| project-rename firstUserAdded = ImpactedUser, firstEventTime = TimeGenerated, firstAdderUser = Actor
| join kind= innerunique (
  GitHubAudit
  | where ImpactedUser != """"
  | where Action == ""org.invite_member"" or Action == ""org.add_member"" or Action == ""team.add_member"" or Action == ""repo.add_member""
  | distinct ImpactedUser, TimeGenerated, Actor
  | project-rename secondUserAdded = ImpactedUser, secondEventTime = TimeGenerated, secondAdderUser = Actor
) on $right.secondAdderUser == $left.firstUserAdded
| where secondEventTime between (firstEventTime .. (firstEventTime + 1h))
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/User%20Grant%20Access%20and%20Grants%20Other%20Access.yaml,2020-10-04,User%20Grant%20Access%20and%20Grants%20Other%20Access.yaml
,2020-10-04 07:11:15.6720053,mitre-attack,,,Data Compressed,,,,,,,,,,,,,,,,
cd11d6a1-e2ad-47fa-9a9f-4c70b143d4fd,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,,Hunting Query,Azure Sentinel Community Github,Multiple large queries made by user,"'This hunting query looks for users who are running multiple queries that return either a very large 
amount of data or the maximum amount allowed by the query method.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let UI_apps = dynamic(['ASI_Portal','AzureMonitorLogsConnector','AppAnalytics']);
let threshold = 3;
let timeframe = 1d;
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where (ResponseRowCount == 10001 and RequestClientApp in(UI_apps)) or (ResponseRowCount > 10001 and RequestClientApp !in(UI_apps))
| summarize count() by AADEmail
| where count_ > threshold
| join kind=rightsemi (
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where (ResponseRowCount == 10001 and RequestClientApp in(UI_apps)) or (ResponseRowCount > 10001 and RequestClientApp !in(UI_apps)))
on AADEmail
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/MultipleLargeQueriesByUser.yaml,2020-10-04,MultipleLargeQueriesByUser.yaml
97543188-a4e8-4439-980d-17b231149617,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,,Hunting Query,Azure Sentinel Community Github,Query data volume anomolies,"'This hunting query looks for anomalously large LA queries by users.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let lookback = 7d;
let threshold = 0;
LAQueryLogs
| make-series rows = sum(ResponseRowCount) on TimeGenerated in range(startofday(ago(lookback)), now(), 1h)
| extend (anomalies, score, baseline) = series_decompose_anomalies(rows,3, -1, 'linefit')
| mv-expand anomalies to typeof(int), score to typeof(double), TimeGenerated to typeof(datetime)
| where anomalies > threshold 
| sort by score desc
| join kind=rightsemi (
LAQueryLogs
| summarize make_set(QueryText) by AADEmail, RequestTarget, TimeGenerated = bin(TimeGenerated, 1h))
on TimeGenerated
| project TimeGenerated, AADEmail, RequestTarget, set_QueryText
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/QueryDataVolumeAnomolies.yaml,2020-10-04,QueryDataVolumeAnomolies.yaml
8699df3f-f89e-431f-9dea-056c4ce7014a,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1030,Data Transfer Size Limits,,Hunting Query,Azure Sentinel Community Github,User returning more data than daily average,"'This hunting query looks for users whose total returned data for a day is significantly above their monthly average.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let threshold = 10;
let lookback = 7d;
let timeframe = 1d;
let baseline = 10000;
let diff = 5;
let anomolous_users = (
LAQueryLogs
| where TimeGenerated between(startofday(ago(lookback))..startofday(ago(timeframe)))
| summarize score=sum(ResponseRowCount) by AADEmail
| join kind = fullouter (LAQueryLogs
| where TimeGenerated > startofday(ago(timeframe))
| summarize score_now=sum(ResponseRowCount) by AADEmail)
on AADEmail
| extend hist_score = iif((score/29)*threshold > baseline, (score/29)*threshold, baseline)
| where isnotempty(score)
| where score_now > hist_score*diff
| project AADEmail);
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where AADEmail in(anomolous_users)
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail
// Comment out the line below to see the queries run by users.
| summarize total_rows = sum(ResponseRowCount), NoQueries = count(), AvgQuerySize = sum(ResponseRowCount)/count() by AADEmail
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/UserReturningMoreDataThanDailyAverage.yaml,2020-10-04,UserReturningMoreDataThanDailyAverage.yaml
f8ab176c-1f3f-4cb5-8dc1-f50d30bcae0d,2020-10-04 07:11:15.6720053,mitre-attack,Execution,T1059,Command and Scripting Interpreter,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous Code Execution,"'Adversaries may abuse command and script interpreters to execute commands, scripts, or binaries. These interfaces and languages provide ways of interacting with computer systems and are a common feature across many different platforms. APT19, for example, used PowerShell commands to execute payloads. The query below generates an output of all users performing an ""action"" operation regarding ""runCommand"" in virtual machines, where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,BehaviorAnalytics,"let operations = dynamic(['Run Command on Virtual Machine']);
BehaviorAnalytics
| where ActionType in(operations)
| where ActivityInsights has ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Code%20Execution.yaml,2020-10-04,Anomalous%20Code%20Execution.yaml
a2fca6ac-1155-4eec-934b-65aa62cdbb09,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1020,Automated Exfiltration,,Hunting Query,Azure Sentinel Community Github,User running multiple queries that fail,"'This hunting query looks for users who have multiple failed queries in a short space of time.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let lookback = 7d;
let timeframe = 1h;
let threshold = 10;
LAQueryLogs
| where TimeGenerated > ago(lookback)
| where ResponseCode != 200
| summarize count() by AADEmail, bin(TimeGenerated, timeframe)
| where count_ > threshold
| join kind=rightsemi ( 
LAQueryLogs
| where TimeGenerated > ago(lookback)
| summarize make_set(QueryText) by AADEmail, bin(TimeGenerated, timeframe))
on AADEmail, TimeGenerated
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/UserRunningMultipleQueriesThatFail.yaml,2020-10-04,UserRunningMultipleQueriesThatFail.yaml
8cf3c78e-cd10-4bfb-bd69-d62dc7f375f1,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1530,Data from Cloud Storage Object,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous Data Access,"'Adversaries may access data objects from cloud storage.  The query below generates an output of all users performing a ""read"" operation regarding data or files, where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,BehaviorAnalytics,"let operations = dynamic(['Export an existing database']);
BehaviorAnalytics
| where ActionType in(operations)
| where ActivityInsights has ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Data%20Access.yaml,2020-10-04,Anomalous%20Data%20Access.yaml
f7f4a77e-f68f-4b56-9aaf-a0c9d87d7a8e,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1213,Data from Information Repositories,,Detection,Azure Sentinel Community Github,Users searching for VIP user activity,"This query monitors for users running Log Analytics queries that contain filters 
for specific, defined VIP user accounts. Use this detection to alert for users specifically 
searching for activity of sensitive users.
",AzureMonitor(Query Audit),LAQueryLogs,"
// Replace these with the usename or emails of your VIP users you wish to monitor for.
let vips = dynamic(['vip1@email.com','vip2@email.com']);
let timeframe = 1d;
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where QueryText has_any (vips)
| project TimeGenerated, AADEmail, RequestClientApp, QueryText, ResponseRowCount, RequestTarget
",1d,1d,gt,0.0,Low,https://github.com/Azure/Azure-Sentinel/blob/master/Detections/LAQueryLogs/UserSearchingForVIPUserActivity.yaml,2020-10-04,UserSearchingForVIPUserActivity.yaml
98e4df23-7bd2-480d-814a-a03f77efc670,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,New ServicePrincipal running queries,"'This hunting query looks for new Service Principals running queries that have not previously been seen running queries.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let lookback = 7d;
let timeframe = 1d;
LAQueryLogs
| where TimeGenerated between (ago(lookback)..ago(timeframe))
| where ResponseCode == 200 and RequestClientApp != ""AppAnalytics"" and AADEmail !contains ""@""
| distinct AADClientId 
| join kind=rightanti( 
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where ResponseCode == 200 and RequestClientApp != ""AppAnalytics"" and AADEmail !contains ""@""
)
on AADClientId
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewServicePrincipalRunningQueries.yaml,2020-10-04,NewServicePrincipalRunningQueries.yaml
8f18c6ea-fcd0-4d9a-a8fd-19a6aaa1660c,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,Cross workspace query anomolies,"'This hunting query looks for increases in the number of workspaces queried by a user.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let lookback = 30d;
let timeframe = 1d;
let threshold = 0;
LAQueryLogs
| where TimeGenerated between (ago(lookback)..ago(timeframe))
| mv-expand(RequestContext)
| extend RequestContextExtended = split(RequestTarget, ""/"") 
| extend Subscription = tostring(RequestContextExtended[2]), ResourceGroups = tostring(RequestContextExtended[4]), Workspace = tostring(RequestContextExtended[8])
| summarize count(), HistWorkspaceCount=dcount(Workspace) by AADEmail
| join (
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| mv-expand(RequestContext)
| extend RequestContextExtended = split(RequestTarget, ""/"") 
| extend Subscription = tostring(RequestContextExtended[2]), ResourceGroups = tostring(RequestContextExtended[4]), Workspace = tostring(RequestContextExtended[8])
| summarize make_set(Workspace), count(), CurrWorkspaceCount=dcount(Workspace) by AADEmail
) on AADEmail
| where CurrWorkspaceCount > HistWorkspaceCount
// Uncomment follow rows to see queries made by these users
//| join (
//LAQueryLogs
//| where TimeGenerated > ago(timeframe))
//on AADEmail
//| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/CrossWorkspaceQueryAnomolies.yaml,2020-10-04,CrossWorkspaceQueryAnomolies.yaml
8c4fb385-98b0-4ef5-b3da-65db0fb22d89,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,New users running queries,"'This hunting query looks for users who have run queries that have not previously been seen running queries.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let lookback = 7d;
let timeframe = 1d;
LAQueryLogs
| where TimeGenerated between(startofday(ago(lookback))..startofday(ago(timeframe)))
| summarize by AADEmail
| join kind = rightanti (LAQueryLogs
| where TimeGenerated > ago(timeframe))
on AADEmail
| project TimeGenerated, AADEmail, QueryText, RequestClientApp, RequestTarget
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewUserRunningQueries.yaml,2020-10-04,NewUserRunningQueries.yaml
2bf19f27-0466-4c16-a821-ce84e524476d,2020-10-04 07:11:15.6720053,mitre-attack,Collection,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,Query looking for secrets,"'This hunting query looks for queries that appear to be looking for secrets or passwords in tables.'
",AzureMonitor(Query Audit),LAQueryLogs,"
// Extend this list with items to search for
let keywords = dynamic([""password"", ""pwd"", ""creds"", ""credentials"", ""secret""]);
// To exclude key phrases or tables to exclude add to these lists
let table_exclusions = dynamic([""AuditLogs"",""SigninLogs"", ""LAQueryLogs"", ""SecurityEvent""]);
let keyword_exclusion = dynamic([""reset user password"", ""change user password""]);
let timeframe = 7d;
LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where RequestClientApp != 'Sentinel-General'
| extend querytext_lower = tolower(QueryText)
| where querytext_lower has_any(keywords)
| project TimeGenerated, AADEmail, QueryText, RequestClientApp, RequestTarget, ResponseCode, ResponseRowCount, ResponseDurationMs, CorrelationId
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail
| join kind=leftanti ( LAQueryLogs
| where TimeGenerated > ago(timeframe)
| where RequestClientApp != 'Sentinel-General'
| extend querytext_lower = tolower(QueryText)
| where QueryText has_any(table_exclusions) or querytext_lower has_any(keyword_exclusion))
on CorrelationId
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/QueryLookingForSecrets.yaml,2020-10-04,QueryLookingForSecrets.yaml
1dd98313-f43f-4d8b-9870-5a1dfb2cf93f,2020-10-04 07:11:15.6720053,mitre-attack,Exfiltration,T1213,Data from Information Repositories,,Hunting Query,Azure Sentinel Community Github,New client running queries,"'This hunting query looks for clients running queries that have not previously been seen running queries.'
",AzureMonitor(Query Audit),LAQueryLogs,"
let lookback = 7d;
let timeframe = 1d;
LAQueryLogs
| where TimeGenerated between (ago(lookback)..ago(timeframe))
| where ResponseCode == 200
| join kind= rightanti( 
LAQueryLogs
| where TimeGenerated > ago(timeframe)
)
on RequestClientApp
| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewClientRunningQueries.yaml,2020-10-04,NewClientRunningQueries.yaml
fcb704ae-ac17-400a-9ed9-3c46bd0a3960,2020-10-04 07:11:15.6720053,mitre-attack,Defense Evasion,T1562,Impair Defenses,Azure,Hunting Query,Azure Sentinel Community Github,Anomalous Defensive Mechanism Modification,"'Adversaries may disable security tools to avoid possible detection of their tools and activities. DarkComet, for example, can disable Security Center functions like anti-virus. The query below generates an output of all users performing a ""delete"" operation regarding a security policy, where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'
",BehaviorAnalytics,BehaviorAnalytics,"let operations = dynamic(['Remove database vulnerability assessment rule baseline']);
BehaviorAnalytics
| where ActionType in(operations)
| where ActivityInsights has ""True""
| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,ActivityInsights ,SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights
",,,,,,https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/BehaviorAnalytics/Anomalous%20Defensive%20Mechanism%20Modification.yaml,2020-10-04,Anomalous%20Defensive%20Mechanism%20Modification.yaml